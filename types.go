// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	time "time"
)

type AddCustomHostname struct {
	// The custom hostname to attach to the project
	Hostname string `json:"hostname"`
}

// Error response model
type ApiErrorResponse struct {
	// Error code
	Code string `json:"code"`
	// Status code
	Status float64 `json:"status"`
	// Error description
	Message string                `json:"message"`
	Data    *ApiErrorResponseData `json:"data,omitempty"`
}

type ApiErrorResponseData struct {
}

type ApiKeyIntegrationConfigs struct {
	HeaderKey string `json:"header_key"`
	ApiKey    string `json:"api_key"`
}

type AttachedIntegrationToSource struct {
	Success bool `json:"success"`
}

// Error code of the delivery attempt
type AttemptErrorCodes string

const (
	AttemptErrorCodesCancelled                AttemptErrorCodes = "CANCELLED"
	AttemptErrorCodesTimeout                  AttemptErrorCodes = "TIMEOUT"
	AttemptErrorCodesNotFound                 AttemptErrorCodes = "NOT_FOUND"
	AttemptErrorCodesConnectionRefused        AttemptErrorCodes = "CONNECTION_REFUSED"
	AttemptErrorCodesConnectionReset          AttemptErrorCodes = "CONNECTION_RESET"
	AttemptErrorCodesMissingUrl               AttemptErrorCodes = "MISSING_URL"
	AttemptErrorCodesCli                      AttemptErrorCodes = "CLI"
	AttemptErrorCodesCliUnavailable           AttemptErrorCodes = "CLI_UNAVAILABLE"
	AttemptErrorCodesSelfSignedCert           AttemptErrorCodes = "SELF_SIGNED_CERT"
	AttemptErrorCodesErrTlsCertAltnameInvalid AttemptErrorCodes = "ERR_TLS_CERT_ALTNAME_INVALID"
	AttemptErrorCodesErrSslWrongVersionNumber AttemptErrorCodes = "ERR_SSL_WRONG_VERSION_NUMBER"
	AttemptErrorCodesSslErrorCaUnknown        AttemptErrorCodes = "SSL_ERROR_CA_UNKNOWN"
	AttemptErrorCodesTtlExpired               AttemptErrorCodes = "TTL_EXPIRED"
	AttemptErrorCodesDataArchived             AttemptErrorCodes = "DATA_ARCHIVED"
	AttemptErrorCodesSslCertExpired           AttemptErrorCodes = "SSL_CERT_EXPIRED"
	AttemptErrorCodesBulkRetryCancelled       AttemptErrorCodes = "BULK_RETRY_CANCELLED"
	AttemptErrorCodesDnsLookupFailed          AttemptErrorCodes = "DNS_LOOKUP_FAILED"
	AttemptErrorCodesHostUnreachable          AttemptErrorCodes = "HOST_UNREACHABLE"
	AttemptErrorCodesProtocolError            AttemptErrorCodes = "PROTOCOL_ERROR"
	AttemptErrorCodesSocketClosed             AttemptErrorCodes = "SOCKET_CLOSED"
	AttemptErrorCodesOauth2HandshakeFailed    AttemptErrorCodes = "OAUTH2_HANDSHAKE_FAILED"
	AttemptErrorCodesUnknown                  AttemptErrorCodes = "UNKNOWN"
)

func NewAttemptErrorCodesFromString(s string) (AttemptErrorCodes, error) {
	switch s {
	case "CANCELLED":
		return AttemptErrorCodesCancelled, nil
	case "TIMEOUT":
		return AttemptErrorCodesTimeout, nil
	case "NOT_FOUND":
		return AttemptErrorCodesNotFound, nil
	case "CONNECTION_REFUSED":
		return AttemptErrorCodesConnectionRefused, nil
	case "CONNECTION_RESET":
		return AttemptErrorCodesConnectionReset, nil
	case "MISSING_URL":
		return AttemptErrorCodesMissingUrl, nil
	case "CLI":
		return AttemptErrorCodesCli, nil
	case "CLI_UNAVAILABLE":
		return AttemptErrorCodesCliUnavailable, nil
	case "SELF_SIGNED_CERT":
		return AttemptErrorCodesSelfSignedCert, nil
	case "ERR_TLS_CERT_ALTNAME_INVALID":
		return AttemptErrorCodesErrTlsCertAltnameInvalid, nil
	case "ERR_SSL_WRONG_VERSION_NUMBER":
		return AttemptErrorCodesErrSslWrongVersionNumber, nil
	case "SSL_ERROR_CA_UNKNOWN":
		return AttemptErrorCodesSslErrorCaUnknown, nil
	case "TTL_EXPIRED":
		return AttemptErrorCodesTtlExpired, nil
	case "DATA_ARCHIVED":
		return AttemptErrorCodesDataArchived, nil
	case "SSL_CERT_EXPIRED":
		return AttemptErrorCodesSslCertExpired, nil
	case "BULK_RETRY_CANCELLED":
		return AttemptErrorCodesBulkRetryCancelled, nil
	case "DNS_LOOKUP_FAILED":
		return AttemptErrorCodesDnsLookupFailed, nil
	case "HOST_UNREACHABLE":
		return AttemptErrorCodesHostUnreachable, nil
	case "PROTOCOL_ERROR":
		return AttemptErrorCodesProtocolError, nil
	case "SOCKET_CLOSED":
		return AttemptErrorCodesSocketClosed, nil
	case "OAUTH2_HANDSHAKE_FAILED":
		return AttemptErrorCodesOauth2HandshakeFailed, nil
	case "UNKNOWN":
		return AttemptErrorCodesUnknown, nil
	}
	var t AttemptErrorCodes
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptErrorCodes) Ptr() *AttemptErrorCodes {
	return &a
}

type AttemptState string

const (
	AttemptStateDelivering AttemptState = "DELIVERING"
	AttemptStateQueued     AttemptState = "QUEUED"
	AttemptStatePending    AttemptState = "PENDING"
	AttemptStateCompleted  AttemptState = "COMPLETED"
	AttemptStateHold       AttemptState = "HOLD"
)

func NewAttemptStateFromString(s string) (AttemptState, error) {
	switch s {
	case "DELIVERING":
		return AttemptStateDelivering, nil
	case "QUEUED":
		return AttemptStateQueued, nil
	case "PENDING":
		return AttemptStatePending, nil
	case "COMPLETED":
		return AttemptStateCompleted, nil
	case "HOLD":
		return AttemptStateHold, nil
	}
	var t AttemptState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptState) Ptr() *AttemptState {
	return &a
}

// Attempt status
type AttemptStatus string

const (
	AttemptStatusQueued     AttemptStatus = "QUEUED"
	AttemptStatusFailed     AttemptStatus = "FAILED"
	AttemptStatusSuccessful AttemptStatus = "SUCCESSFUL"
	AttemptStatusHold       AttemptStatus = "HOLD"
)

func NewAttemptStatusFromString(s string) (AttemptStatus, error) {
	switch s {
	case "QUEUED":
		return AttemptStatusQueued, nil
	case "FAILED":
		return AttemptStatusFailed, nil
	case "SUCCESSFUL":
		return AttemptStatusSuccessful, nil
	case "HOLD":
		return AttemptStatusHold, nil
	}
	var t AttemptStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptStatus) Ptr() *AttemptStatus {
	return &a
}

// How the attempt was triggered
type AttemptTrigger string

const (
	AttemptTriggerInitial   AttemptTrigger = "INITIAL"
	AttemptTriggerManual    AttemptTrigger = "MANUAL"
	AttemptTriggerBulkRetry AttemptTrigger = "BULK_RETRY"
	AttemptTriggerUnpause   AttemptTrigger = "UNPAUSE"
	AttemptTriggerAutomatic AttemptTrigger = "AUTOMATIC"
)

func NewAttemptTriggerFromString(s string) (AttemptTrigger, error) {
	switch s {
	case "INITIAL":
		return AttemptTriggerInitial, nil
	case "MANUAL":
		return AttemptTriggerManual, nil
	case "BULK_RETRY":
		return AttemptTriggerBulkRetry, nil
	case "UNPAUSE":
		return AttemptTriggerUnpause, nil
	case "AUTOMATIC":
		return AttemptTriggerAutomatic, nil
	}
	var t AttemptTrigger
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptTrigger) Ptr() *AttemptTrigger {
	return &a
}

// API Key
type AuthApiKey struct {
	Config *DestinationAuthMethodApiKeyConfig `json:"config,omitempty"`
}

// AWS Signature
type AuthAwsSignature struct {
	Config *DestinationAuthMethodAwsSignatureConfig `json:"config,omitempty"`
}

// Basic Auth
type AuthBasicAuth struct {
	Config *DestinationAuthMethodBasicAuthConfig `json:"config,omitempty"`
}

// Bearer Token
type AuthBearerToken struct {
	Config *DestinationAuthMethodBearerTokenConfig `json:"config,omitempty"`
}

// Custom Signature
type AuthCustomSignature struct {
	Config *DestinationAuthMethodCustomSignatureConfig `json:"config,omitempty"`
}

// Hookdeck Signature
type AuthHookdeckSignature struct {
	Config *DestinationAuthMethodSignatureConfig `json:"config,omitempty"`
}

// OAuth2 Authorization Code
type AuthOAuth2AuthorizationCode struct {
	Config *DestinationAuthMethodOAuth2AuthorizationCodeConfig `json:"config,omitempty"`
}

// OAuth2 Client Credentials
type AuthOAuth2ClientCredentials struct {
	Config *DestinationAuthMethodOAuth2ClientCredentialsConfig `json:"config,omitempty"`
}

type BasicAuthIntegrationConfigs struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type BatchOperation struct {
	// ID of the bulk retry
	Id string `json:"id"`
	// ID of the project
	TeamId string `json:"team_id"`
	// Query object to filter records
	Query *BatchOperationQuery `json:"query,omitempty"`
	// Date the bulk retry was created
	CreatedAt time.Time `json:"created_at"`
	// Last time the bulk retry was updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the bulk retry was cancelled
	CancelledAt *time.Time `json:"cancelled_at,omitempty"`
	// Date the bulk retry was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Number of batches currently processed
	ProcessedBatch *int `json:"processed_batch,omitempty"`
	// Number of events that were successfully delivered
	CompletedCount *int `json:"completed_count,omitempty"`
	// Indicates if the bulk retry is currently in progress
	InProgress bool `json:"in_progress"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
	// Number of events that failed to be delivered
	FailedCount *int     `json:"failed_count,omitempty"`
	Number      *float64 `json:"number,omitempty"`
}

type BatchOperationPaginatedResult struct {
	Pagination *SeekPagination   `json:"pagination,omitempty"`
	Count      *int              `json:"count,omitempty"`
	Models     []*BatchOperation `json:"models,omitempty"`
}

// Query object to filter records
type BatchOperationQuery struct {
	typeName         string
	StringUnknownMap map[string]interface{}
	StringOptional   *string
}

func NewBatchOperationQueryFromStringUnknownMap(value map[string]interface{}) *BatchOperationQuery {
	return &BatchOperationQuery{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func NewBatchOperationQueryFromStringOptional(value *string) *BatchOperationQuery {
	return &BatchOperationQuery{typeName: "stringOptional", StringOptional: value}
}

func (b *BatchOperationQuery) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		b.typeName = "stringUnknownMap"
		b.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		b.typeName = "stringOptional"
		b.StringOptional = valueStringOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BatchOperationQuery) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "stringUnknownMap":
		return json.Marshal(b.StringUnknownMap)
	case "stringOptional":
		return json.Marshal(b.StringOptional)
	}
}

type BatchOperationQueryVisitor interface {
	VisitStringUnknownMap(map[string]interface{}) error
	VisitStringOptional(*string) error
}

func (b *BatchOperationQuery) Accept(visitor BatchOperationQueryVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(b.StringUnknownMap)
	case "stringOptional":
		return visitor.VisitStringOptional(b.StringOptional)
	}
}

type Bookmark struct {
	// ID of the bookmark
	Id string `json:"id"`
	// ID of the project
	TeamId string `json:"team_id"`
	// ID of the associated connection
	WebhookId string `json:"webhook_id"`
	// ID of the bookmarked event data
	EventDataId string `json:"event_data_id"`
	// Descriptive name of the bookmark
	Label string `json:"label"`
	// Alternate alias for the bookmark
	Alias *string         `json:"alias,omitempty"`
	Data  *ShortEventData `json:"data,omitempty"`
	// Date the bookmark was last manually triggered
	LastUsedAt *time.Time `json:"last_used_at,omitempty"`
	// Date the bookmark was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the bookmark was created
	CreatedAt time.Time `json:"created_at"`
}

type BookmarkPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Bookmark     `json:"models,omitempty"`
}

type Connection struct {
	// ID of the connection
	Id string `json:"id"`
	// Unique name of the connection for this source
	Name *string `json:"name,omitempty"`
	// Full name of the connection concatenated from source, connection and desitnation name
	FullName *string `json:"full_name,omitempty"`
	// Description of the connection
	Description *string `json:"description,omitempty"`
	// ID of the project
	TeamId      string       `json:"team_id"`
	Destination *Destination `json:"destination,omitempty"`
	Source      *Source      `json:"source,omitempty"`
	// Array of rules configured on the connection
	Rules []*Rule `json:"rules,omitempty"`
	// Date the connection was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty"`
	// Date the connection was paused
	PausedAt *time.Time `json:"paused_at,omitempty"`
	// Date the connection was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the connection was created
	CreatedAt time.Time `json:"created_at"`
}

type ConnectionPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Connection   `json:"models,omitempty"`
}

type ConsoleLine struct {
	Type    ConsoleLineType `json:"type,omitempty"`
	Message string          `json:"message"`
}

type ConsoleLineType string

const (
	ConsoleLineTypeError ConsoleLineType = "error"
	ConsoleLineTypeLog   ConsoleLineType = "log"
	ConsoleLineTypeWarn  ConsoleLineType = "warn"
	ConsoleLineTypeInfo  ConsoleLineType = "info"
	ConsoleLineTypeDebug ConsoleLineType = "debug"
)

func NewConsoleLineTypeFromString(s string) (ConsoleLineType, error) {
	switch s {
	case "error":
		return ConsoleLineTypeError, nil
	case "log":
		return ConsoleLineTypeLog, nil
	case "warn":
		return ConsoleLineTypeWarn, nil
	case "info":
		return ConsoleLineTypeInfo, nil
	case "debug":
		return ConsoleLineTypeDebug, nil
	}
	var t ConsoleLineType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConsoleLineType) Ptr() *ConsoleLineType {
	return &c
}

type DelayRule struct {
	// Delay to introduce in MS
	Delay int `json:"delay"`
}

type DeleteCustomDomainSchema struct {
	// The custom hostname ID
	Id string `json:"id"`
}

type DeletedBookmarkResponse struct {
	// Bookmark ID
	Id string `json:"id"`
}

type DeletedIntegration struct {
	Id string `json:"id"`
}

type DeletedIssueTriggerResponse struct {
	Id string `json:"id"`
}

// Delivery issue
type DeliveryIssue struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the project
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// Deprecated, will always be set to null
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                        `json:"created_at"`
	AggregationKeys *DeliveryIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *DeliveryIssueReference       `json:"reference,omitempty"`
}

// Keys used as the aggregation keys a 'delivery' type issue
type DeliveryIssueAggregationKeys struct {
	WebhookId      []string            `json:"webhook_id,omitempty"`
	ResponseStatus []float64           `json:"response_status,omitempty"`
	ErrorCode      []AttemptErrorCodes `json:"error_code,omitempty"`
}

// Delivery issue data
type DeliveryIssueData struct {
	TriggerEvent   *Event        `json:"trigger_event,omitempty"`
	TriggerAttempt *EventAttempt `json:"trigger_attempt,omitempty"`
}

// Reference to the event and attempt an issue is being created for.
type DeliveryIssueReference struct {
	EventId   string `json:"event_id"`
	AttemptId string `json:"attempt_id"`
}

// Delivery issue
type DeliveryIssueWithData struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the project
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// Deprecated, will always be set to null
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                        `json:"created_at"`
	AggregationKeys *DeliveryIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *DeliveryIssueReference       `json:"reference,omitempty"`
	Data            *DeliveryIssueData            `json:"data,omitempty"`
}

// Associated [Destination](#destination-object) object
type Destination struct {
	// ID of the destination
	Id string `json:"id"`
	// A unique, human-friendly name for the destination
	Name string `json:"name"`
	// Description of the destination
	Description *string `json:"description,omitempty"`
	// ID of the project
	TeamId                 string `json:"team_id"`
	PathForwardingDisabled *bool  `json:"path_forwarding_disabled,omitempty"`
	// HTTP endpoint of the destination
	Url *string `json:"url,omitempty"`
	// Path for the CLI destination
	CliPath *string `json:"cli_path,omitempty"`
	// Limit delivery rate of event attempts to receive per period.
	RateLimit       *int                         `json:"rate_limit,omitempty"`
	RateLimitPeriod *DestinationRateLimitPeriod  `json:"rate_limit_period,omitempty"`
	HttpMethod      *DestinationHttpMethod       `json:"http_method,omitempty"`
	AuthMethod      *DestinationAuthMethodConfig `json:"auth_method,omitempty"`
	// Date the destination was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty"`
	// Date the destination was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the destination was created
	CreatedAt time.Time `json:"created_at"`
}

// API key config for the destination's auth method
type DestinationAuthMethodApiKeyConfig struct {
	// Key for the API key auth
	Key string `json:"key"`
	// API key for the API key auth
	ApiKey string `json:"api_key"`
	// Whether the API key should be sent as a header or a query parameter
	To *DestinationAuthMethodApiKeyConfigTo `json:"to,omitempty"`
}

// Whether the API key should be sent as a header or a query parameter
type DestinationAuthMethodApiKeyConfigTo string

const (
	DestinationAuthMethodApiKeyConfigToHeader DestinationAuthMethodApiKeyConfigTo = "header"
	DestinationAuthMethodApiKeyConfigToQuery  DestinationAuthMethodApiKeyConfigTo = "query"
)

func NewDestinationAuthMethodApiKeyConfigToFromString(s string) (DestinationAuthMethodApiKeyConfigTo, error) {
	switch s {
	case "header":
		return DestinationAuthMethodApiKeyConfigToHeader, nil
	case "query":
		return DestinationAuthMethodApiKeyConfigToQuery, nil
	}
	var t DestinationAuthMethodApiKeyConfigTo
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationAuthMethodApiKeyConfigTo) Ptr() *DestinationAuthMethodApiKeyConfigTo {
	return &d
}

// AWS Signature config for the destination's auth method
type DestinationAuthMethodAwsSignatureConfig struct {
	// AWS access key id
	AccessKeyId string `json:"access_key_id"`
	// AWS secret access key
	SecretAccessKey string `json:"secret_access_key"`
}

// Basic auth config for the destination's auth method
type DestinationAuthMethodBasicAuthConfig struct {
	// Username for basic auth
	Username string `json:"username"`
	// Password for basic auth
	Password string `json:"password"`
}

// Bearer token config for the destination's auth method
type DestinationAuthMethodBearerTokenConfig struct {
	// Token for the bearer token auth
	Token string `json:"token"`
}

// Config for the destination's auth method
type DestinationAuthMethodConfig struct {
	Type                    string
	HookdeckSignature       *AuthHookdeckSignature
	BasicAuth               *AuthBasicAuth
	ApiKey                  *AuthApiKey
	BearerToken             *AuthBearerToken
	Oauth2ClientCredentials *AuthOAuth2ClientCredentials
	Oauth2AuthorizationCode *AuthOAuth2AuthorizationCode
	CustomSignature         *AuthCustomSignature
	AwsSignature            *AuthAwsSignature
}

func NewDestinationAuthMethodConfigFromHookdeckSignature(value *AuthHookdeckSignature) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "HOOKDECK_SIGNATURE", HookdeckSignature: value}
}

func NewDestinationAuthMethodConfigFromBasicAuth(value *AuthBasicAuth) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "BASIC_AUTH", BasicAuth: value}
}

func NewDestinationAuthMethodConfigFromApiKey(value *AuthApiKey) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "API_KEY", ApiKey: value}
}

func NewDestinationAuthMethodConfigFromBearerToken(value *AuthBearerToken) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "BEARER_TOKEN", BearerToken: value}
}

func NewDestinationAuthMethodConfigFromOauth2ClientCredentials(value *AuthOAuth2ClientCredentials) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "OAUTH2_CLIENT_CREDENTIALS", Oauth2ClientCredentials: value}
}

func NewDestinationAuthMethodConfigFromOauth2AuthorizationCode(value *AuthOAuth2AuthorizationCode) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "OAUTH2_AUTHORIZATION_CODE", Oauth2AuthorizationCode: value}
}

func NewDestinationAuthMethodConfigFromCustomSignature(value *AuthCustomSignature) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "CUSTOM_SIGNATURE", CustomSignature: value}
}

func NewDestinationAuthMethodConfigFromAwsSignature(value *AuthAwsSignature) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "AWS_SIGNATURE", AwsSignature: value}
}

func (d *DestinationAuthMethodConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	d.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "HOOKDECK_SIGNATURE":
		value := new(AuthHookdeckSignature)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.HookdeckSignature = value
	case "BASIC_AUTH":
		value := new(AuthBasicAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.BasicAuth = value
	case "API_KEY":
		value := new(AuthApiKey)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.ApiKey = value
	case "BEARER_TOKEN":
		value := new(AuthBearerToken)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.BearerToken = value
	case "OAUTH2_CLIENT_CREDENTIALS":
		value := new(AuthOAuth2ClientCredentials)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.Oauth2ClientCredentials = value
	case "OAUTH2_AUTHORIZATION_CODE":
		value := new(AuthOAuth2AuthorizationCode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.Oauth2AuthorizationCode = value
	case "CUSTOM_SIGNATURE":
		value := new(AuthCustomSignature)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.CustomSignature = value
	case "AWS_SIGNATURE":
		value := new(AuthAwsSignature)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.AwsSignature = value
	}
	return nil
}

func (d DestinationAuthMethodConfig) MarshalJSON() ([]byte, error) {
	switch d.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.Type, d)
	case "HOOKDECK_SIGNATURE":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthHookdeckSignature
		}{
			Type:                  d.Type,
			AuthHookdeckSignature: d.HookdeckSignature,
		}
		return json.Marshal(marshaler)
	case "BASIC_AUTH":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthBasicAuth
		}{
			Type:          d.Type,
			AuthBasicAuth: d.BasicAuth,
		}
		return json.Marshal(marshaler)
	case "API_KEY":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthApiKey
		}{
			Type:       d.Type,
			AuthApiKey: d.ApiKey,
		}
		return json.Marshal(marshaler)
	case "BEARER_TOKEN":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthBearerToken
		}{
			Type:            d.Type,
			AuthBearerToken: d.BearerToken,
		}
		return json.Marshal(marshaler)
	case "OAUTH2_CLIENT_CREDENTIALS":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthOAuth2ClientCredentials
		}{
			Type:                        d.Type,
			AuthOAuth2ClientCredentials: d.Oauth2ClientCredentials,
		}
		return json.Marshal(marshaler)
	case "OAUTH2_AUTHORIZATION_CODE":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthOAuth2AuthorizationCode
		}{
			Type:                        d.Type,
			AuthOAuth2AuthorizationCode: d.Oauth2AuthorizationCode,
		}
		return json.Marshal(marshaler)
	case "CUSTOM_SIGNATURE":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthCustomSignature
		}{
			Type:                d.Type,
			AuthCustomSignature: d.CustomSignature,
		}
		return json.Marshal(marshaler)
	case "AWS_SIGNATURE":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthAwsSignature
		}{
			Type:             d.Type,
			AuthAwsSignature: d.AwsSignature,
		}
		return json.Marshal(marshaler)
	}
}

type DestinationAuthMethodConfigVisitor interface {
	VisitHookdeckSignature(*AuthHookdeckSignature) error
	VisitBasicAuth(*AuthBasicAuth) error
	VisitApiKey(*AuthApiKey) error
	VisitBearerToken(*AuthBearerToken) error
	VisitOauth2ClientCredentials(*AuthOAuth2ClientCredentials) error
	VisitOauth2AuthorizationCode(*AuthOAuth2AuthorizationCode) error
	VisitCustomSignature(*AuthCustomSignature) error
	VisitAwsSignature(*AuthAwsSignature) error
}

func (d *DestinationAuthMethodConfig) Accept(visitor DestinationAuthMethodConfigVisitor) error {
	switch d.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", d.Type, d)
	case "HOOKDECK_SIGNATURE":
		return visitor.VisitHookdeckSignature(d.HookdeckSignature)
	case "BASIC_AUTH":
		return visitor.VisitBasicAuth(d.BasicAuth)
	case "API_KEY":
		return visitor.VisitApiKey(d.ApiKey)
	case "BEARER_TOKEN":
		return visitor.VisitBearerToken(d.BearerToken)
	case "OAUTH2_CLIENT_CREDENTIALS":
		return visitor.VisitOauth2ClientCredentials(d.Oauth2ClientCredentials)
	case "OAUTH2_AUTHORIZATION_CODE":
		return visitor.VisitOauth2AuthorizationCode(d.Oauth2AuthorizationCode)
	case "CUSTOM_SIGNATURE":
		return visitor.VisitCustomSignature(d.CustomSignature)
	case "AWS_SIGNATURE":
		return visitor.VisitAwsSignature(d.AwsSignature)
	}
}

// Custom signature config for the destination's auth method
type DestinationAuthMethodCustomSignatureConfig struct {
	// Key for the custom signature auth
	Key string `json:"key"`
	// Signing secret for the custom signature auth. If left empty a secret will be generated for you.
	SigningSecret *string `json:"signing_secret,omitempty"`
}

// OAuth2 Authorization Code config for the destination's auth method
type DestinationAuthMethodOAuth2AuthorizationCodeConfig struct {
	// Client id in the auth server
	ClientId string `json:"client_id"`
	// Client secret in the auth server
	ClientSecret string `json:"client_secret"`
	// Refresh token already returned by the auth server
	RefreshToken string `json:"refresh_token"`
	// Scope to access
	Scope *string `json:"scope,omitempty"`
	// URL of the auth server
	AuthServer string `json:"auth_server"`
}

// OAuth2 Client Credentials config for the destination's auth method
type DestinationAuthMethodOAuth2ClientCredentialsConfig struct {
	// Client id in the auth server
	ClientId string `json:"client_id"`
	// Client secret in the auth server
	ClientSecret string `json:"client_secret"`
	// Scope to access
	Scope *string `json:"scope,omitempty"`
	// URL of the auth server
	AuthServer string `json:"auth_server"`
	// Basic (default) or Bearer Authentication
	AuthenticationType *DestinationAuthMethodOAuth2ClientCredentialsConfigAuthenticationType `json:"authentication_type,omitempty"`
}

// Basic (default) or Bearer Authentication
type DestinationAuthMethodOAuth2ClientCredentialsConfigAuthenticationType string

const (
	DestinationAuthMethodOAuth2ClientCredentialsConfigAuthenticationTypeBasic  DestinationAuthMethodOAuth2ClientCredentialsConfigAuthenticationType = "basic"
	DestinationAuthMethodOAuth2ClientCredentialsConfigAuthenticationTypeBearer DestinationAuthMethodOAuth2ClientCredentialsConfigAuthenticationType = "bearer"
)

func NewDestinationAuthMethodOAuth2ClientCredentialsConfigAuthenticationTypeFromString(s string) (DestinationAuthMethodOAuth2ClientCredentialsConfigAuthenticationType, error) {
	switch s {
	case "basic":
		return DestinationAuthMethodOAuth2ClientCredentialsConfigAuthenticationTypeBasic, nil
	case "bearer":
		return DestinationAuthMethodOAuth2ClientCredentialsConfigAuthenticationTypeBearer, nil
	}
	var t DestinationAuthMethodOAuth2ClientCredentialsConfigAuthenticationType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationAuthMethodOAuth2ClientCredentialsConfigAuthenticationType) Ptr() *DestinationAuthMethodOAuth2ClientCredentialsConfigAuthenticationType {
	return &d
}

// Empty config for the destination's auth method
type DestinationAuthMethodSignatureConfig struct {
}

// HTTP method used on requests sent to the destination, overrides the method used on requests sent to the source.
type DestinationHttpMethod string

const (
	DestinationHttpMethodGet    DestinationHttpMethod = "GET"
	DestinationHttpMethodPost   DestinationHttpMethod = "POST"
	DestinationHttpMethodPut    DestinationHttpMethod = "PUT"
	DestinationHttpMethodPatch  DestinationHttpMethod = "PATCH"
	DestinationHttpMethodDelete DestinationHttpMethod = "DELETE"
)

func NewDestinationHttpMethodFromString(s string) (DestinationHttpMethod, error) {
	switch s {
	case "GET":
		return DestinationHttpMethodGet, nil
	case "POST":
		return DestinationHttpMethodPost, nil
	case "PUT":
		return DestinationHttpMethodPut, nil
	case "PATCH":
		return DestinationHttpMethodPatch, nil
	case "DELETE":
		return DestinationHttpMethodDelete, nil
	}
	var t DestinationHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationHttpMethod) Ptr() *DestinationHttpMethod {
	return &d
}

type DestinationPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Destination  `json:"models,omitempty"`
}

// Period to rate limit attempts
type DestinationRateLimitPeriod string

const (
	DestinationRateLimitPeriodSecond     DestinationRateLimitPeriod = "second"
	DestinationRateLimitPeriodMinute     DestinationRateLimitPeriod = "minute"
	DestinationRateLimitPeriodHour       DestinationRateLimitPeriod = "hour"
	DestinationRateLimitPeriodConcurrent DestinationRateLimitPeriod = "concurrent"
)

func NewDestinationRateLimitPeriodFromString(s string) (DestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return DestinationRateLimitPeriodSecond, nil
	case "minute":
		return DestinationRateLimitPeriodMinute, nil
	case "hour":
		return DestinationRateLimitPeriodHour, nil
	case "concurrent":
		return DestinationRateLimitPeriodConcurrent, nil
	}
	var t DestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationRateLimitPeriod) Ptr() *DestinationRateLimitPeriod {
	return &d
}

type DetachedIntegrationFromSource struct {
}

type Event struct {
	// ID of the event
	Id string `json:"id"`
	// ID of the project
	TeamId string `json:"team_id"`
	// ID of the associated connection
	WebhookId string `json:"webhook_id"`
	// ID of the associated source
	SourceId string `json:"source_id"`
	// ID of the associated destination
	DestinationId string `json:"destination_id"`
	// ID of the event data
	EventDataId string `json:"event_data_id"`
	// ID of the request that created the event
	RequestId string `json:"request_id"`
	// Number of delivery attempts made
	Attempts int `json:"attempts"`
	// Date of the most recently attempted retry
	LastAttemptAt *time.Time `json:"last_attempt_at,omitempty"`
	// Date of the next scheduled retry
	NextAttemptAt *time.Time `json:"next_attempt_at,omitempty"`
	// Event status
	ResponseStatus *int               `json:"response_status,omitempty"`
	ErrorCode      *AttemptErrorCodes `json:"error_code,omitempty"`
	Status         EventStatus        `json:"status,omitempty"`
	// Date of the latest successful attempt
	SuccessfulAt *time.Time `json:"successful_at,omitempty"`
	// ID of the CLI the event is sent to
	CliId *string `json:"cli_id,omitempty"`
	// Date the event was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the event was created
	CreatedAt time.Time       `json:"created_at"`
	Data      *ShortEventData `json:"data,omitempty"`
}

type EventArray = []*Event

type EventAttempt struct {
	// Attempt ID
	Id string `json:"id"`
	// Team ID
	TeamId string `json:"team_id"`
	// Event ID
	EventId string `json:"event_id"`
	// Attempt's HTTP response code
	ResponseStatus *int `json:"response_status,omitempty"`
	// Sequential number of attempts (up to and including this one) made for the associated event
	AttemptNumber *int               `json:"attempt_number,omitempty"`
	Trigger       *AttemptTrigger    `json:"trigger,omitempty"`
	ErrorCode     *AttemptErrorCodes `json:"error_code,omitempty"`
	Body          *EventAttemptBody  `json:"body,omitempty"`
	// URL of the destination where delivery was attempted
	RequestedUrl *string `json:"requested_url,omitempty"`
	// HTTP method used to deliver the attempt
	HttpMethod *EventAttemptHttpMethod `json:"http_method,omitempty"`
	// ID of associated bulk retry
	BulkRetryId *string       `json:"bulk_retry_id,omitempty"`
	Status      AttemptStatus `json:"status,omitempty"`
	// Date the attempt was successful
	SuccessfulAt *time.Time `json:"successful_at,omitempty"`
	// Date the attempt was delivered
	DeliveredAt *time.Time `json:"delivered_at,omitempty"`
	// Date the destination responded to this attempt
	RespondedAt *time.Time `json:"responded_at,omitempty"`
	// Time elapsed between attempt initiation and final delivery (in ms)
	DeliveryLatency *int `json:"delivery_latency,omitempty"`
	// Time elapsed between attempt initiation and a response from the destination (in ms)
	ResponseLatency *int `json:"response_latency,omitempty"`
	// Date the attempt was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the attempt was created
	CreatedAt     time.Time     `json:"created_at"`
	State         *AttemptState `json:"state,omitempty"`
	DestinationId *string       `json:"destination_id,omitempty"`
}

type EventAttemptBody struct {
	typeName string
	// Response body from the destination
	EventAttemptBodyZeroOptional *EventAttemptBodyZero
	// Response body from the destination
	StringOptional *string
}

func NewEventAttemptBodyFromEventAttemptBodyZeroOptional(value *EventAttemptBodyZero) *EventAttemptBody {
	return &EventAttemptBody{typeName: "eventAttemptBodyZeroOptional", EventAttemptBodyZeroOptional: value}
}

func NewEventAttemptBodyFromStringOptional(value *string) *EventAttemptBody {
	return &EventAttemptBody{typeName: "stringOptional", StringOptional: value}
}

func (e *EventAttemptBody) UnmarshalJSON(data []byte) error {
	var valueEventAttemptBodyZeroOptional *EventAttemptBodyZero
	if err := json.Unmarshal(data, &valueEventAttemptBodyZeroOptional); err == nil {
		e.typeName = "eventAttemptBodyZeroOptional"
		e.EventAttemptBodyZeroOptional = valueEventAttemptBodyZeroOptional
		return nil
	}
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		e.typeName = "stringOptional"
		e.StringOptional = valueStringOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventAttemptBody) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventAttemptBodyZeroOptional":
		return json.Marshal(e.EventAttemptBodyZeroOptional)
	case "stringOptional":
		return json.Marshal(e.StringOptional)
	}
}

type EventAttemptBodyVisitor interface {
	VisitEventAttemptBodyZeroOptional(*EventAttemptBodyZero) error
	VisitStringOptional(*string) error
}

func (e *EventAttemptBody) Accept(visitor EventAttemptBodyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventAttemptBodyZeroOptional":
		return visitor.VisitEventAttemptBodyZeroOptional(e.EventAttemptBodyZeroOptional)
	case "stringOptional":
		return visitor.VisitStringOptional(e.StringOptional)
	}
}

// Response body from the destination
type EventAttemptBodyZero struct {
}

// HTTP method used to deliver the attempt
type EventAttemptHttpMethod string

const (
	EventAttemptHttpMethodGet    EventAttemptHttpMethod = "GET"
	EventAttemptHttpMethodPost   EventAttemptHttpMethod = "POST"
	EventAttemptHttpMethodPut    EventAttemptHttpMethod = "PUT"
	EventAttemptHttpMethodPatch  EventAttemptHttpMethod = "PATCH"
	EventAttemptHttpMethodDelete EventAttemptHttpMethod = "DELETE"
)

func NewEventAttemptHttpMethodFromString(s string) (EventAttemptHttpMethod, error) {
	switch s {
	case "GET":
		return EventAttemptHttpMethodGet, nil
	case "POST":
		return EventAttemptHttpMethodPost, nil
	case "PUT":
		return EventAttemptHttpMethodPut, nil
	case "PATCH":
		return EventAttemptHttpMethodPatch, nil
	case "DELETE":
		return EventAttemptHttpMethodDelete, nil
	}
	var t EventAttemptHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventAttemptHttpMethod) Ptr() *EventAttemptHttpMethod {
	return &e
}

type EventAttemptPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*EventAttempt `json:"models,omitempty"`
}

type EventPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Event        `json:"models,omitempty"`
}

type EventStatus string

const (
	EventStatusScheduled  EventStatus = "SCHEDULED"
	EventStatusQueued     EventStatus = "QUEUED"
	EventStatusHold       EventStatus = "HOLD"
	EventStatusSuccessful EventStatus = "SUCCESSFUL"
	EventStatusFailed     EventStatus = "FAILED"
)

func NewEventStatusFromString(s string) (EventStatus, error) {
	switch s {
	case "SCHEDULED":
		return EventStatusScheduled, nil
	case "QUEUED":
		return EventStatusQueued, nil
	case "HOLD":
		return EventStatusHold, nil
	case "SUCCESSFUL":
		return EventStatusSuccessful, nil
	case "FAILED":
		return EventStatusFailed, nil
	}
	var t EventStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventStatus) Ptr() *EventStatus {
	return &e
}

type FilterRule struct {
	Headers *FilterRuleProperty `json:"headers,omitempty"`
	Body    *FilterRuleProperty `json:"body,omitempty"`
	Query   *FilterRuleProperty `json:"query,omitempty"`
	Path    *FilterRuleProperty `json:"path,omitempty"`
}

// JSON using our filter syntax to filter on request headers
type FilterRuleProperty struct {
	typeName                 string
	StringOptional           *string
	DoubleOptional           *float64
	BooleanOptional          *bool
	StringUnknownMapOptional map[string]interface{}
}

func NewFilterRulePropertyFromStringOptional(value *string) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "stringOptional", StringOptional: value}
}

func NewFilterRulePropertyFromDoubleOptional(value *float64) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "doubleOptional", DoubleOptional: value}
}

func NewFilterRulePropertyFromBooleanOptional(value *bool) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "booleanOptional", BooleanOptional: value}
}

func NewFilterRulePropertyFromStringUnknownMapOptional(value map[string]interface{}) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "stringUnknownMapOptional", StringUnknownMapOptional: value}
}

func (f *FilterRuleProperty) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		f.typeName = "stringOptional"
		f.StringOptional = valueStringOptional
		return nil
	}
	var valueDoubleOptional *float64
	if err := json.Unmarshal(data, &valueDoubleOptional); err == nil {
		f.typeName = "doubleOptional"
		f.DoubleOptional = valueDoubleOptional
		return nil
	}
	var valueBooleanOptional *bool
	if err := json.Unmarshal(data, &valueBooleanOptional); err == nil {
		f.typeName = "booleanOptional"
		f.BooleanOptional = valueBooleanOptional
		return nil
	}
	var valueStringUnknownMapOptional map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapOptional); err == nil {
		f.typeName = "stringUnknownMapOptional"
		f.StringUnknownMapOptional = valueStringUnknownMapOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilterRuleProperty) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringOptional":
		return json.Marshal(f.StringOptional)
	case "doubleOptional":
		return json.Marshal(f.DoubleOptional)
	case "booleanOptional":
		return json.Marshal(f.BooleanOptional)
	case "stringUnknownMapOptional":
		return json.Marshal(f.StringUnknownMapOptional)
	}
}

type FilterRulePropertyVisitor interface {
	VisitStringOptional(*string) error
	VisitDoubleOptional(*float64) error
	VisitBooleanOptional(*bool) error
	VisitStringUnknownMapOptional(map[string]interface{}) error
}

func (f *FilterRuleProperty) Accept(visitor FilterRulePropertyVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringOptional":
		return visitor.VisitStringOptional(f.StringOptional)
	case "doubleOptional":
		return visitor.VisitDoubleOptional(f.DoubleOptional)
	case "booleanOptional":
		return visitor.VisitBooleanOptional(f.BooleanOptional)
	case "stringUnknownMapOptional":
		return visitor.VisitStringUnknownMapOptional(f.StringUnknownMapOptional)
	}
}

type FilteredMeta string

const (
	FilteredMetaBody    FilteredMeta = "body"
	FilteredMetaHeaders FilteredMeta = "headers"
	FilteredMetaPath    FilteredMeta = "path"
	FilteredMetaQuery   FilteredMeta = "query"
)

func NewFilteredMetaFromString(s string) (FilteredMeta, error) {
	switch s {
	case "body":
		return FilteredMetaBody, nil
	case "headers":
		return FilteredMetaHeaders, nil
	case "path":
		return FilteredMetaPath, nil
	case "query":
		return FilteredMetaQuery, nil
	}
	var t FilteredMeta
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilteredMeta) Ptr() *FilteredMeta {
	return &f
}

type HandledApiKeyIntegrationConfigs struct {
	ApiKey string `json:"api_key"`
}

type HandledHmacConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type HmacAlgorithms string

const (
	HmacAlgorithmsMd5    HmacAlgorithms = "md5"
	HmacAlgorithmsSha1   HmacAlgorithms = "sha1"
	HmacAlgorithmsSha256 HmacAlgorithms = "sha256"
	HmacAlgorithmsSha512 HmacAlgorithms = "sha512"
)

func NewHmacAlgorithmsFromString(s string) (HmacAlgorithms, error) {
	switch s {
	case "md5":
		return HmacAlgorithmsMd5, nil
	case "sha1":
		return HmacAlgorithmsSha1, nil
	case "sha256":
		return HmacAlgorithmsSha256, nil
	case "sha512":
		return HmacAlgorithmsSha512, nil
	}
	var t HmacAlgorithms
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HmacAlgorithms) Ptr() *HmacAlgorithms {
	return &h
}

type HmacIntegrationConfigs struct {
	WebhookSecretKey string                         `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms                 `json:"algorithm,omitempty"`
	HeaderKey        string                         `json:"header_key"`
	Encoding         HmacIntegrationConfigsEncoding `json:"encoding,omitempty"`
}

type HmacIntegrationConfigsEncoding string

const (
	HmacIntegrationConfigsEncodingBase64 HmacIntegrationConfigsEncoding = "base64"
	HmacIntegrationConfigsEncodingHex    HmacIntegrationConfigsEncoding = "hex"
)

func NewHmacIntegrationConfigsEncodingFromString(s string) (HmacIntegrationConfigsEncoding, error) {
	switch s {
	case "base64":
		return HmacIntegrationConfigsEncodingBase64, nil
	case "hex":
		return HmacIntegrationConfigsEncodingHex, nil
	}
	var t HmacIntegrationConfigsEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HmacIntegrationConfigsEncoding) Ptr() *HmacIntegrationConfigsEncoding {
	return &h
}

type IgnoredEvent struct {
	Id        string            `json:"id"`
	TeamId    string            `json:"team_id"`
	WebhookId string            `json:"webhook_id"`
	Cause     IgnoredEventCause `json:"cause,omitempty"`
	RequestId string            `json:"request_id"`
	Meta      *IgnoredEventMeta `json:"meta,omitempty"`
	UpdatedAt time.Time         `json:"updated_at"`
	CreatedAt time.Time         `json:"created_at"`
}

type IgnoredEventCause string

const (
	IgnoredEventCauseDisabled             IgnoredEventCause = "DISABLED"
	IgnoredEventCauseFiltered             IgnoredEventCause = "FILTERED"
	IgnoredEventCauseTransformationFailed IgnoredEventCause = "TRANSFORMATION_FAILED"
	IgnoredEventCauseCliDisconnected      IgnoredEventCause = "CLI_DISCONNECTED"
)

func NewIgnoredEventCauseFromString(s string) (IgnoredEventCause, error) {
	switch s {
	case "DISABLED":
		return IgnoredEventCauseDisabled, nil
	case "FILTERED":
		return IgnoredEventCauseFiltered, nil
	case "TRANSFORMATION_FAILED":
		return IgnoredEventCauseTransformationFailed, nil
	case "CLI_DISCONNECTED":
		return IgnoredEventCauseCliDisconnected, nil
	}
	var t IgnoredEventCause
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IgnoredEventCause) Ptr() *IgnoredEventCause {
	return &i
}

type IgnoredEventMeta struct {
	typeName                 string
	FilteredMeta             FilteredMeta
	TransformationFailedMeta *TransformationFailedMeta
}

func NewIgnoredEventMetaFromFilteredMeta(value FilteredMeta) *IgnoredEventMeta {
	return &IgnoredEventMeta{typeName: "filteredMeta", FilteredMeta: value}
}

func NewIgnoredEventMetaFromTransformationFailedMeta(value *TransformationFailedMeta) *IgnoredEventMeta {
	return &IgnoredEventMeta{typeName: "transformationFailedMeta", TransformationFailedMeta: value}
}

func (i *IgnoredEventMeta) UnmarshalJSON(data []byte) error {
	var valueFilteredMeta FilteredMeta
	if err := json.Unmarshal(data, &valueFilteredMeta); err == nil {
		i.typeName = "filteredMeta"
		i.FilteredMeta = valueFilteredMeta
		return nil
	}
	valueTransformationFailedMeta := new(TransformationFailedMeta)
	if err := json.Unmarshal(data, &valueTransformationFailedMeta); err == nil {
		i.typeName = "transformationFailedMeta"
		i.TransformationFailedMeta = valueTransformationFailedMeta
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IgnoredEventMeta) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "filteredMeta":
		return json.Marshal(i.FilteredMeta)
	case "transformationFailedMeta":
		return json.Marshal(i.TransformationFailedMeta)
	}
}

type IgnoredEventMetaVisitor interface {
	VisitFilteredMeta(FilteredMeta) error
	VisitTransformationFailedMeta(*TransformationFailedMeta) error
}

func (i *IgnoredEventMeta) Accept(visitor IgnoredEventMetaVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "filteredMeta":
		return visitor.VisitFilteredMeta(i.FilteredMeta)
	case "transformationFailedMeta":
		return visitor.VisitTransformationFailedMeta(i.TransformationFailedMeta)
	}
}

type IgnoredEventPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*IgnoredEvent `json:"models,omitempty"`
}

type Integration struct {
	// ID of the integration
	Id string `json:"id"`
	// ID of the project
	TeamId string `json:"team_id"`
	// Label of the integration
	Label    string              `json:"label"`
	Provider IntegrationProvider `json:"provider,omitempty"`
	// List of features to enable (see features list below)
	Features []IntegrationFeature `json:"features,omitempty"`
	// Decrypted Key/Value object of the associated configuration for that provider
	Configs *IntegrationConfigs `json:"configs,omitempty"`
	// List of source IDs the integration is attached to
	Sources []string `json:"sources,omitempty"`
	// Date the integration was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the integration was created
	CreatedAt time.Time `json:"created_at"`
}

// Decrypted Key/Value object of the associated configuration for that provider
type IntegrationConfigs struct {
	typeName                          string
	HmacIntegrationConfigs            *HmacIntegrationConfigs
	ApiKeyIntegrationConfigs          *ApiKeyIntegrationConfigs
	HandledApiKeyIntegrationConfigs   *HandledApiKeyIntegrationConfigs
	HandledHmacConfigs                *HandledHmacConfigs
	BasicAuthIntegrationConfigs       *BasicAuthIntegrationConfigs
	ShopifyIntegrationConfigs         *ShopifyIntegrationConfigs
	VercelLogDrainsIntegrationConfigs *VercelLogDrainsIntegrationConfigs
	IntegrationConfigsSeven           *IntegrationConfigsSeven
}

func NewIntegrationConfigsFromHmacIntegrationConfigs(value *HmacIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "hmacIntegrationConfigs", HmacIntegrationConfigs: value}
}

func NewIntegrationConfigsFromApiKeyIntegrationConfigs(value *ApiKeyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "apiKeyIntegrationConfigs", ApiKeyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromHandledApiKeyIntegrationConfigs(value *HandledApiKeyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "handledApiKeyIntegrationConfigs", HandledApiKeyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromHandledHmacConfigs(value *HandledHmacConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "handledHmacConfigs", HandledHmacConfigs: value}
}

func NewIntegrationConfigsFromBasicAuthIntegrationConfigs(value *BasicAuthIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "basicAuthIntegrationConfigs", BasicAuthIntegrationConfigs: value}
}

func NewIntegrationConfigsFromShopifyIntegrationConfigs(value *ShopifyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "shopifyIntegrationConfigs", ShopifyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromVercelLogDrainsIntegrationConfigs(value *VercelLogDrainsIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "vercelLogDrainsIntegrationConfigs", VercelLogDrainsIntegrationConfigs: value}
}

func NewIntegrationConfigsFromIntegrationConfigsSeven(value *IntegrationConfigsSeven) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "integrationConfigsSeven", IntegrationConfigsSeven: value}
}

func (i *IntegrationConfigs) UnmarshalJSON(data []byte) error {
	valueHmacIntegrationConfigs := new(HmacIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHmacIntegrationConfigs); err == nil {
		i.typeName = "hmacIntegrationConfigs"
		i.HmacIntegrationConfigs = valueHmacIntegrationConfigs
		return nil
	}
	valueApiKeyIntegrationConfigs := new(ApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueApiKeyIntegrationConfigs); err == nil {
		i.typeName = "apiKeyIntegrationConfigs"
		i.ApiKeyIntegrationConfigs = valueApiKeyIntegrationConfigs
		return nil
	}
	valueHandledApiKeyIntegrationConfigs := new(HandledApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHandledApiKeyIntegrationConfigs); err == nil {
		i.typeName = "handledApiKeyIntegrationConfigs"
		i.HandledApiKeyIntegrationConfigs = valueHandledApiKeyIntegrationConfigs
		return nil
	}
	valueHandledHmacConfigs := new(HandledHmacConfigs)
	if err := json.Unmarshal(data, &valueHandledHmacConfigs); err == nil {
		i.typeName = "handledHmacConfigs"
		i.HandledHmacConfigs = valueHandledHmacConfigs
		return nil
	}
	valueBasicAuthIntegrationConfigs := new(BasicAuthIntegrationConfigs)
	if err := json.Unmarshal(data, &valueBasicAuthIntegrationConfigs); err == nil {
		i.typeName = "basicAuthIntegrationConfigs"
		i.BasicAuthIntegrationConfigs = valueBasicAuthIntegrationConfigs
		return nil
	}
	valueShopifyIntegrationConfigs := new(ShopifyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueShopifyIntegrationConfigs); err == nil {
		i.typeName = "shopifyIntegrationConfigs"
		i.ShopifyIntegrationConfigs = valueShopifyIntegrationConfigs
		return nil
	}
	valueVercelLogDrainsIntegrationConfigs := new(VercelLogDrainsIntegrationConfigs)
	if err := json.Unmarshal(data, &valueVercelLogDrainsIntegrationConfigs); err == nil {
		i.typeName = "vercelLogDrainsIntegrationConfigs"
		i.VercelLogDrainsIntegrationConfigs = valueVercelLogDrainsIntegrationConfigs
		return nil
	}
	valueIntegrationConfigsSeven := new(IntegrationConfigsSeven)
	if err := json.Unmarshal(data, &valueIntegrationConfigsSeven); err == nil {
		i.typeName = "integrationConfigsSeven"
		i.IntegrationConfigsSeven = valueIntegrationConfigsSeven
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IntegrationConfigs) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "hmacIntegrationConfigs":
		return json.Marshal(i.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return json.Marshal(i.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return json.Marshal(i.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return json.Marshal(i.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return json.Marshal(i.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return json.Marshal(i.ShopifyIntegrationConfigs)
	case "vercelLogDrainsIntegrationConfigs":
		return json.Marshal(i.VercelLogDrainsIntegrationConfigs)
	case "integrationConfigsSeven":
		return json.Marshal(i.IntegrationConfigsSeven)
	}
}

type IntegrationConfigsVisitor interface {
	VisitHmacIntegrationConfigs(*HmacIntegrationConfigs) error
	VisitApiKeyIntegrationConfigs(*ApiKeyIntegrationConfigs) error
	VisitHandledApiKeyIntegrationConfigs(*HandledApiKeyIntegrationConfigs) error
	VisitHandledHmacConfigs(*HandledHmacConfigs) error
	VisitBasicAuthIntegrationConfigs(*BasicAuthIntegrationConfigs) error
	VisitShopifyIntegrationConfigs(*ShopifyIntegrationConfigs) error
	VisitVercelLogDrainsIntegrationConfigs(*VercelLogDrainsIntegrationConfigs) error
	VisitIntegrationConfigsSeven(*IntegrationConfigsSeven) error
}

func (i *IntegrationConfigs) Accept(visitor IntegrationConfigsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "hmacIntegrationConfigs":
		return visitor.VisitHmacIntegrationConfigs(i.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return visitor.VisitApiKeyIntegrationConfigs(i.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return visitor.VisitHandledApiKeyIntegrationConfigs(i.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return visitor.VisitHandledHmacConfigs(i.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return visitor.VisitBasicAuthIntegrationConfigs(i.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return visitor.VisitShopifyIntegrationConfigs(i.ShopifyIntegrationConfigs)
	case "vercelLogDrainsIntegrationConfigs":
		return visitor.VisitVercelLogDrainsIntegrationConfigs(i.VercelLogDrainsIntegrationConfigs)
	case "integrationConfigsSeven":
		return visitor.VisitIntegrationConfigsSeven(i.IntegrationConfigsSeven)
	}
}

type IntegrationConfigsSeven struct {
}

type IntegrationFeature string

const (
	IntegrationFeatureVerification IntegrationFeature = "VERIFICATION"
	IntegrationFeatureHandshake    IntegrationFeature = "HANDSHAKE"
)

func NewIntegrationFeatureFromString(s string) (IntegrationFeature, error) {
	switch s {
	case "VERIFICATION":
		return IntegrationFeatureVerification, nil
	case "HANDSHAKE":
		return IntegrationFeatureHandshake, nil
	}
	var t IntegrationFeature
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationFeature) Ptr() *IntegrationFeature {
	return &i
}

type IntegrationPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Integration  `json:"models,omitempty"`
}

type IntegrationProvider string

const (
	IntegrationProviderHmac            IntegrationProvider = "HMAC"
	IntegrationProviderBasicAuth       IntegrationProvider = "BASIC_AUTH"
	IntegrationProviderApiKey          IntegrationProvider = "API_KEY"
	IntegrationProviderCloudsignal     IntegrationProvider = "CLOUDSIGNAL"
	IntegrationProviderCourier         IntegrationProvider = "COURIER"
	IntegrationProviderFrontapp        IntegrationProvider = "FRONTAPP"
	IntegrationProviderTwitter         IntegrationProvider = "TWITTER"
	IntegrationProviderStripe          IntegrationProvider = "STRIPE"
	IntegrationProviderRecharge        IntegrationProvider = "RECHARGE"
	IntegrationProviderTwilio          IntegrationProvider = "TWILIO"
	IntegrationProviderGithub          IntegrationProvider = "GITHUB"
	IntegrationProviderShopify         IntegrationProvider = "SHOPIFY"
	IntegrationProviderPostmark        IntegrationProvider = "POSTMARK"
	IntegrationProviderTypeform        IntegrationProvider = "TYPEFORM"
	IntegrationProviderXero            IntegrationProvider = "XERO"
	IntegrationProviderSvix            IntegrationProvider = "SVIX"
	IntegrationProviderZoom            IntegrationProvider = "ZOOM"
	IntegrationProviderAkeneo          IntegrationProvider = "AKENEO"
	IntegrationProviderAdyen           IntegrationProvider = "ADYEN"
	IntegrationProviderGitlab          IntegrationProvider = "GITLAB"
	IntegrationProviderPropertyFinder  IntegrationProvider = "PROPERTY-FINDER"
	IntegrationProviderWoocommerce     IntegrationProvider = "WOOCOMMERCE"
	IntegrationProviderOura            IntegrationProvider = "OURA"
	IntegrationProviderCommercelayer   IntegrationProvider = "COMMERCELAYER"
	IntegrationProviderHubspot         IntegrationProvider = "HUBSPOT"
	IntegrationProviderMailgun         IntegrationProvider = "MAILGUN"
	IntegrationProviderPersona         IntegrationProvider = "PERSONA"
	IntegrationProviderPipedrive       IntegrationProvider = "PIPEDRIVE"
	IntegrationProviderSendgrid        IntegrationProvider = "SENDGRID"
	IntegrationProviderWorkos          IntegrationProvider = "WORKOS"
	IntegrationProviderSynctera        IntegrationProvider = "SYNCTERA"
	IntegrationProviderAwsSns          IntegrationProvider = "AWS_SNS"
	IntegrationProviderThreeDEye       IntegrationProvider = "THREE_D_EYE"
	IntegrationProviderTwitch          IntegrationProvider = "TWITCH"
	IntegrationProviderEnode           IntegrationProvider = "ENODE"
	IntegrationProviderFavro           IntegrationProvider = "FAVRO"
	IntegrationProviderLinear          IntegrationProvider = "LINEAR"
	IntegrationProviderShopline        IntegrationProvider = "SHOPLINE"
	IntegrationProviderWix             IntegrationProvider = "WIX"
	IntegrationProviderNmi             IntegrationProvider = "NMI"
	IntegrationProviderOrb             IntegrationProvider = "ORB"
	IntegrationProviderPylon           IntegrationProvider = "PYLON"
	IntegrationProviderRepay           IntegrationProvider = "REPAY"
	IntegrationProviderSquare          IntegrationProvider = "SQUARE"
	IntegrationProviderSolidgate       IntegrationProvider = "SOLIDGATE"
	IntegrationProviderTrello          IntegrationProvider = "TRELLO"
	IntegrationProviderSanity          IntegrationProvider = "SANITY"
	IntegrationProviderEbay            IntegrationProvider = "EBAY"
	IntegrationProviderTelnyx          IntegrationProvider = "TELNYX"
	IntegrationProviderDiscord         IntegrationProvider = "DISCORD"
	IntegrationProviderTokenio         IntegrationProvider = "TOKENIO"
	IntegrationProviderFiserv          IntegrationProvider = "FISERV"
	IntegrationProviderBondsmith       IntegrationProvider = "BONDSMITH"
	IntegrationProviderVercelLogDrains IntegrationProvider = "VERCEL_LOG_DRAINS"
	IntegrationProviderVercel          IntegrationProvider = "VERCEL"
	IntegrationProviderTebex           IntegrationProvider = "TEBEX"
	IntegrationProviderSlack           IntegrationProvider = "SLACK"
	IntegrationProviderRazorpay        IntegrationProvider = "RAZORPAY"
)

func NewIntegrationProviderFromString(s string) (IntegrationProvider, error) {
	switch s {
	case "HMAC":
		return IntegrationProviderHmac, nil
	case "BASIC_AUTH":
		return IntegrationProviderBasicAuth, nil
	case "API_KEY":
		return IntegrationProviderApiKey, nil
	case "CLOUDSIGNAL":
		return IntegrationProviderCloudsignal, nil
	case "COURIER":
		return IntegrationProviderCourier, nil
	case "FRONTAPP":
		return IntegrationProviderFrontapp, nil
	case "TWITTER":
		return IntegrationProviderTwitter, nil
	case "STRIPE":
		return IntegrationProviderStripe, nil
	case "RECHARGE":
		return IntegrationProviderRecharge, nil
	case "TWILIO":
		return IntegrationProviderTwilio, nil
	case "GITHUB":
		return IntegrationProviderGithub, nil
	case "SHOPIFY":
		return IntegrationProviderShopify, nil
	case "POSTMARK":
		return IntegrationProviderPostmark, nil
	case "TYPEFORM":
		return IntegrationProviderTypeform, nil
	case "XERO":
		return IntegrationProviderXero, nil
	case "SVIX":
		return IntegrationProviderSvix, nil
	case "ZOOM":
		return IntegrationProviderZoom, nil
	case "AKENEO":
		return IntegrationProviderAkeneo, nil
	case "ADYEN":
		return IntegrationProviderAdyen, nil
	case "GITLAB":
		return IntegrationProviderGitlab, nil
	case "PROPERTY-FINDER":
		return IntegrationProviderPropertyFinder, nil
	case "WOOCOMMERCE":
		return IntegrationProviderWoocommerce, nil
	case "OURA":
		return IntegrationProviderOura, nil
	case "COMMERCELAYER":
		return IntegrationProviderCommercelayer, nil
	case "HUBSPOT":
		return IntegrationProviderHubspot, nil
	case "MAILGUN":
		return IntegrationProviderMailgun, nil
	case "PERSONA":
		return IntegrationProviderPersona, nil
	case "PIPEDRIVE":
		return IntegrationProviderPipedrive, nil
	case "SENDGRID":
		return IntegrationProviderSendgrid, nil
	case "WORKOS":
		return IntegrationProviderWorkos, nil
	case "SYNCTERA":
		return IntegrationProviderSynctera, nil
	case "AWS_SNS":
		return IntegrationProviderAwsSns, nil
	case "THREE_D_EYE":
		return IntegrationProviderThreeDEye, nil
	case "TWITCH":
		return IntegrationProviderTwitch, nil
	case "ENODE":
		return IntegrationProviderEnode, nil
	case "FAVRO":
		return IntegrationProviderFavro, nil
	case "LINEAR":
		return IntegrationProviderLinear, nil
	case "SHOPLINE":
		return IntegrationProviderShopline, nil
	case "WIX":
		return IntegrationProviderWix, nil
	case "NMI":
		return IntegrationProviderNmi, nil
	case "ORB":
		return IntegrationProviderOrb, nil
	case "PYLON":
		return IntegrationProviderPylon, nil
	case "REPAY":
		return IntegrationProviderRepay, nil
	case "SQUARE":
		return IntegrationProviderSquare, nil
	case "SOLIDGATE":
		return IntegrationProviderSolidgate, nil
	case "TRELLO":
		return IntegrationProviderTrello, nil
	case "SANITY":
		return IntegrationProviderSanity, nil
	case "EBAY":
		return IntegrationProviderEbay, nil
	case "TELNYX":
		return IntegrationProviderTelnyx, nil
	case "DISCORD":
		return IntegrationProviderDiscord, nil
	case "TOKENIO":
		return IntegrationProviderTokenio, nil
	case "FISERV":
		return IntegrationProviderFiserv, nil
	case "BONDSMITH":
		return IntegrationProviderBondsmith, nil
	case "VERCEL_LOG_DRAINS":
		return IntegrationProviderVercelLogDrains, nil
	case "VERCEL":
		return IntegrationProviderVercel, nil
	case "TEBEX":
		return IntegrationProviderTebex, nil
	case "SLACK":
		return IntegrationProviderSlack, nil
	case "RAZORPAY":
		return IntegrationProviderRazorpay, nil
	}
	var t IntegrationProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationProvider) Ptr() *IntegrationProvider {
	return &i
}

// Issue
type Issue struct {
	Type           string
	Delivery       *DeliveryIssue
	Transformation *TransformationIssue
}

func NewIssueFromDelivery(value *DeliveryIssue) *Issue {
	return &Issue{Type: "delivery", Delivery: value}
}

func NewIssueFromTransformation(value *TransformationIssue) *Issue {
	return &Issue{Type: "transformation", Transformation: value}
}

func (i *Issue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "delivery":
		value := new(DeliveryIssue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Delivery = value
	case "transformation":
		value := new(TransformationIssue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Transformation = value
	}
	return nil
}

func (i Issue) MarshalJSON() ([]byte, error) {
	switch i.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		var marshaler = struct {
			Type string `json:"type"`
			*DeliveryIssue
		}{
			Type:          i.Type,
			DeliveryIssue: i.Delivery,
		}
		return json.Marshal(marshaler)
	case "transformation":
		var marshaler = struct {
			Type string `json:"type"`
			*TransformationIssue
		}{
			Type:                i.Type,
			TransformationIssue: i.Transformation,
		}
		return json.Marshal(marshaler)
	}
}

type IssueVisitor interface {
	VisitDelivery(*DeliveryIssue) error
	VisitTransformation(*TransformationIssue) error
}

func (i *Issue) Accept(visitor IssueVisitor) error {
	switch i.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		return visitor.VisitDelivery(i.Delivery)
	case "transformation":
		return visitor.VisitTransformation(i.Transformation)
	}
}

type IssueCount struct {
	// Number of issues
	Count int `json:"count"`
}

// Issue status
type IssueStatus string

const (
	IssueStatusOpened       IssueStatus = "OPENED"
	IssueStatusIgnored      IssueStatus = "IGNORED"
	IssueStatusAcknowledged IssueStatus = "ACKNOWLEDGED"
	IssueStatusResolved     IssueStatus = "RESOLVED"
)

func NewIssueStatusFromString(s string) (IssueStatus, error) {
	switch s {
	case "OPENED":
		return IssueStatusOpened, nil
	case "IGNORED":
		return IssueStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueStatusAcknowledged, nil
	case "RESOLVED":
		return IssueStatusResolved, nil
	}
	var t IssueStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueStatus) Ptr() *IssueStatus {
	return &i
}

type IssueTrigger struct {
	// ID of the issue trigger
	Id string `json:"id"`
	// ID of the project
	TeamId *string `json:"team_id,omitempty"`
	// Optional unique name to use as reference when using the API
	Name     *string                `json:"name,omitempty"`
	Type     IssueType              `json:"type,omitempty"`
	Configs  *IssueTriggerReference `json:"configs,omitempty"`
	Channels *IssueTriggerChannels  `json:"channels,omitempty"`
	// ISO timestamp for when the issue trigger was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty"`
	// ISO timestamp for when the issue trigger was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// ISO timestamp for when the issue trigger was created
	CreatedAt time.Time `json:"created_at"`
	// ISO timestamp for when the issue trigger was deleted
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
}

// Configurations for a 'Backpressure' issue trigger
type IssueTriggerBackpressureConfigs struct {
	Delay IssueTriggerBackpressureDelay `json:"delay"`
	// A pattern to match on the destination name or array of destination IDs. Use `*` as wildcard.
	Destinations *IssueTriggerBackpressureConfigsDestinations `json:"destinations,omitempty"`
}

// A pattern to match on the destination name or array of destination IDs. Use `*` as wildcard.
type IssueTriggerBackpressureConfigsDestinations struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerBackpressureConfigsDestinationsFromString(value string) *IssueTriggerBackpressureConfigsDestinations {
	return &IssueTriggerBackpressureConfigsDestinations{typeName: "string", String: value}
}

func NewIssueTriggerBackpressureConfigsDestinationsFromStringList(value []string) *IssueTriggerBackpressureConfigsDestinations {
	return &IssueTriggerBackpressureConfigsDestinations{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerBackpressureConfigsDestinations) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerBackpressureConfigsDestinations) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerBackpressureConfigsDestinationsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerBackpressureConfigsDestinations) Accept(visitor IssueTriggerBackpressureConfigsDestinationsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// The minimum delay (backpressure) to open the issue for min of 1 minute (60000) and max of 1 day (86400000)
type IssueTriggerBackpressureDelay = int

// Notification channels object for the specific channel type
type IssueTriggerChannels struct {
	Slack    *IssueTriggerSlackChannel       `json:"slack,omitempty"`
	Opsgenie *IssueTriggerIntegrationChannel `json:"opsgenie,omitempty"`
	Email    *IssueTriggerEmailChannel       `json:"email,omitempty"`
}

// Configurations for a 'delivery' issue trigger
type IssueTriggerDeliveryConfigs struct {
	Strategy IssueTriggerStrategy `json:"strategy,omitempty"`
	// A pattern to match on the connection name or array of connection IDs. Use `*` as wildcard.
	Connections *IssueTriggerDeliveryConfigsConnections `json:"connections,omitempty"`
}

// A pattern to match on the connection name or array of connection IDs. Use `*` as wildcard.
type IssueTriggerDeliveryConfigsConnections struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerDeliveryConfigsConnectionsFromString(value string) *IssueTriggerDeliveryConfigsConnections {
	return &IssueTriggerDeliveryConfigsConnections{typeName: "string", String: value}
}

func NewIssueTriggerDeliveryConfigsConnectionsFromStringList(value []string) *IssueTriggerDeliveryConfigsConnections {
	return &IssueTriggerDeliveryConfigsConnections{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerDeliveryConfigsConnections) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerDeliveryConfigsConnections) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerDeliveryConfigsConnectionsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerDeliveryConfigsConnections) Accept(visitor IssueTriggerDeliveryConfigsConnectionsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Email channel for an issue trigger
type IssueTriggerEmailChannel struct {
}

// Integration channel for an issue trigger
type IssueTriggerIntegrationChannel struct {
}

type IssueTriggerPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*IssueTrigger `json:"models,omitempty"`
}

// Configuration object for the specific issue type selected
type IssueTriggerReference struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewIssueTriggerReferenceFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerReferenceFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerReferenceFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerReference) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typeName = "issueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typeName = "issueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typeName = "issueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerReference) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
}

type IssueTriggerReferenceVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerReference) Accept(visitor IssueTriggerReferenceVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
}

// Slack channel for an issue trigger
type IssueTriggerSlackChannel struct {
	// Channel name
	ChannelName string `json:"channel_name"`
}

// The strategy uses to open the issue
type IssueTriggerStrategy string

const (
	IssueTriggerStrategyFirstAttempt IssueTriggerStrategy = "first_attempt"
	IssueTriggerStrategyFinalAttempt IssueTriggerStrategy = "final_attempt"
)

func NewIssueTriggerStrategyFromString(s string) (IssueTriggerStrategy, error) {
	switch s {
	case "first_attempt":
		return IssueTriggerStrategyFirstAttempt, nil
	case "final_attempt":
		return IssueTriggerStrategyFinalAttempt, nil
	}
	var t IssueTriggerStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueTriggerStrategy) Ptr() *IssueTriggerStrategy {
	return &i
}

// Configurations for a 'Transformation' issue trigger
type IssueTriggerTransformationConfigs struct {
	LogLevel TransformationExecutionLogLevel `json:"log_level,omitempty"`
	// A pattern to match on the transformation name or array of transformation IDs. Use `*` as wildcard.
	Transformations *IssueTriggerTransformationConfigsTransformations `json:"transformations,omitempty"`
}

// A pattern to match on the transformation name or array of transformation IDs. Use `*` as wildcard.
type IssueTriggerTransformationConfigsTransformations struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerTransformationConfigsTransformationsFromString(value string) *IssueTriggerTransformationConfigsTransformations {
	return &IssueTriggerTransformationConfigsTransformations{typeName: "string", String: value}
}

func NewIssueTriggerTransformationConfigsTransformationsFromStringList(value []string) *IssueTriggerTransformationConfigsTransformations {
	return &IssueTriggerTransformationConfigsTransformations{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerTransformationConfigsTransformations) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerTransformationConfigsTransformations) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerTransformationConfigsTransformationsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerTransformationConfigsTransformations) Accept(visitor IssueTriggerTransformationConfigsTransformationsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Issue type
type IssueType string

const (
	IssueTypeDelivery       IssueType = "delivery"
	IssueTypeTransformation IssueType = "transformation"
	IssueTypeBackpressure   IssueType = "backpressure"
)

func NewIssueTypeFromString(s string) (IssueType, error) {
	switch s {
	case "delivery":
		return IssueTypeDelivery, nil
	case "transformation":
		return IssueTypeTransformation, nil
	case "backpressure":
		return IssueTypeBackpressure, nil
	}
	var t IssueType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueType) Ptr() *IssueType {
	return &i
}

type IssueWithData struct {
	Type           string
	Delivery       *DeliveryIssueWithData
	Transformation *TransformationIssueWithData
}

func NewIssueWithDataFromDelivery(value *DeliveryIssueWithData) *IssueWithData {
	return &IssueWithData{Type: "delivery", Delivery: value}
}

func NewIssueWithDataFromTransformation(value *TransformationIssueWithData) *IssueWithData {
	return &IssueWithData{Type: "transformation", Transformation: value}
}

func (i *IssueWithData) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "delivery":
		value := new(DeliveryIssueWithData)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Delivery = value
	case "transformation":
		value := new(TransformationIssueWithData)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Transformation = value
	}
	return nil
}

func (i IssueWithData) MarshalJSON() ([]byte, error) {
	switch i.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		var marshaler = struct {
			Type string `json:"type"`
			*DeliveryIssueWithData
		}{
			Type:                  i.Type,
			DeliveryIssueWithData: i.Delivery,
		}
		return json.Marshal(marshaler)
	case "transformation":
		var marshaler = struct {
			Type string `json:"type"`
			*TransformationIssueWithData
		}{
			Type:                        i.Type,
			TransformationIssueWithData: i.Transformation,
		}
		return json.Marshal(marshaler)
	}
}

type IssueWithDataVisitor interface {
	VisitDelivery(*DeliveryIssueWithData) error
	VisitTransformation(*TransformationIssueWithData) error
}

func (i *IssueWithData) Accept(visitor IssueWithDataVisitor) error {
	switch i.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		return visitor.VisitDelivery(i.Delivery)
	case "transformation":
		return visitor.VisitTransformation(i.Transformation)
	}
}

type IssueWithDataPaginatedResult struct {
	Pagination *SeekPagination  `json:"pagination,omitempty"`
	Count      *int             `json:"count,omitempty"`
	Models     []*IssueWithData `json:"models,omitempty"`
}

type ListCustomDomainSchema = []*ListCustomDomainSchemaItem

type ListCustomDomainSchemaItem struct {
	Id                    *string                                          `json:"id,omitempty"`
	Hostname              *string                                          `json:"hostname,omitempty"`
	Status                *string                                          `json:"status,omitempty"`
	Ssl                   *ListCustomDomainSchemaItemSsl                   `json:"ssl,omitempty"`
	VerificationErrors    []string                                         `json:"verification_errors,omitempty"`
	OwnershipVerification *ListCustomDomainSchemaItemOwnershipVerification `json:"ownership_verification,omitempty"`
	CreatedAt             *string                                          `json:"created_at,omitempty"`
}

type ListCustomDomainSchemaItemOwnershipVerification struct {
	Type  *string `json:"type,omitempty"`
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type ListCustomDomainSchemaItemSsl struct {
	Id                   *string                                                  `json:"id,omitempty"`
	Type                 *string                                                  `json:"type,omitempty"`
	Method               *string                                                  `json:"method,omitempty"`
	Status               *string                                                  `json:"status,omitempty"`
	TxtName              *string                                                  `json:"txt_name,omitempty"`
	TxtValue             *string                                                  `json:"txt_value,omitempty"`
	ValidationRecords    []*ListCustomDomainSchemaItemSslValidationRecordsItem    `json:"validation_records,omitempty"`
	DcvDelegationRecords []*ListCustomDomainSchemaItemSslDcvDelegationRecordsItem `json:"dcv_delegation_records,omitempty"`
	Settings             *ListCustomDomainSchemaItemSslSettings                   `json:"settings,omitempty"`
	BundleMethod         *string                                                  `json:"bundle_method,omitempty"`
	Wildcard             *bool                                                    `json:"wildcard,omitempty"`
	CertificateAuthority *string                                                  `json:"certificate_authority,omitempty"`
}

type ListCustomDomainSchemaItemSslDcvDelegationRecordsItem struct {
	Cname       *string `json:"cname,omitempty"`
	CnameTarget *string `json:"cname_target,omitempty"`
}

type ListCustomDomainSchemaItemSslSettings struct {
	MinTlsVersion *string `json:"min_tls_version,omitempty"`
}

type ListCustomDomainSchemaItemSslValidationRecordsItem struct {
	Status   *string `json:"status,omitempty"`
	TxtName  *string `json:"txt_name,omitempty"`
	TxtValue *string `json:"txt_value,omitempty"`
}

type OrderByDirection string

const (
	OrderByDirectionAsc  OrderByDirection = "asc"
	OrderByDirectionDesc OrderByDirection = "desc"
)

func NewOrderByDirectionFromString(s string) (OrderByDirection, error) {
	switch s {
	case "asc":
		return OrderByDirectionAsc, nil
	case "desc":
		return OrderByDirectionDesc, nil
	}
	var t OrderByDirection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderByDirection) Ptr() *OrderByDirection {
	return &o
}

type RawBody struct {
	Body string `json:"body"`
}

type Request struct {
	// ID of the request
	Id string `json:"id"`
	// ID of the project
	TeamId string `json:"team_id"`
	// Whether or not the request was verified when received
	Verified *bool `json:"verified,omitempty"`
	// ID of the request data
	OriginalEventDataId *string               `json:"original_event_data_id,omitempty"`
	RejectionCause      RequestRejectionCause `json:"rejection_cause,omitempty"`
	// The priority attributed to the request when received
	IngestPriority *RequestIngestPriority `json:"ingest_priority,omitempty"`
	// The time the request was originally received
	IngestedAt *time.Time `json:"ingested_at,omitempty"`
	// ID of the associated source
	SourceId string `json:"source_id"`
	// The count of events created from this request (CLI events not included)
	EventsCount *int `json:"events_count,omitempty"`
	// The count of CLI events created from this request
	CliEventsCount *int `json:"cli_events_count,omitempty"`
	IgnoredCount   *int `json:"ignored_count,omitempty"`
	// Date the event was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the event was created
	CreatedAt time.Time       `json:"created_at"`
	Data      *ShortEventData `json:"data,omitempty"`
}

// The priority attributed to the request when received
type RequestIngestPriority string

const (
	RequestIngestPriorityNormal RequestIngestPriority = "NORMAL"
	RequestIngestPriorityLow    RequestIngestPriority = "LOW"
)

func NewRequestIngestPriorityFromString(s string) (RequestIngestPriority, error) {
	switch s {
	case "NORMAL":
		return RequestIngestPriorityNormal, nil
	case "LOW":
		return RequestIngestPriorityLow, nil
	}
	var t RequestIngestPriority
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestIngestPriority) Ptr() *RequestIngestPriority {
	return &r
}

type RequestPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Request      `json:"models,omitempty"`
}

type RequestRejectionCause string

const (
	RequestRejectionCauseSourceDisabled         RequestRejectionCause = "SOURCE_DISABLED"
	RequestRejectionCauseNoConnection           RequestRejectionCause = "NO_CONNECTION"
	RequestRejectionCauseVerificationFailed     RequestRejectionCause = "VERIFICATION_FAILED"
	RequestRejectionCauseUnsupportedHttpMethod  RequestRejectionCause = "UNSUPPORTED_HTTP_METHOD"
	RequestRejectionCauseUnsupportedContentType RequestRejectionCause = "UNSUPPORTED_CONTENT_TYPE"
	RequestRejectionCauseUnparsableJson         RequestRejectionCause = "UNPARSABLE_JSON"
	RequestRejectionCausePayloadTooLarge        RequestRejectionCause = "PAYLOAD_TOO_LARGE"
	RequestRejectionCauseIngestionFatal         RequestRejectionCause = "INGESTION_FATAL"
	RequestRejectionCauseUnknown                RequestRejectionCause = "UNKNOWN"
)

func NewRequestRejectionCauseFromString(s string) (RequestRejectionCause, error) {
	switch s {
	case "SOURCE_DISABLED":
		return RequestRejectionCauseSourceDisabled, nil
	case "NO_CONNECTION":
		return RequestRejectionCauseNoConnection, nil
	case "VERIFICATION_FAILED":
		return RequestRejectionCauseVerificationFailed, nil
	case "UNSUPPORTED_HTTP_METHOD":
		return RequestRejectionCauseUnsupportedHttpMethod, nil
	case "UNSUPPORTED_CONTENT_TYPE":
		return RequestRejectionCauseUnsupportedContentType, nil
	case "UNPARSABLE_JSON":
		return RequestRejectionCauseUnparsableJson, nil
	case "PAYLOAD_TOO_LARGE":
		return RequestRejectionCausePayloadTooLarge, nil
	case "INGESTION_FATAL":
		return RequestRejectionCauseIngestionFatal, nil
	case "UNKNOWN":
		return RequestRejectionCauseUnknown, nil
	}
	var t RequestRejectionCause
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestRejectionCause) Ptr() *RequestRejectionCause {
	return &r
}

type RetriedEvent struct {
	Event   *Event        `json:"event,omitempty"`
	Attempt *EventAttempt `json:"attempt,omitempty"`
}

type RetryRequest struct {
	Request *Request `json:"request,omitempty"`
	Events  []*Event `json:"events,omitempty"`
}

type RetryRule struct {
	Strategy RetryStrategy `json:"strategy,omitempty"`
	// Time in MS between each retry
	Interval *int `json:"interval,omitempty"`
	// Maximum number of retries to attempt
	Count *int `json:"count,omitempty"`
}

// Algorithm to use when calculating delay between retries
type RetryStrategy string

const (
	RetryStrategyLinear      RetryStrategy = "linear"
	RetryStrategyExponential RetryStrategy = "exponential"
)

func NewRetryStrategyFromString(s string) (RetryStrategy, error) {
	switch s {
	case "linear":
		return RetryStrategyLinear, nil
	case "exponential":
		return RetryStrategyExponential, nil
	}
	var t RetryStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RetryStrategy) Ptr() *RetryStrategy {
	return &r
}

type Rule struct {
	Type      string
	Retry     *RetryRule
	Filter    *FilterRule
	Transform *TransformRule
	Delay     *DelayRule
}

func NewRuleFromRetry(value *RetryRule) *Rule {
	return &Rule{Type: "retry", Retry: value}
}

func NewRuleFromFilter(value *FilterRule) *Rule {
	return &Rule{Type: "filter", Filter: value}
}

func NewRuleFromTransform(value *TransformRule) *Rule {
	return &Rule{Type: "transform", Transform: value}
}

func NewRuleFromDelay(value *DelayRule) *Rule {
	return &Rule{Type: "delay", Delay: value}
}

func (r *Rule) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	r.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "retry":
		value := new(RetryRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Retry = value
	case "filter":
		value := new(FilterRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Filter = value
	case "transform":
		value := new(TransformRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Transform = value
	case "delay":
		value := new(DelayRule)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		r.Delay = value
	}
	return nil
}

func (r Rule) MarshalJSON() ([]byte, error) {
	switch r.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "retry":
		var marshaler = struct {
			Type string `json:"type"`
			*RetryRule
		}{
			Type:      r.Type,
			RetryRule: r.Retry,
		}
		return json.Marshal(marshaler)
	case "filter":
		var marshaler = struct {
			Type string `json:"type"`
			*FilterRule
		}{
			Type:       r.Type,
			FilterRule: r.Filter,
		}
		return json.Marshal(marshaler)
	case "transform":
		var marshaler = struct {
			Type string `json:"type"`
			*TransformRule
		}{
			Type:          r.Type,
			TransformRule: r.Transform,
		}
		return json.Marshal(marshaler)
	case "delay":
		var marshaler = struct {
			Type string `json:"type"`
			*DelayRule
		}{
			Type:      r.Type,
			DelayRule: r.Delay,
		}
		return json.Marshal(marshaler)
	}
}

type RuleVisitor interface {
	VisitRetry(*RetryRule) error
	VisitFilter(*FilterRule) error
	VisitTransform(*TransformRule) error
	VisitDelay(*DelayRule) error
}

func (r *Rule) Accept(visitor RuleVisitor) error {
	switch r.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", r.Type, r)
	case "retry":
		return visitor.VisitRetry(r.Retry)
	case "filter":
		return visitor.VisitFilter(r.Filter)
	case "transform":
		return visitor.VisitTransform(r.Transform)
	case "delay":
		return visitor.VisitDelay(r.Delay)
	}
}

type SeekPagination struct {
	OrderBy *SeekPaginationOrderBy `json:"order_by,omitempty"`
	Dir     *SeekPaginationDir     `json:"dir,omitempty"`
	Limit   *int                   `json:"limit,omitempty"`
	Prev    *string                `json:"prev,omitempty"`
	Next    *string                `json:"next,omitempty"`
}

type SeekPaginationDir struct {
	typeName             string
	OrderByDirection     OrderByDirection
	OrderByDirectionList []OrderByDirection
}

func NewSeekPaginationDirFromOrderByDirection(value OrderByDirection) *SeekPaginationDir {
	return &SeekPaginationDir{typeName: "orderByDirection", OrderByDirection: value}
}

func NewSeekPaginationDirFromOrderByDirectionList(value []OrderByDirection) *SeekPaginationDir {
	return &SeekPaginationDir{typeName: "orderByDirectionList", OrderByDirectionList: value}
}

func (s *SeekPaginationDir) UnmarshalJSON(data []byte) error {
	var valueOrderByDirection OrderByDirection
	if err := json.Unmarshal(data, &valueOrderByDirection); err == nil {
		s.typeName = "orderByDirection"
		s.OrderByDirection = valueOrderByDirection
		return nil
	}
	var valueOrderByDirectionList []OrderByDirection
	if err := json.Unmarshal(data, &valueOrderByDirectionList); err == nil {
		s.typeName = "orderByDirectionList"
		s.OrderByDirectionList = valueOrderByDirectionList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SeekPaginationDir) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "orderByDirection":
		return json.Marshal(s.OrderByDirection)
	case "orderByDirectionList":
		return json.Marshal(s.OrderByDirectionList)
	}
}

type SeekPaginationDirVisitor interface {
	VisitOrderByDirection(OrderByDirection) error
	VisitOrderByDirectionList([]OrderByDirection) error
}

func (s *SeekPaginationDir) Accept(visitor SeekPaginationDirVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "orderByDirection":
		return visitor.VisitOrderByDirection(s.OrderByDirection)
	case "orderByDirectionList":
		return visitor.VisitOrderByDirectionList(s.OrderByDirectionList)
	}
}

type SeekPaginationOrderBy struct {
	typeName   string
	String     string
	StringList []string
}

func NewSeekPaginationOrderByFromString(value string) *SeekPaginationOrderBy {
	return &SeekPaginationOrderBy{typeName: "string", String: value}
}

func NewSeekPaginationOrderByFromStringList(value []string) *SeekPaginationOrderBy {
	return &SeekPaginationOrderBy{typeName: "stringList", StringList: value}
}

func (s *SeekPaginationOrderBy) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		s.typeName = "stringList"
		s.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SeekPaginationOrderBy) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "stringList":
		return json.Marshal(s.StringList)
	}
}

type SeekPaginationOrderByVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (s *SeekPaginationOrderBy) Accept(visitor SeekPaginationOrderByVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "stringList":
		return visitor.VisitStringList(s.StringList)
	}
}

type ShopifyIntegrationConfigs struct {
	WebhookSecretKey string                                    `json:"webhook_secret_key"`
	RateLimitPeriod  *ShopifyIntegrationConfigsRateLimitPeriod `json:"rate_limit_period,omitempty"`
	RateLimit        *float64                                  `json:"rate_limit,omitempty"`
	ApiKey           *string                                   `json:"api_key,omitempty"`
	ApiSecret        *string                                   `json:"api_secret,omitempty"`
	Shop             *string                                   `json:"shop,omitempty"`
}

type ShopifyIntegrationConfigsRateLimitPeriod string

const (
	ShopifyIntegrationConfigsRateLimitPeriodMinute ShopifyIntegrationConfigsRateLimitPeriod = "minute"
	ShopifyIntegrationConfigsRateLimitPeriodSecond ShopifyIntegrationConfigsRateLimitPeriod = "second"
)

func NewShopifyIntegrationConfigsRateLimitPeriodFromString(s string) (ShopifyIntegrationConfigsRateLimitPeriod, error) {
	switch s {
	case "minute":
		return ShopifyIntegrationConfigsRateLimitPeriodMinute, nil
	case "second":
		return ShopifyIntegrationConfigsRateLimitPeriodSecond, nil
	}
	var t ShopifyIntegrationConfigsRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShopifyIntegrationConfigsRateLimitPeriod) Ptr() *ShopifyIntegrationConfigsRateLimitPeriod {
	return &s
}

// Request data
type ShortEventData struct {
	// Request path
	Path string `json:"path"`
	// Raw query param string
	Query *string `json:"query,omitempty"`
	// JSON representation of query params
	ParsedQuery *ShortEventDataParsedQuery `json:"parsed_query,omitempty"`
	// JSON representation of the headers
	Headers *ShortEventDataHeaders `json:"headers,omitempty"`
	// JSON or string representation of the body
	Body *ShortEventDataBody `json:"body,omitempty"`
	// Whether the payload is considered large payload and not searchable
	IsLargePayload *bool `json:"is_large_payload,omitempty"`
}

// JSON or string representation of the body
type ShortEventDataBody struct {
	typeName              string
	String                string
	ShortEventDataBodyOne *ShortEventDataBodyOne
	UnknownList           []interface{}
}

func NewShortEventDataBodyFromString(value string) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "string", String: value}
}

func NewShortEventDataBodyFromShortEventDataBodyOne(value *ShortEventDataBodyOne) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "shortEventDataBodyOne", ShortEventDataBodyOne: value}
}

func NewShortEventDataBodyFromUnknownList(value []interface{}) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "unknownList", UnknownList: value}
}

func (s *ShortEventDataBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueShortEventDataBodyOne := new(ShortEventDataBodyOne)
	if err := json.Unmarshal(data, &valueShortEventDataBodyOne); err == nil {
		s.typeName = "shortEventDataBodyOne"
		s.ShortEventDataBodyOne = valueShortEventDataBodyOne
		return nil
	}
	var valueUnknownList []interface{}
	if err := json.Unmarshal(data, &valueUnknownList); err == nil {
		s.typeName = "unknownList"
		s.UnknownList = valueUnknownList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataBody) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "shortEventDataBodyOne":
		return json.Marshal(s.ShortEventDataBodyOne)
	case "unknownList":
		return json.Marshal(s.UnknownList)
	}
}

type ShortEventDataBodyVisitor interface {
	VisitString(string) error
	VisitShortEventDataBodyOne(*ShortEventDataBodyOne) error
	VisitUnknownList([]interface{}) error
}

func (s *ShortEventDataBody) Accept(visitor ShortEventDataBodyVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "shortEventDataBodyOne":
		return visitor.VisitShortEventDataBodyOne(s.ShortEventDataBodyOne)
	case "unknownList":
		return visitor.VisitUnknownList(s.UnknownList)
	}
}

type ShortEventDataBodyOne struct {
}

// JSON representation of the headers
type ShortEventDataHeaders struct {
	typeName                string
	String                  string
	StringStringOptionalMap map[string]*string
}

func NewShortEventDataHeadersFromString(value string) *ShortEventDataHeaders {
	return &ShortEventDataHeaders{typeName: "string", String: value}
}

func NewShortEventDataHeadersFromStringStringOptionalMap(value map[string]*string) *ShortEventDataHeaders {
	return &ShortEventDataHeaders{typeName: "stringStringOptionalMap", StringStringOptionalMap: value}
}

func (s *ShortEventDataHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	var valueStringStringOptionalMap map[string]*string
	if err := json.Unmarshal(data, &valueStringStringOptionalMap); err == nil {
		s.typeName = "stringStringOptionalMap"
		s.StringStringOptionalMap = valueStringStringOptionalMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataHeaders) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "stringStringOptionalMap":
		return json.Marshal(s.StringStringOptionalMap)
	}
}

type ShortEventDataHeadersVisitor interface {
	VisitString(string) error
	VisitStringStringOptionalMap(map[string]*string) error
}

func (s *ShortEventDataHeaders) Accept(visitor ShortEventDataHeadersVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "stringStringOptionalMap":
		return visitor.VisitStringStringOptionalMap(s.StringStringOptionalMap)
	}
}

// JSON representation of query params
type ShortEventDataParsedQuery struct {
	typeName                     string
	StringOptional               *string
	ShortEventDataParsedQueryOne *ShortEventDataParsedQueryOne
}

func NewShortEventDataParsedQueryFromStringOptional(value *string) *ShortEventDataParsedQuery {
	return &ShortEventDataParsedQuery{typeName: "stringOptional", StringOptional: value}
}

func NewShortEventDataParsedQueryFromShortEventDataParsedQueryOne(value *ShortEventDataParsedQueryOne) *ShortEventDataParsedQuery {
	return &ShortEventDataParsedQuery{typeName: "shortEventDataParsedQueryOne", ShortEventDataParsedQueryOne: value}
}

func (s *ShortEventDataParsedQuery) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		s.typeName = "stringOptional"
		s.StringOptional = valueStringOptional
		return nil
	}
	valueShortEventDataParsedQueryOne := new(ShortEventDataParsedQueryOne)
	if err := json.Unmarshal(data, &valueShortEventDataParsedQueryOne); err == nil {
		s.typeName = "shortEventDataParsedQueryOne"
		s.ShortEventDataParsedQueryOne = valueShortEventDataParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataParsedQuery) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringOptional":
		return json.Marshal(s.StringOptional)
	case "shortEventDataParsedQueryOne":
		return json.Marshal(s.ShortEventDataParsedQueryOne)
	}
}

type ShortEventDataParsedQueryVisitor interface {
	VisitStringOptional(*string) error
	VisitShortEventDataParsedQueryOne(*ShortEventDataParsedQueryOne) error
}

func (s *ShortEventDataParsedQuery) Accept(visitor ShortEventDataParsedQueryVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringOptional":
		return visitor.VisitStringOptional(s.StringOptional)
	case "shortEventDataParsedQueryOne":
		return visitor.VisitShortEventDataParsedQueryOne(s.ShortEventDataParsedQueryOne)
	}
}

type ShortEventDataParsedQueryOne struct {
}

// Associated [Source](#source-object) object
type Source struct {
	// ID of the source
	Id string `json:"id"`
	// Name for the source
	Name string `json:"name"`
	// Description of the source
	Description *string `json:"description,omitempty"`
	// ID of the project
	TeamId string `json:"team_id"`
	// A unique URL that must be supplied to your webhook's provider
	Url                string                   `json:"url"`
	Verification       *SourceVerification      `json:"verification,omitempty"`
	AllowedHttpMethods *SourceAllowedHttpMethod `json:"allowed_http_methods,omitempty"`
	CustomResponse     *SourceCustomResponse    `json:"custom_response,omitempty"`
	// Date the source was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty"`
	// Date the source was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the source was created
	CreatedAt time.Time `json:"created_at"`
}

// List of allowed HTTP methods. Defaults to PUT, POST, PATCH, DELETE.
type SourceAllowedHttpMethod = []SourceAllowedHttpMethodItem

type SourceAllowedHttpMethodItem string

const (
	SourceAllowedHttpMethodItemGet    SourceAllowedHttpMethodItem = "GET"
	SourceAllowedHttpMethodItemPost   SourceAllowedHttpMethodItem = "POST"
	SourceAllowedHttpMethodItemPut    SourceAllowedHttpMethodItem = "PUT"
	SourceAllowedHttpMethodItemPatch  SourceAllowedHttpMethodItem = "PATCH"
	SourceAllowedHttpMethodItemDelete SourceAllowedHttpMethodItem = "DELETE"
)

func NewSourceAllowedHttpMethodItemFromString(s string) (SourceAllowedHttpMethodItem, error) {
	switch s {
	case "GET":
		return SourceAllowedHttpMethodItemGet, nil
	case "POST":
		return SourceAllowedHttpMethodItemPost, nil
	case "PUT":
		return SourceAllowedHttpMethodItemPut, nil
	case "PATCH":
		return SourceAllowedHttpMethodItemPatch, nil
	case "DELETE":
		return SourceAllowedHttpMethodItemDelete, nil
	}
	var t SourceAllowedHttpMethodItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceAllowedHttpMethodItem) Ptr() *SourceAllowedHttpMethodItem {
	return &s
}

// Custom response object
type SourceCustomResponse struct {
	ContentType SourceCustomResponseContentType `json:"content_type,omitempty"`
	// Body of the custom response
	Body string `json:"body"`
}

// Content type of the custom response
type SourceCustomResponseContentType string

const (
	SourceCustomResponseContentTypeJson SourceCustomResponseContentType = "json"
	SourceCustomResponseContentTypeText SourceCustomResponseContentType = "text"
	SourceCustomResponseContentTypeXml  SourceCustomResponseContentType = "xml"
)

func NewSourceCustomResponseContentTypeFromString(s string) (SourceCustomResponseContentType, error) {
	switch s {
	case "json":
		return SourceCustomResponseContentTypeJson, nil
	case "text":
		return SourceCustomResponseContentTypeText, nil
	case "xml":
		return SourceCustomResponseContentTypeXml, nil
	}
	var t SourceCustomResponseContentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceCustomResponseContentType) Ptr() *SourceCustomResponseContentType {
	return &s
}

type SourcePaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Source       `json:"models,omitempty"`
}

type SourceVerification struct {
	typeName              string
	VerificationConfig    *VerificationConfig
	SourceVerificationOne *SourceVerificationOne
}

func NewSourceVerificationFromVerificationConfig(value *VerificationConfig) *SourceVerification {
	return &SourceVerification{typeName: "verificationConfig", VerificationConfig: value}
}

func NewSourceVerificationFromSourceVerificationOne(value *SourceVerificationOne) *SourceVerification {
	return &SourceVerification{typeName: "sourceVerificationOne", SourceVerificationOne: value}
}

func (s *SourceVerification) UnmarshalJSON(data []byte) error {
	valueVerificationConfig := new(VerificationConfig)
	if err := json.Unmarshal(data, &valueVerificationConfig); err == nil {
		s.typeName = "verificationConfig"
		s.VerificationConfig = valueVerificationConfig
		return nil
	}
	valueSourceVerificationOne := new(SourceVerificationOne)
	if err := json.Unmarshal(data, &valueSourceVerificationOne); err == nil {
		s.typeName = "sourceVerificationOne"
		s.SourceVerificationOne = valueSourceVerificationOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SourceVerification) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "verificationConfig":
		return json.Marshal(s.VerificationConfig)
	case "sourceVerificationOne":
		return json.Marshal(s.SourceVerificationOne)
	}
}

type SourceVerificationVisitor interface {
	VisitVerificationConfig(*VerificationConfig) error
	VisitSourceVerificationOne(*SourceVerificationOne) error
}

func (s *SourceVerification) Accept(visitor SourceVerificationVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "verificationConfig":
		return visitor.VisitVerificationConfig(s.VerificationConfig)
	case "sourceVerificationOne":
		return visitor.VisitSourceVerificationOne(s.SourceVerificationOne)
	}
}

type SourceVerificationOne struct {
}

type ToggleWebhookNotifications struct {
	Enabled  bool          `json:"enabled"`
	Topics   []TopicsValue `json:"topics,omitempty"`
	SourceId string        `json:"source_id"`
}

// Supported topics
type TopicsValue string

const (
	TopicsValueIssueOpened             TopicsValue = "issue.opened"
	TopicsValueIssueUpdated            TopicsValue = "issue.updated"
	TopicsValueDeprecatedAttemptFailed TopicsValue = "deprecated.attempt-failed"
	TopicsValueEventSuccessful         TopicsValue = "event.successful"
)

func NewTopicsValueFromString(s string) (TopicsValue, error) {
	switch s {
	case "issue.opened":
		return TopicsValueIssueOpened, nil
	case "issue.updated":
		return TopicsValueIssueUpdated, nil
	case "deprecated.attempt-failed":
		return TopicsValueDeprecatedAttemptFailed, nil
	case "event.successful":
		return TopicsValueEventSuccessful, nil
	}
	var t TopicsValue
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TopicsValue) Ptr() *TopicsValue {
	return &t
}

type TransformRule struct {
	// ID of the attached transformation object. Optional input, always set once the rule is defined
	TransformationId *string `json:"transformation_id,omitempty"`
	// You can optionally define a new transformation while creating a transform rule
	Transformation *TransformRuleTransformation `json:"transformation,omitempty"`
}

// You can optionally define a new transformation while creating a transform rule
type TransformRuleTransformation struct {
	// The unique name of the transformation
	Name string `json:"name"`
	// A string representation of your JavaScript (ES6) code to run
	Code string `json:"code"`
	// A key-value object of environment variables to encrypt and expose to your transformation code
	Env map[string]*string `json:"env,omitempty"`
}

type Transformation struct {
	// ID of the transformation
	Id string `json:"id"`
	// ID of the project
	TeamId string `json:"team_id"`
	// A unique, human-friendly name for the transformation
	Name string `json:"name"`
	// JavaScript code to be executed
	Code         string  `json:"code"`
	EncryptedEnv *string `json:"encrypted_env,omitempty"`
	Iv           *string `json:"iv,omitempty"`
	// Key-value environment variables to be passed to the transformation
	Env map[string]*string `json:"env,omitempty"`
	// Date the transformation was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the transformation was created
	CreatedAt time.Time `json:"created_at"`
}

type TransformationExecution struct {
	Id                     string                          `json:"id"`
	TransformedEventDataId string                          `json:"transformed_event_data_id"`
	OriginalEventDataId    string                          `json:"original_event_data_id"`
	TransformationId       string                          `json:"transformation_id"`
	TeamId                 string                          `json:"team_id"`
	WebhookId              string                          `json:"webhook_id"`
	LogLevel               TransformationExecutionLogLevel `json:"log_level,omitempty"`
	Logs                   []*ConsoleLine                  `json:"logs,omitempty"`
	UpdatedAt              time.Time                       `json:"updated_at"`
	CreatedAt              time.Time                       `json:"created_at"`
	OriginalEventData      *ShortEventData                 `json:"original_event_data,omitempty"`
	TransformedEventData   *ShortEventData                 `json:"transformed_event_data,omitempty"`
	IssueId                *string                         `json:"issue_id,omitempty"`
}

// The minimum log level to open the issue on
type TransformationExecutionLogLevel string

const (
	TransformationExecutionLogLevelDebug TransformationExecutionLogLevel = "debug"
	TransformationExecutionLogLevelInfo  TransformationExecutionLogLevel = "info"
	TransformationExecutionLogLevelWarn  TransformationExecutionLogLevel = "warn"
	TransformationExecutionLogLevelError TransformationExecutionLogLevel = "error"
	TransformationExecutionLogLevelFatal TransformationExecutionLogLevel = "fatal"
)

func NewTransformationExecutionLogLevelFromString(s string) (TransformationExecutionLogLevel, error) {
	switch s {
	case "debug":
		return TransformationExecutionLogLevelDebug, nil
	case "info":
		return TransformationExecutionLogLevelInfo, nil
	case "warn":
		return TransformationExecutionLogLevelWarn, nil
	case "error":
		return TransformationExecutionLogLevelError, nil
	case "fatal":
		return TransformationExecutionLogLevelFatal, nil
	}
	var t TransformationExecutionLogLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransformationExecutionLogLevel) Ptr() *TransformationExecutionLogLevel {
	return &t
}

type TransformationExecutionPaginatedResult struct {
	Pagination *SeekPagination            `json:"pagination,omitempty"`
	Count      *int                       `json:"count,omitempty"`
	Models     []*TransformationExecution `json:"models,omitempty"`
}

type TransformationExecutorOutput struct {
	RequestId        *string                              `json:"request_id,omitempty"`
	TransformationId *string                              `json:"transformation_id,omitempty"`
	ExecutionId      *string                              `json:"execution_id,omitempty"`
	LogLevel         TransformationExecutionLogLevel      `json:"log_level,omitempty"`
	Request          *TransformationExecutorOutputRequest `json:"request,omitempty"`
	Console          []*ConsoleLine                       `json:"console,omitempty"`
}

type TransformationExecutorOutputRequest struct {
	Headers     *TransformationExecutorOutputRequestHeaders     `json:"headers,omitempty"`
	Path        string                                          `json:"path"`
	Query       *TransformationExecutorOutputRequestQuery       `json:"query,omitempty"`
	ParsedQuery *TransformationExecutorOutputRequestParsedQuery `json:"parsed_query,omitempty"`
	Body        *TransformationExecutorOutputRequestBody        `json:"body,omitempty"`
}

type TransformationExecutorOutputRequestBody struct {
	typeName                                   string
	StringOptional                             *string
	TransformationExecutorOutputRequestBodyOne *TransformationExecutorOutputRequestBodyOne
}

func NewTransformationExecutorOutputRequestBodyFromStringOptional(value *string) *TransformationExecutorOutputRequestBody {
	return &TransformationExecutorOutputRequestBody{typeName: "stringOptional", StringOptional: value}
}

func NewTransformationExecutorOutputRequestBodyFromTransformationExecutorOutputRequestBodyOne(value *TransformationExecutorOutputRequestBodyOne) *TransformationExecutorOutputRequestBody {
	return &TransformationExecutorOutputRequestBody{typeName: "transformationExecutorOutputRequestBodyOne", TransformationExecutorOutputRequestBodyOne: value}
}

func (t *TransformationExecutorOutputRequestBody) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		t.typeName = "stringOptional"
		t.StringOptional = valueStringOptional
		return nil
	}
	valueTransformationExecutorOutputRequestBodyOne := new(TransformationExecutorOutputRequestBodyOne)
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestBodyOne); err == nil {
		t.typeName = "transformationExecutorOutputRequestBodyOne"
		t.TransformationExecutorOutputRequestBodyOne = valueTransformationExecutorOutputRequestBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestBody) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return json.Marshal(t.StringOptional)
	case "transformationExecutorOutputRequestBodyOne":
		return json.Marshal(t.TransformationExecutorOutputRequestBodyOne)
	}
}

type TransformationExecutorOutputRequestBodyVisitor interface {
	VisitStringOptional(*string) error
	VisitTransformationExecutorOutputRequestBodyOne(*TransformationExecutorOutputRequestBodyOne) error
}

func (t *TransformationExecutorOutputRequestBody) Accept(visitor TransformationExecutorOutputRequestBodyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return visitor.VisitStringOptional(t.StringOptional)
	case "transformationExecutorOutputRequestBodyOne":
		return visitor.VisitTransformationExecutorOutputRequestBodyOne(t.TransformationExecutorOutputRequestBodyOne)
	}
}

type TransformationExecutorOutputRequestBodyOne struct {
}

type TransformationExecutorOutputRequestHeaders struct {
	typeName         string
	String           string
	StringUnknownMap map[string]interface{}
}

func NewTransformationExecutorOutputRequestHeadersFromString(value string) *TransformationExecutorOutputRequestHeaders {
	return &TransformationExecutorOutputRequestHeaders{typeName: "string", String: value}
}

func NewTransformationExecutorOutputRequestHeadersFromStringUnknownMap(value map[string]interface{}) *TransformationExecutorOutputRequestHeaders {
	return &TransformationExecutorOutputRequestHeaders{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (t *TransformationExecutorOutputRequestHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		t.typeName = "stringUnknownMap"
		t.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestHeaders) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "stringUnknownMap":
		return json.Marshal(t.StringUnknownMap)
	}
}

type TransformationExecutorOutputRequestHeadersVisitor interface {
	VisitString(string) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (t *TransformationExecutorOutputRequestHeaders) Accept(visitor TransformationExecutorOutputRequestHeadersVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(t.StringUnknownMap)
	}
}

type TransformationExecutorOutputRequestParsedQuery struct {
	typeName                                          string
	StringOptional                                    *string
	TransformationExecutorOutputRequestParsedQueryOne *TransformationExecutorOutputRequestParsedQueryOne
}

func NewTransformationExecutorOutputRequestParsedQueryFromStringOptional(value *string) *TransformationExecutorOutputRequestParsedQuery {
	return &TransformationExecutorOutputRequestParsedQuery{typeName: "stringOptional", StringOptional: value}
}

func NewTransformationExecutorOutputRequestParsedQueryFromTransformationExecutorOutputRequestParsedQueryOne(value *TransformationExecutorOutputRequestParsedQueryOne) *TransformationExecutorOutputRequestParsedQuery {
	return &TransformationExecutorOutputRequestParsedQuery{typeName: "transformationExecutorOutputRequestParsedQueryOne", TransformationExecutorOutputRequestParsedQueryOne: value}
}

func (t *TransformationExecutorOutputRequestParsedQuery) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		t.typeName = "stringOptional"
		t.StringOptional = valueStringOptional
		return nil
	}
	valueTransformationExecutorOutputRequestParsedQueryOne := new(TransformationExecutorOutputRequestParsedQueryOne)
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestParsedQueryOne); err == nil {
		t.typeName = "transformationExecutorOutputRequestParsedQueryOne"
		t.TransformationExecutorOutputRequestParsedQueryOne = valueTransformationExecutorOutputRequestParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestParsedQuery) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return json.Marshal(t.StringOptional)
	case "transformationExecutorOutputRequestParsedQueryOne":
		return json.Marshal(t.TransformationExecutorOutputRequestParsedQueryOne)
	}
}

type TransformationExecutorOutputRequestParsedQueryVisitor interface {
	VisitStringOptional(*string) error
	VisitTransformationExecutorOutputRequestParsedQueryOne(*TransformationExecutorOutputRequestParsedQueryOne) error
}

func (t *TransformationExecutorOutputRequestParsedQuery) Accept(visitor TransformationExecutorOutputRequestParsedQueryVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return visitor.VisitStringOptional(t.StringOptional)
	case "transformationExecutorOutputRequestParsedQueryOne":
		return visitor.VisitTransformationExecutorOutputRequestParsedQueryOne(t.TransformationExecutorOutputRequestParsedQueryOne)
	}
}

type TransformationExecutorOutputRequestParsedQueryOne struct {
}

type TransformationExecutorOutputRequestQuery struct {
	typeName                                             string
	TransformationExecutorOutputRequestQueryZeroOptional *TransformationExecutorOutputRequestQueryZero
	String                                               string
}

func NewTransformationExecutorOutputRequestQueryFromTransformationExecutorOutputRequestQueryZeroOptional(value *TransformationExecutorOutputRequestQueryZero) *TransformationExecutorOutputRequestQuery {
	return &TransformationExecutorOutputRequestQuery{typeName: "transformationExecutorOutputRequestQueryZeroOptional", TransformationExecutorOutputRequestQueryZeroOptional: value}
}

func NewTransformationExecutorOutputRequestQueryFromString(value string) *TransformationExecutorOutputRequestQuery {
	return &TransformationExecutorOutputRequestQuery{typeName: "string", String: value}
}

func (t *TransformationExecutorOutputRequestQuery) UnmarshalJSON(data []byte) error {
	var valueTransformationExecutorOutputRequestQueryZeroOptional *TransformationExecutorOutputRequestQueryZero
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestQueryZeroOptional); err == nil {
		t.typeName = "transformationExecutorOutputRequestQueryZeroOptional"
		t.TransformationExecutorOutputRequestQueryZeroOptional = valueTransformationExecutorOutputRequestQueryZeroOptional
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestQuery) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationExecutorOutputRequestQueryZeroOptional":
		return json.Marshal(t.TransformationExecutorOutputRequestQueryZeroOptional)
	case "string":
		return json.Marshal(t.String)
	}
}

type TransformationExecutorOutputRequestQueryVisitor interface {
	VisitTransformationExecutorOutputRequestQueryZeroOptional(*TransformationExecutorOutputRequestQueryZero) error
	VisitString(string) error
}

func (t *TransformationExecutorOutputRequestQuery) Accept(visitor TransformationExecutorOutputRequestQueryVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationExecutorOutputRequestQueryZeroOptional":
		return visitor.VisitTransformationExecutorOutputRequestQueryZeroOptional(t.TransformationExecutorOutputRequestQueryZeroOptional)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TransformationExecutorOutputRequestQueryZero struct {
}

type TransformationFailedMeta struct {
	TransformationId string `json:"transformation_id"`
}

// Transformation issue
type TransformationIssue struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the project
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// Deprecated, will always be set to null
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                              `json:"created_at"`
	AggregationKeys *TransformationIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *TransformationIssueReference       `json:"reference,omitempty"`
}

// Keys used as the aggregation keys a 'transformation' type issue
type TransformationIssueAggregationKeys struct {
	TransformationId []string                        `json:"transformation_id,omitempty"`
	LogLevel         TransformationExecutionLogLevel `json:"log_level,omitempty"`
}

// Transformation issue data
type TransformationIssueData struct {
	TransformationExecution *TransformationExecution `json:"transformation_execution,omitempty"`
	TriggerAttempt          *EventAttempt            `json:"trigger_attempt,omitempty"`
}

// Reference to the event request transformation an issue is being created for.
type TransformationIssueReference struct {
	TransformationExecutionId string `json:"transformation_execution_id"`
	// Deprecated but still found on historical issues
	TriggerEventRequestTransformationId *string `json:"trigger_event_request_transformation_id,omitempty"`
}

// Transformation issue
type TransformationIssueWithData struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the project
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// Deprecated, will always be set to null
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                              `json:"created_at"`
	AggregationKeys *TransformationIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *TransformationIssueReference       `json:"reference,omitempty"`
	Data            *TransformationIssueData            `json:"data,omitempty"`
}

type TransformationPaginatedResult struct {
	Pagination *SeekPagination   `json:"pagination,omitempty"`
	Count      *int              `json:"count,omitempty"`
	Models     []*Transformation `json:"models,omitempty"`
}

type VercelLogDrainsIntegrationConfigs struct {
	WebhookSecretKey      *string `json:"webhook_secret_key,omitempty"`
	VercelLogDrainsSecret string  `json:"vercel_log_drains_secret"`
}

type Verification3DEye struct {
	Configs *Verification3DEyeConfigs `json:"configs,omitempty"`
}

// The verification configs for 3dEye. Only included if the ?include=verification.configs query param is present
type Verification3DEyeConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationAdyen struct {
	Configs *VerificationAdyenConfigs `json:"configs,omitempty"`
}

// The verification configs for Adyen. Only included if the ?include=verification.configs query param is present
type VerificationAdyenConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationAkeneo struct {
	Configs *VerificationAkeneoConfigs `json:"configs,omitempty"`
}

// The verification configs for Akeneo. Only included if the ?include=verification.configs query param is present
type VerificationAkeneoConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationApiKey struct {
	Configs *VerificationApiKeyConfigs `json:"configs,omitempty"`
}

// The verification configs for API Key. Only included if the ?include=verification.configs query param is present
type VerificationApiKeyConfigs struct {
	HeaderKey string `json:"header_key"`
	ApiKey    string `json:"api_key"`
}

type VerificationAwssns struct {
	Configs *VerificationAwssnsConfigs `json:"configs,omitempty"`
}

// The verification configs for AWS SNS. Only included if the ?include=verification.configs query param is present
type VerificationAwssnsConfigs struct {
}

type VerificationBasicAuth struct {
	Configs *VerificationBasicAuthConfigs `json:"configs,omitempty"`
}

// The verification configs for Basic Auth. Only included if the ?include=verification.configs query param is present
type VerificationBasicAuthConfigs struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type VerificationBondsmith struct {
	Configs *VerificationBondsmithConfigs `json:"configs,omitempty"`
}

// The verification configs for Bondsmith. Only included if the ?include=verification.configs query param is present
type VerificationBondsmithConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationCloudSignal struct {
	Configs *VerificationCloudSignalConfigs `json:"configs,omitempty"`
}

// The verification configs for Cloud Signal. Only included if the ?include=verification.configs query param is present
type VerificationCloudSignalConfigs struct {
	ApiKey string `json:"api_key"`
}

type VerificationCommercelayer struct {
	Configs *VerificationCommercelayerConfigs `json:"configs,omitempty"`
}

// The verification configs for Commercelayer. Only included if the ?include=verification.configs query param is present
type VerificationCommercelayerConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

// The verification configs for the specified verification type
type VerificationConfig struct {
	Type            string
	Hmac            *VerificationHmac
	BasicAuth       *VerificationBasicAuth
	ApiKey          *VerificationApiKey
	Cloudsignal     *VerificationCloudSignal
	Courier         *VerificationCourier
	Frontapp        *VerificationFrontApp
	Twitter         *VerificationTwitter
	Stripe          *VerificationStripe
	Recharge        *VerificationRecharge
	Twilio          *VerificationTwilio
	Github          *VerificationGitHub
	Shopify         *VerificationShopify
	Postmark        *VerificationPostmark
	Typeform        *VerificationTypeform
	Xero            *VerificationXero
	Svix            *VerificationSvix
	Zoom            *VerificationZoom
	Akeneo          *VerificationAkeneo
	Adyen           *VerificationAdyen
	Gitlab          *VerificationGitLab
	PropertyFinder  *VerificationPropertyFinder
	Woocommerce     *VerificationWooCommerce
	Oura            *VerificationOura
	Commercelayer   *VerificationCommercelayer
	Hubspot         *VerificationHubspot
	Mailgun         *VerificationMailgun
	Persona         *VerificationPersona
	Pipedrive       *VerificationPipedrive
	Sendgrid        *VerificationSendGrid
	Workos          *VerificationWorkOs
	Synctera        *VerificationSynctera
	AwsSns          *VerificationAwssns
	ThreeDEye       *Verification3DEye
	Twitch          *VerificationTwitch
	Enode           *VerificationEnode
	Favro           *VerificationFavro
	Linear          *VerificationLinear
	Shopline        *VerificationShopline
	Wix             *VerificationWix
	Nmi             *VerificationNmiPaymentGateway
	Orb             *VerificationOrb
	Pylon           *VerificationPylon
	Repay           *VerificationRepay
	Square          *VerificationSquare
	Solidgate       *VerificationSolidGate
	Trello          *VerificationTrello
	Sanity          *VerificationSanity
	Ebay            *VerificationEbay
	Telnyx          *VerificationTelnyx
	Discord         *VerificationDiscord
	Tokenio         *VerificationTokenIo
	Fiserv          *VerificationFiserv
	Bondsmith       *VerificationBondsmith
	VercelLogDrains *VerificationVercelLogDrains
	Vercel          *VerificationVercel
	Tebex           *VerificationTebex
	Slack           *VerificationSlack
	Razorpay        *VerificationRazorpay
}

func NewVerificationConfigFromHmac(value *VerificationHmac) *VerificationConfig {
	return &VerificationConfig{Type: "hmac", Hmac: value}
}

func NewVerificationConfigFromBasicAuth(value *VerificationBasicAuth) *VerificationConfig {
	return &VerificationConfig{Type: "basic_auth", BasicAuth: value}
}

func NewVerificationConfigFromApiKey(value *VerificationApiKey) *VerificationConfig {
	return &VerificationConfig{Type: "api_key", ApiKey: value}
}

func NewVerificationConfigFromCloudsignal(value *VerificationCloudSignal) *VerificationConfig {
	return &VerificationConfig{Type: "cloudsignal", Cloudsignal: value}
}

func NewVerificationConfigFromCourier(value *VerificationCourier) *VerificationConfig {
	return &VerificationConfig{Type: "courier", Courier: value}
}

func NewVerificationConfigFromFrontapp(value *VerificationFrontApp) *VerificationConfig {
	return &VerificationConfig{Type: "frontapp", Frontapp: value}
}

func NewVerificationConfigFromTwitter(value *VerificationTwitter) *VerificationConfig {
	return &VerificationConfig{Type: "twitter", Twitter: value}
}

func NewVerificationConfigFromStripe(value *VerificationStripe) *VerificationConfig {
	return &VerificationConfig{Type: "stripe", Stripe: value}
}

func NewVerificationConfigFromRecharge(value *VerificationRecharge) *VerificationConfig {
	return &VerificationConfig{Type: "recharge", Recharge: value}
}

func NewVerificationConfigFromTwilio(value *VerificationTwilio) *VerificationConfig {
	return &VerificationConfig{Type: "twilio", Twilio: value}
}

func NewVerificationConfigFromGithub(value *VerificationGitHub) *VerificationConfig {
	return &VerificationConfig{Type: "github", Github: value}
}

func NewVerificationConfigFromShopify(value *VerificationShopify) *VerificationConfig {
	return &VerificationConfig{Type: "shopify", Shopify: value}
}

func NewVerificationConfigFromPostmark(value *VerificationPostmark) *VerificationConfig {
	return &VerificationConfig{Type: "postmark", Postmark: value}
}

func NewVerificationConfigFromTypeform(value *VerificationTypeform) *VerificationConfig {
	return &VerificationConfig{Type: "typeform", Typeform: value}
}

func NewVerificationConfigFromXero(value *VerificationXero) *VerificationConfig {
	return &VerificationConfig{Type: "xero", Xero: value}
}

func NewVerificationConfigFromSvix(value *VerificationSvix) *VerificationConfig {
	return &VerificationConfig{Type: "svix", Svix: value}
}

func NewVerificationConfigFromZoom(value *VerificationZoom) *VerificationConfig {
	return &VerificationConfig{Type: "zoom", Zoom: value}
}

func NewVerificationConfigFromAkeneo(value *VerificationAkeneo) *VerificationConfig {
	return &VerificationConfig{Type: "akeneo", Akeneo: value}
}

func NewVerificationConfigFromAdyen(value *VerificationAdyen) *VerificationConfig {
	return &VerificationConfig{Type: "adyen", Adyen: value}
}

func NewVerificationConfigFromGitlab(value *VerificationGitLab) *VerificationConfig {
	return &VerificationConfig{Type: "gitlab", Gitlab: value}
}

func NewVerificationConfigFromPropertyFinder(value *VerificationPropertyFinder) *VerificationConfig {
	return &VerificationConfig{Type: "property-finder", PropertyFinder: value}
}

func NewVerificationConfigFromWoocommerce(value *VerificationWooCommerce) *VerificationConfig {
	return &VerificationConfig{Type: "woocommerce", Woocommerce: value}
}

func NewVerificationConfigFromOura(value *VerificationOura) *VerificationConfig {
	return &VerificationConfig{Type: "oura", Oura: value}
}

func NewVerificationConfigFromCommercelayer(value *VerificationCommercelayer) *VerificationConfig {
	return &VerificationConfig{Type: "commercelayer", Commercelayer: value}
}

func NewVerificationConfigFromHubspot(value *VerificationHubspot) *VerificationConfig {
	return &VerificationConfig{Type: "hubspot", Hubspot: value}
}

func NewVerificationConfigFromMailgun(value *VerificationMailgun) *VerificationConfig {
	return &VerificationConfig{Type: "mailgun", Mailgun: value}
}

func NewVerificationConfigFromPersona(value *VerificationPersona) *VerificationConfig {
	return &VerificationConfig{Type: "persona", Persona: value}
}

func NewVerificationConfigFromPipedrive(value *VerificationPipedrive) *VerificationConfig {
	return &VerificationConfig{Type: "pipedrive", Pipedrive: value}
}

func NewVerificationConfigFromSendgrid(value *VerificationSendGrid) *VerificationConfig {
	return &VerificationConfig{Type: "sendgrid", Sendgrid: value}
}

func NewVerificationConfigFromWorkos(value *VerificationWorkOs) *VerificationConfig {
	return &VerificationConfig{Type: "workos", Workos: value}
}

func NewVerificationConfigFromSynctera(value *VerificationSynctera) *VerificationConfig {
	return &VerificationConfig{Type: "synctera", Synctera: value}
}

func NewVerificationConfigFromAwsSns(value *VerificationAwssns) *VerificationConfig {
	return &VerificationConfig{Type: "aws_sns", AwsSns: value}
}

func NewVerificationConfigFromThreeDEye(value *Verification3DEye) *VerificationConfig {
	return &VerificationConfig{Type: "three_d_eye", ThreeDEye: value}
}

func NewVerificationConfigFromTwitch(value *VerificationTwitch) *VerificationConfig {
	return &VerificationConfig{Type: "twitch", Twitch: value}
}

func NewVerificationConfigFromEnode(value *VerificationEnode) *VerificationConfig {
	return &VerificationConfig{Type: "enode", Enode: value}
}

func NewVerificationConfigFromFavro(value *VerificationFavro) *VerificationConfig {
	return &VerificationConfig{Type: "favro", Favro: value}
}

func NewVerificationConfigFromLinear(value *VerificationLinear) *VerificationConfig {
	return &VerificationConfig{Type: "linear", Linear: value}
}

func NewVerificationConfigFromShopline(value *VerificationShopline) *VerificationConfig {
	return &VerificationConfig{Type: "shopline", Shopline: value}
}

func NewVerificationConfigFromWix(value *VerificationWix) *VerificationConfig {
	return &VerificationConfig{Type: "wix", Wix: value}
}

func NewVerificationConfigFromNmi(value *VerificationNmiPaymentGateway) *VerificationConfig {
	return &VerificationConfig{Type: "nmi", Nmi: value}
}

func NewVerificationConfigFromOrb(value *VerificationOrb) *VerificationConfig {
	return &VerificationConfig{Type: "orb", Orb: value}
}

func NewVerificationConfigFromPylon(value *VerificationPylon) *VerificationConfig {
	return &VerificationConfig{Type: "pylon", Pylon: value}
}

func NewVerificationConfigFromRepay(value *VerificationRepay) *VerificationConfig {
	return &VerificationConfig{Type: "repay", Repay: value}
}

func NewVerificationConfigFromSquare(value *VerificationSquare) *VerificationConfig {
	return &VerificationConfig{Type: "square", Square: value}
}

func NewVerificationConfigFromSolidgate(value *VerificationSolidGate) *VerificationConfig {
	return &VerificationConfig{Type: "solidgate", Solidgate: value}
}

func NewVerificationConfigFromTrello(value *VerificationTrello) *VerificationConfig {
	return &VerificationConfig{Type: "trello", Trello: value}
}

func NewVerificationConfigFromSanity(value *VerificationSanity) *VerificationConfig {
	return &VerificationConfig{Type: "sanity", Sanity: value}
}

func NewVerificationConfigFromEbay(value *VerificationEbay) *VerificationConfig {
	return &VerificationConfig{Type: "ebay", Ebay: value}
}

func NewVerificationConfigFromTelnyx(value *VerificationTelnyx) *VerificationConfig {
	return &VerificationConfig{Type: "telnyx", Telnyx: value}
}

func NewVerificationConfigFromDiscord(value *VerificationDiscord) *VerificationConfig {
	return &VerificationConfig{Type: "discord", Discord: value}
}

func NewVerificationConfigFromTokenio(value *VerificationTokenIo) *VerificationConfig {
	return &VerificationConfig{Type: "tokenio", Tokenio: value}
}

func NewVerificationConfigFromFiserv(value *VerificationFiserv) *VerificationConfig {
	return &VerificationConfig{Type: "fiserv", Fiserv: value}
}

func NewVerificationConfigFromBondsmith(value *VerificationBondsmith) *VerificationConfig {
	return &VerificationConfig{Type: "bondsmith", Bondsmith: value}
}

func NewVerificationConfigFromVercelLogDrains(value *VerificationVercelLogDrains) *VerificationConfig {
	return &VerificationConfig{Type: "vercel_log_drains", VercelLogDrains: value}
}

func NewVerificationConfigFromVercel(value *VerificationVercel) *VerificationConfig {
	return &VerificationConfig{Type: "vercel", Vercel: value}
}

func NewVerificationConfigFromTebex(value *VerificationTebex) *VerificationConfig {
	return &VerificationConfig{Type: "tebex", Tebex: value}
}

func NewVerificationConfigFromSlack(value *VerificationSlack) *VerificationConfig {
	return &VerificationConfig{Type: "slack", Slack: value}
}

func NewVerificationConfigFromRazorpay(value *VerificationRazorpay) *VerificationConfig {
	return &VerificationConfig{Type: "razorpay", Razorpay: value}
}

func (v *VerificationConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	v.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "hmac":
		value := new(VerificationHmac)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Hmac = value
	case "basic_auth":
		value := new(VerificationBasicAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.BasicAuth = value
	case "api_key":
		value := new(VerificationApiKey)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ApiKey = value
	case "cloudsignal":
		value := new(VerificationCloudSignal)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Cloudsignal = value
	case "courier":
		value := new(VerificationCourier)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Courier = value
	case "frontapp":
		value := new(VerificationFrontApp)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Frontapp = value
	case "twitter":
		value := new(VerificationTwitter)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Twitter = value
	case "stripe":
		value := new(VerificationStripe)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Stripe = value
	case "recharge":
		value := new(VerificationRecharge)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Recharge = value
	case "twilio":
		value := new(VerificationTwilio)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Twilio = value
	case "github":
		value := new(VerificationGitHub)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Github = value
	case "shopify":
		value := new(VerificationShopify)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Shopify = value
	case "postmark":
		value := new(VerificationPostmark)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Postmark = value
	case "typeform":
		value := new(VerificationTypeform)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Typeform = value
	case "xero":
		value := new(VerificationXero)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Xero = value
	case "svix":
		value := new(VerificationSvix)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Svix = value
	case "zoom":
		value := new(VerificationZoom)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Zoom = value
	case "akeneo":
		value := new(VerificationAkeneo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Akeneo = value
	case "adyen":
		value := new(VerificationAdyen)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Adyen = value
	case "gitlab":
		value := new(VerificationGitLab)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Gitlab = value
	case "property-finder":
		value := new(VerificationPropertyFinder)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.PropertyFinder = value
	case "woocommerce":
		value := new(VerificationWooCommerce)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Woocommerce = value
	case "oura":
		value := new(VerificationOura)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Oura = value
	case "commercelayer":
		value := new(VerificationCommercelayer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Commercelayer = value
	case "hubspot":
		value := new(VerificationHubspot)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Hubspot = value
	case "mailgun":
		value := new(VerificationMailgun)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Mailgun = value
	case "persona":
		value := new(VerificationPersona)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Persona = value
	case "pipedrive":
		value := new(VerificationPipedrive)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Pipedrive = value
	case "sendgrid":
		value := new(VerificationSendGrid)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Sendgrid = value
	case "workos":
		value := new(VerificationWorkOs)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Workos = value
	case "synctera":
		value := new(VerificationSynctera)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Synctera = value
	case "aws_sns":
		value := new(VerificationAwssns)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.AwsSns = value
	case "three_d_eye":
		value := new(Verification3DEye)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ThreeDEye = value
	case "twitch":
		value := new(VerificationTwitch)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Twitch = value
	case "enode":
		value := new(VerificationEnode)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Enode = value
	case "favro":
		value := new(VerificationFavro)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Favro = value
	case "linear":
		value := new(VerificationLinear)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Linear = value
	case "shopline":
		value := new(VerificationShopline)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Shopline = value
	case "wix":
		value := new(VerificationWix)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Wix = value
	case "nmi":
		value := new(VerificationNmiPaymentGateway)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Nmi = value
	case "orb":
		value := new(VerificationOrb)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Orb = value
	case "pylon":
		value := new(VerificationPylon)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Pylon = value
	case "repay":
		value := new(VerificationRepay)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Repay = value
	case "square":
		value := new(VerificationSquare)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Square = value
	case "solidgate":
		value := new(VerificationSolidGate)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Solidgate = value
	case "trello":
		value := new(VerificationTrello)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Trello = value
	case "sanity":
		value := new(VerificationSanity)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Sanity = value
	case "ebay":
		value := new(VerificationEbay)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Ebay = value
	case "telnyx":
		value := new(VerificationTelnyx)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Telnyx = value
	case "discord":
		value := new(VerificationDiscord)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Discord = value
	case "tokenio":
		value := new(VerificationTokenIo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Tokenio = value
	case "fiserv":
		value := new(VerificationFiserv)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Fiserv = value
	case "bondsmith":
		value := new(VerificationBondsmith)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Bondsmith = value
	case "vercel_log_drains":
		value := new(VerificationVercelLogDrains)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.VercelLogDrains = value
	case "vercel":
		value := new(VerificationVercel)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Vercel = value
	case "tebex":
		value := new(VerificationTebex)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Tebex = value
	case "slack":
		value := new(VerificationSlack)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Slack = value
	case "razorpay":
		value := new(VerificationRazorpay)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Razorpay = value
	}
	return nil
}

func (v VerificationConfig) MarshalJSON() ([]byte, error) {
	switch v.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.Type, v)
	case "hmac":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationHmac
		}{
			Type:             v.Type,
			VerificationHmac: v.Hmac,
		}
		return json.Marshal(marshaler)
	case "basic_auth":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationBasicAuth
		}{
			Type:                  v.Type,
			VerificationBasicAuth: v.BasicAuth,
		}
		return json.Marshal(marshaler)
	case "api_key":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationApiKey
		}{
			Type:               v.Type,
			VerificationApiKey: v.ApiKey,
		}
		return json.Marshal(marshaler)
	case "cloudsignal":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationCloudSignal
		}{
			Type:                    v.Type,
			VerificationCloudSignal: v.Cloudsignal,
		}
		return json.Marshal(marshaler)
	case "courier":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationCourier
		}{
			Type:                v.Type,
			VerificationCourier: v.Courier,
		}
		return json.Marshal(marshaler)
	case "frontapp":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationFrontApp
		}{
			Type:                 v.Type,
			VerificationFrontApp: v.Frontapp,
		}
		return json.Marshal(marshaler)
	case "twitter":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationTwitter
		}{
			Type:                v.Type,
			VerificationTwitter: v.Twitter,
		}
		return json.Marshal(marshaler)
	case "stripe":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationStripe
		}{
			Type:               v.Type,
			VerificationStripe: v.Stripe,
		}
		return json.Marshal(marshaler)
	case "recharge":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationRecharge
		}{
			Type:                 v.Type,
			VerificationRecharge: v.Recharge,
		}
		return json.Marshal(marshaler)
	case "twilio":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationTwilio
		}{
			Type:               v.Type,
			VerificationTwilio: v.Twilio,
		}
		return json.Marshal(marshaler)
	case "github":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationGitHub
		}{
			Type:               v.Type,
			VerificationGitHub: v.Github,
		}
		return json.Marshal(marshaler)
	case "shopify":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationShopify
		}{
			Type:                v.Type,
			VerificationShopify: v.Shopify,
		}
		return json.Marshal(marshaler)
	case "postmark":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationPostmark
		}{
			Type:                 v.Type,
			VerificationPostmark: v.Postmark,
		}
		return json.Marshal(marshaler)
	case "typeform":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationTypeform
		}{
			Type:                 v.Type,
			VerificationTypeform: v.Typeform,
		}
		return json.Marshal(marshaler)
	case "xero":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationXero
		}{
			Type:             v.Type,
			VerificationXero: v.Xero,
		}
		return json.Marshal(marshaler)
	case "svix":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationSvix
		}{
			Type:             v.Type,
			VerificationSvix: v.Svix,
		}
		return json.Marshal(marshaler)
	case "zoom":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationZoom
		}{
			Type:             v.Type,
			VerificationZoom: v.Zoom,
		}
		return json.Marshal(marshaler)
	case "akeneo":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationAkeneo
		}{
			Type:               v.Type,
			VerificationAkeneo: v.Akeneo,
		}
		return json.Marshal(marshaler)
	case "adyen":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationAdyen
		}{
			Type:              v.Type,
			VerificationAdyen: v.Adyen,
		}
		return json.Marshal(marshaler)
	case "gitlab":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationGitLab
		}{
			Type:               v.Type,
			VerificationGitLab: v.Gitlab,
		}
		return json.Marshal(marshaler)
	case "property-finder":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationPropertyFinder
		}{
			Type:                       v.Type,
			VerificationPropertyFinder: v.PropertyFinder,
		}
		return json.Marshal(marshaler)
	case "woocommerce":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationWooCommerce
		}{
			Type:                    v.Type,
			VerificationWooCommerce: v.Woocommerce,
		}
		return json.Marshal(marshaler)
	case "oura":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationOura
		}{
			Type:             v.Type,
			VerificationOura: v.Oura,
		}
		return json.Marshal(marshaler)
	case "commercelayer":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationCommercelayer
		}{
			Type:                      v.Type,
			VerificationCommercelayer: v.Commercelayer,
		}
		return json.Marshal(marshaler)
	case "hubspot":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationHubspot
		}{
			Type:                v.Type,
			VerificationHubspot: v.Hubspot,
		}
		return json.Marshal(marshaler)
	case "mailgun":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationMailgun
		}{
			Type:                v.Type,
			VerificationMailgun: v.Mailgun,
		}
		return json.Marshal(marshaler)
	case "persona":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationPersona
		}{
			Type:                v.Type,
			VerificationPersona: v.Persona,
		}
		return json.Marshal(marshaler)
	case "pipedrive":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationPipedrive
		}{
			Type:                  v.Type,
			VerificationPipedrive: v.Pipedrive,
		}
		return json.Marshal(marshaler)
	case "sendgrid":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationSendGrid
		}{
			Type:                 v.Type,
			VerificationSendGrid: v.Sendgrid,
		}
		return json.Marshal(marshaler)
	case "workos":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationWorkOs
		}{
			Type:               v.Type,
			VerificationWorkOs: v.Workos,
		}
		return json.Marshal(marshaler)
	case "synctera":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationSynctera
		}{
			Type:                 v.Type,
			VerificationSynctera: v.Synctera,
		}
		return json.Marshal(marshaler)
	case "aws_sns":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationAwssns
		}{
			Type:               v.Type,
			VerificationAwssns: v.AwsSns,
		}
		return json.Marshal(marshaler)
	case "three_d_eye":
		var marshaler = struct {
			Type string `json:"type"`
			*Verification3DEye
		}{
			Type:              v.Type,
			Verification3DEye: v.ThreeDEye,
		}
		return json.Marshal(marshaler)
	case "twitch":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationTwitch
		}{
			Type:               v.Type,
			VerificationTwitch: v.Twitch,
		}
		return json.Marshal(marshaler)
	case "enode":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationEnode
		}{
			Type:              v.Type,
			VerificationEnode: v.Enode,
		}
		return json.Marshal(marshaler)
	case "favro":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationFavro
		}{
			Type:              v.Type,
			VerificationFavro: v.Favro,
		}
		return json.Marshal(marshaler)
	case "linear":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationLinear
		}{
			Type:               v.Type,
			VerificationLinear: v.Linear,
		}
		return json.Marshal(marshaler)
	case "shopline":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationShopline
		}{
			Type:                 v.Type,
			VerificationShopline: v.Shopline,
		}
		return json.Marshal(marshaler)
	case "wix":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationWix
		}{
			Type:            v.Type,
			VerificationWix: v.Wix,
		}
		return json.Marshal(marshaler)
	case "nmi":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationNmiPaymentGateway
		}{
			Type:                          v.Type,
			VerificationNmiPaymentGateway: v.Nmi,
		}
		return json.Marshal(marshaler)
	case "orb":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationOrb
		}{
			Type:            v.Type,
			VerificationOrb: v.Orb,
		}
		return json.Marshal(marshaler)
	case "pylon":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationPylon
		}{
			Type:              v.Type,
			VerificationPylon: v.Pylon,
		}
		return json.Marshal(marshaler)
	case "repay":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationRepay
		}{
			Type:              v.Type,
			VerificationRepay: v.Repay,
		}
		return json.Marshal(marshaler)
	case "square":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationSquare
		}{
			Type:               v.Type,
			VerificationSquare: v.Square,
		}
		return json.Marshal(marshaler)
	case "solidgate":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationSolidGate
		}{
			Type:                  v.Type,
			VerificationSolidGate: v.Solidgate,
		}
		return json.Marshal(marshaler)
	case "trello":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationTrello
		}{
			Type:               v.Type,
			VerificationTrello: v.Trello,
		}
		return json.Marshal(marshaler)
	case "sanity":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationSanity
		}{
			Type:               v.Type,
			VerificationSanity: v.Sanity,
		}
		return json.Marshal(marshaler)
	case "ebay":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationEbay
		}{
			Type:             v.Type,
			VerificationEbay: v.Ebay,
		}
		return json.Marshal(marshaler)
	case "telnyx":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationTelnyx
		}{
			Type:               v.Type,
			VerificationTelnyx: v.Telnyx,
		}
		return json.Marshal(marshaler)
	case "discord":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationDiscord
		}{
			Type:                v.Type,
			VerificationDiscord: v.Discord,
		}
		return json.Marshal(marshaler)
	case "tokenio":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationTokenIo
		}{
			Type:                v.Type,
			VerificationTokenIo: v.Tokenio,
		}
		return json.Marshal(marshaler)
	case "fiserv":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationFiserv
		}{
			Type:               v.Type,
			VerificationFiserv: v.Fiserv,
		}
		return json.Marshal(marshaler)
	case "bondsmith":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationBondsmith
		}{
			Type:                  v.Type,
			VerificationBondsmith: v.Bondsmith,
		}
		return json.Marshal(marshaler)
	case "vercel_log_drains":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationVercelLogDrains
		}{
			Type:                        v.Type,
			VerificationVercelLogDrains: v.VercelLogDrains,
		}
		return json.Marshal(marshaler)
	case "vercel":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationVercel
		}{
			Type:               v.Type,
			VerificationVercel: v.Vercel,
		}
		return json.Marshal(marshaler)
	case "tebex":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationTebex
		}{
			Type:              v.Type,
			VerificationTebex: v.Tebex,
		}
		return json.Marshal(marshaler)
	case "slack":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationSlack
		}{
			Type:              v.Type,
			VerificationSlack: v.Slack,
		}
		return json.Marshal(marshaler)
	case "razorpay":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationRazorpay
		}{
			Type:                 v.Type,
			VerificationRazorpay: v.Razorpay,
		}
		return json.Marshal(marshaler)
	}
}

type VerificationConfigVisitor interface {
	VisitHmac(*VerificationHmac) error
	VisitBasicAuth(*VerificationBasicAuth) error
	VisitApiKey(*VerificationApiKey) error
	VisitCloudsignal(*VerificationCloudSignal) error
	VisitCourier(*VerificationCourier) error
	VisitFrontapp(*VerificationFrontApp) error
	VisitTwitter(*VerificationTwitter) error
	VisitStripe(*VerificationStripe) error
	VisitRecharge(*VerificationRecharge) error
	VisitTwilio(*VerificationTwilio) error
	VisitGithub(*VerificationGitHub) error
	VisitShopify(*VerificationShopify) error
	VisitPostmark(*VerificationPostmark) error
	VisitTypeform(*VerificationTypeform) error
	VisitXero(*VerificationXero) error
	VisitSvix(*VerificationSvix) error
	VisitZoom(*VerificationZoom) error
	VisitAkeneo(*VerificationAkeneo) error
	VisitAdyen(*VerificationAdyen) error
	VisitGitlab(*VerificationGitLab) error
	VisitPropertyFinder(*VerificationPropertyFinder) error
	VisitWoocommerce(*VerificationWooCommerce) error
	VisitOura(*VerificationOura) error
	VisitCommercelayer(*VerificationCommercelayer) error
	VisitHubspot(*VerificationHubspot) error
	VisitMailgun(*VerificationMailgun) error
	VisitPersona(*VerificationPersona) error
	VisitPipedrive(*VerificationPipedrive) error
	VisitSendgrid(*VerificationSendGrid) error
	VisitWorkos(*VerificationWorkOs) error
	VisitSynctera(*VerificationSynctera) error
	VisitAwsSns(*VerificationAwssns) error
	VisitThreeDEye(*Verification3DEye) error
	VisitTwitch(*VerificationTwitch) error
	VisitEnode(*VerificationEnode) error
	VisitFavro(*VerificationFavro) error
	VisitLinear(*VerificationLinear) error
	VisitShopline(*VerificationShopline) error
	VisitWix(*VerificationWix) error
	VisitNmi(*VerificationNmiPaymentGateway) error
	VisitOrb(*VerificationOrb) error
	VisitPylon(*VerificationPylon) error
	VisitRepay(*VerificationRepay) error
	VisitSquare(*VerificationSquare) error
	VisitSolidgate(*VerificationSolidGate) error
	VisitTrello(*VerificationTrello) error
	VisitSanity(*VerificationSanity) error
	VisitEbay(*VerificationEbay) error
	VisitTelnyx(*VerificationTelnyx) error
	VisitDiscord(*VerificationDiscord) error
	VisitTokenio(*VerificationTokenIo) error
	VisitFiserv(*VerificationFiserv) error
	VisitBondsmith(*VerificationBondsmith) error
	VisitVercelLogDrains(*VerificationVercelLogDrains) error
	VisitVercel(*VerificationVercel) error
	VisitTebex(*VerificationTebex) error
	VisitSlack(*VerificationSlack) error
	VisitRazorpay(*VerificationRazorpay) error
}

func (v *VerificationConfig) Accept(visitor VerificationConfigVisitor) error {
	switch v.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", v.Type, v)
	case "hmac":
		return visitor.VisitHmac(v.Hmac)
	case "basic_auth":
		return visitor.VisitBasicAuth(v.BasicAuth)
	case "api_key":
		return visitor.VisitApiKey(v.ApiKey)
	case "cloudsignal":
		return visitor.VisitCloudsignal(v.Cloudsignal)
	case "courier":
		return visitor.VisitCourier(v.Courier)
	case "frontapp":
		return visitor.VisitFrontapp(v.Frontapp)
	case "twitter":
		return visitor.VisitTwitter(v.Twitter)
	case "stripe":
		return visitor.VisitStripe(v.Stripe)
	case "recharge":
		return visitor.VisitRecharge(v.Recharge)
	case "twilio":
		return visitor.VisitTwilio(v.Twilio)
	case "github":
		return visitor.VisitGithub(v.Github)
	case "shopify":
		return visitor.VisitShopify(v.Shopify)
	case "postmark":
		return visitor.VisitPostmark(v.Postmark)
	case "typeform":
		return visitor.VisitTypeform(v.Typeform)
	case "xero":
		return visitor.VisitXero(v.Xero)
	case "svix":
		return visitor.VisitSvix(v.Svix)
	case "zoom":
		return visitor.VisitZoom(v.Zoom)
	case "akeneo":
		return visitor.VisitAkeneo(v.Akeneo)
	case "adyen":
		return visitor.VisitAdyen(v.Adyen)
	case "gitlab":
		return visitor.VisitGitlab(v.Gitlab)
	case "property-finder":
		return visitor.VisitPropertyFinder(v.PropertyFinder)
	case "woocommerce":
		return visitor.VisitWoocommerce(v.Woocommerce)
	case "oura":
		return visitor.VisitOura(v.Oura)
	case "commercelayer":
		return visitor.VisitCommercelayer(v.Commercelayer)
	case "hubspot":
		return visitor.VisitHubspot(v.Hubspot)
	case "mailgun":
		return visitor.VisitMailgun(v.Mailgun)
	case "persona":
		return visitor.VisitPersona(v.Persona)
	case "pipedrive":
		return visitor.VisitPipedrive(v.Pipedrive)
	case "sendgrid":
		return visitor.VisitSendgrid(v.Sendgrid)
	case "workos":
		return visitor.VisitWorkos(v.Workos)
	case "synctera":
		return visitor.VisitSynctera(v.Synctera)
	case "aws_sns":
		return visitor.VisitAwsSns(v.AwsSns)
	case "three_d_eye":
		return visitor.VisitThreeDEye(v.ThreeDEye)
	case "twitch":
		return visitor.VisitTwitch(v.Twitch)
	case "enode":
		return visitor.VisitEnode(v.Enode)
	case "favro":
		return visitor.VisitFavro(v.Favro)
	case "linear":
		return visitor.VisitLinear(v.Linear)
	case "shopline":
		return visitor.VisitShopline(v.Shopline)
	case "wix":
		return visitor.VisitWix(v.Wix)
	case "nmi":
		return visitor.VisitNmi(v.Nmi)
	case "orb":
		return visitor.VisitOrb(v.Orb)
	case "pylon":
		return visitor.VisitPylon(v.Pylon)
	case "repay":
		return visitor.VisitRepay(v.Repay)
	case "square":
		return visitor.VisitSquare(v.Square)
	case "solidgate":
		return visitor.VisitSolidgate(v.Solidgate)
	case "trello":
		return visitor.VisitTrello(v.Trello)
	case "sanity":
		return visitor.VisitSanity(v.Sanity)
	case "ebay":
		return visitor.VisitEbay(v.Ebay)
	case "telnyx":
		return visitor.VisitTelnyx(v.Telnyx)
	case "discord":
		return visitor.VisitDiscord(v.Discord)
	case "tokenio":
		return visitor.VisitTokenio(v.Tokenio)
	case "fiserv":
		return visitor.VisitFiserv(v.Fiserv)
	case "bondsmith":
		return visitor.VisitBondsmith(v.Bondsmith)
	case "vercel_log_drains":
		return visitor.VisitVercelLogDrains(v.VercelLogDrains)
	case "vercel":
		return visitor.VisitVercel(v.Vercel)
	case "tebex":
		return visitor.VisitTebex(v.Tebex)
	case "slack":
		return visitor.VisitSlack(v.Slack)
	case "razorpay":
		return visitor.VisitRazorpay(v.Razorpay)
	}
}

type VerificationCourier struct {
	Configs *VerificationCourierConfigs `json:"configs,omitempty"`
}

// The verification configs for Courier. Only included if the ?include=verification.configs query param is present
type VerificationCourierConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationDiscord struct {
	Configs *VerificationDiscordConfigs `json:"configs,omitempty"`
}

// The verification configs for Discord. Only included if the ?include=verification.configs query param is present
type VerificationDiscordConfigs struct {
	PublicKey string `json:"public_key"`
}

type VerificationEbay struct {
	Configs *VerificationEbayConfigs `json:"configs,omitempty"`
}

// The verification configs for Ebay. Only included if the ?include=verification.configs query param is present
type VerificationEbayConfigs struct {
	Environment       string `json:"environment"`
	ClientId          string `json:"client_id"`
	ClientSecret      string `json:"client_secret"`
	DevId             string `json:"dev_id"`
	VerificationToken string `json:"verification_token"`
}

type VerificationEnode struct {
	Configs *VerificationEnodeConfigs `json:"configs,omitempty"`
}

// The verification configs for Enode. Only included if the ?include=verification.configs query param is present
type VerificationEnodeConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationFavro struct {
	Configs *VerificationFavroConfigs `json:"configs,omitempty"`
}

// The verification configs for Favro. Only included if the ?include=verification.configs query param is present
type VerificationFavroConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationFiserv struct {
	Configs *VerificationFiservConfigs `json:"configs,omitempty"`
}

// The verification configs for Fiserv. Only included if the ?include=verification.configs query param is present
type VerificationFiservConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationFrontApp struct {
	Configs *VerificationFrontAppConfigs `json:"configs,omitempty"`
}

// The verification configs for FrontApp. Only included if the ?include=verification.configs query param is present
type VerificationFrontAppConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationGitHub struct {
	Configs *VerificationGitHubConfigs `json:"configs,omitempty"`
}

// The verification configs for GitHub. Only included if the ?include=verification.configs query param is present
type VerificationGitHubConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationGitLab struct {
	Configs *VerificationGitLabConfigs `json:"configs,omitempty"`
}

// The verification configs for GitLab. Only included if the ?include=verification.configs query param is present
type VerificationGitLabConfigs struct {
	ApiKey string `json:"api_key"`
}

type VerificationHmac struct {
	Configs *VerificationHmacConfigs `json:"configs,omitempty"`
}

// The verification configs for HMAC. Only included if the ?include=verification.configs query param is present
type VerificationHmacConfigs struct {
	WebhookSecretKey string                          `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms                  `json:"algorithm,omitempty"`
	HeaderKey        string                          `json:"header_key"`
	Encoding         VerificationHmacConfigsEncoding `json:"encoding,omitempty"`
}

type VerificationHmacConfigsEncoding string

const (
	VerificationHmacConfigsEncodingBase64    VerificationHmacConfigsEncoding = "base64"
	VerificationHmacConfigsEncodingBase64Url VerificationHmacConfigsEncoding = "base64url"
	VerificationHmacConfigsEncodingHex       VerificationHmacConfigsEncoding = "hex"
)

func NewVerificationHmacConfigsEncodingFromString(s string) (VerificationHmacConfigsEncoding, error) {
	switch s {
	case "base64":
		return VerificationHmacConfigsEncodingBase64, nil
	case "base64url":
		return VerificationHmacConfigsEncodingBase64Url, nil
	case "hex":
		return VerificationHmacConfigsEncodingHex, nil
	}
	var t VerificationHmacConfigsEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationHmacConfigsEncoding) Ptr() *VerificationHmacConfigsEncoding {
	return &v
}

type VerificationHubspot struct {
	Configs *VerificationHubspotConfigs `json:"configs,omitempty"`
}

// The verification configs for Hubspot. Only included if the ?include=verification.configs query param is present
type VerificationHubspotConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationLinear struct {
	Configs *VerificationLinearConfigs `json:"configs,omitempty"`
}

// The verification configs for Linear. Only included if the ?include=verification.configs query param is present
type VerificationLinearConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationMailgun struct {
	Configs *VerificationMailgunConfigs `json:"configs,omitempty"`
}

// The verification configs for Mailgun. Only included if the ?include=verification.configs query param is present
type VerificationMailgunConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationNmiPaymentGateway struct {
	Configs *VerificationNmiPaymentGatewayConfigs `json:"configs,omitempty"`
}

// The verification configs for NMI Payment Gateway. Only included if the ?include=verification.configs query param is present
type VerificationNmiPaymentGatewayConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationOrb struct {
	Configs *VerificationOrbConfigs `json:"configs,omitempty"`
}

// The verification configs for Orb. Only included if the ?include=verification.configs query param is present
type VerificationOrbConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationOura struct {
	Configs *VerificationOuraConfigs `json:"configs,omitempty"`
}

// The verification configs for Oura. Only included if the ?include=verification.configs query param is present
type VerificationOuraConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationPersona struct {
	Configs *VerificationPersonaConfigs `json:"configs,omitempty"`
}

// The verification configs for Persona. Only included if the ?include=verification.configs query param is present
type VerificationPersonaConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationPipedrive struct {
	Configs *VerificationPipedriveConfigs `json:"configs,omitempty"`
}

// The verification configs for Pipedrive. Only included if the ?include=verification.configs query param is present
type VerificationPipedriveConfigs struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type VerificationPostmark struct {
	Configs *VerificationPostmarkConfigs `json:"configs,omitempty"`
}

// The verification configs for Postmark. Only included if the ?include=verification.configs query param is present
type VerificationPostmarkConfigs struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

type VerificationPropertyFinder struct {
	Configs *VerificationPropertyFinderConfigs `json:"configs,omitempty"`
}

// The verification configs for Property Finder. Only included if the ?include=verification.configs query param is present
type VerificationPropertyFinderConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationPylon struct {
	Configs *VerificationPylonConfigs `json:"configs,omitempty"`
}

// The verification configs for Pylon. Only included if the ?include=verification.configs query param is present
type VerificationPylonConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationRazorpay struct {
	Configs *VerificationRazorpayConfigs `json:"configs,omitempty"`
}

// The verification configs for Razorpay. Only included if the ?include=verification.configs query param is present
type VerificationRazorpayConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationRecharge struct {
	Configs *VerificationRechargeConfigs `json:"configs,omitempty"`
}

// The verification configs for Recharge. Only included if the ?include=verification.configs query param is present
type VerificationRechargeConfigs struct {
	WebhookSecretKey string                              `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms                      `json:"algorithm,omitempty"`
	HeaderKey        string                              `json:"header_key"`
	Encoding         VerificationRechargeConfigsEncoding `json:"encoding,omitempty"`
}

type VerificationRechargeConfigsEncoding string

const (
	VerificationRechargeConfigsEncodingBase64    VerificationRechargeConfigsEncoding = "base64"
	VerificationRechargeConfigsEncodingBase64Url VerificationRechargeConfigsEncoding = "base64url"
	VerificationRechargeConfigsEncodingHex       VerificationRechargeConfigsEncoding = "hex"
)

func NewVerificationRechargeConfigsEncodingFromString(s string) (VerificationRechargeConfigsEncoding, error) {
	switch s {
	case "base64":
		return VerificationRechargeConfigsEncodingBase64, nil
	case "base64url":
		return VerificationRechargeConfigsEncodingBase64Url, nil
	case "hex":
		return VerificationRechargeConfigsEncodingHex, nil
	}
	var t VerificationRechargeConfigsEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationRechargeConfigsEncoding) Ptr() *VerificationRechargeConfigsEncoding {
	return &v
}

type VerificationRepay struct {
	Configs *VerificationRepayConfigs `json:"configs,omitempty"`
}

// The verification configs for Repay. Only included if the ?include=verification.configs query param is present
type VerificationRepayConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSanity struct {
	Configs *VerificationSanityConfigs `json:"configs,omitempty"`
}

// The verification configs for Sanity. Only included if the ?include=verification.configs query param is present
type VerificationSanityConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSendGrid struct {
	Configs *VerificationSendGridConfigs `json:"configs,omitempty"`
}

// The verification configs for SendGrid. Only included if the ?include=verification.configs query param is present
type VerificationSendGridConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationShopify struct {
	Configs *VerificationShopifyConfigs `json:"configs,omitempty"`
}

// The verification configs for Shopify. Only included if the ?include=verification.configs query param is present
type VerificationShopifyConfigs struct {
	WebhookSecretKey string                                     `json:"webhook_secret_key"`
	RateLimitPeriod  *VerificationShopifyConfigsRateLimitPeriod `json:"rate_limit_period,omitempty"`
	RateLimit        *float64                                   `json:"rate_limit,omitempty"`
	ApiKey           *string                                    `json:"api_key,omitempty"`
	ApiSecret        *string                                    `json:"api_secret,omitempty"`
	Shop             *string                                    `json:"shop,omitempty"`
}

type VerificationShopifyConfigsRateLimitPeriod string

const (
	VerificationShopifyConfigsRateLimitPeriodMinute VerificationShopifyConfigsRateLimitPeriod = "minute"
	VerificationShopifyConfigsRateLimitPeriodSecond VerificationShopifyConfigsRateLimitPeriod = "second"
)

func NewVerificationShopifyConfigsRateLimitPeriodFromString(s string) (VerificationShopifyConfigsRateLimitPeriod, error) {
	switch s {
	case "minute":
		return VerificationShopifyConfigsRateLimitPeriodMinute, nil
	case "second":
		return VerificationShopifyConfigsRateLimitPeriodSecond, nil
	}
	var t VerificationShopifyConfigsRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationShopifyConfigsRateLimitPeriod) Ptr() *VerificationShopifyConfigsRateLimitPeriod {
	return &v
}

type VerificationShopline struct {
	Configs *VerificationShoplineConfigs `json:"configs,omitempty"`
}

// The verification configs for Shopline. Only included if the ?include=verification.configs query param is present
type VerificationShoplineConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSlack struct {
	Configs *VerificationSlackConfigs `json:"configs,omitempty"`
}

// The verification configs for Slack. Only included if the ?include=verification.configs query param is present
type VerificationSlackConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSolidGate struct {
	Configs *VerificationSolidGateConfigs `json:"configs,omitempty"`
}

// The verification configs for SolidGate. Only included if the ?include=verification.configs query param is present
type VerificationSolidGateConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSquare struct {
	Configs *VerificationSquareConfigs `json:"configs,omitempty"`
}

// The verification configs for Square. Only included if the ?include=verification.configs query param is present
type VerificationSquareConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationStripe struct {
	Configs *VerificationStripeConfigs `json:"configs,omitempty"`
}

// The verification configs for Stripe. Only included if the ?include=verification.configs query param is present
type VerificationStripeConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSvix struct {
	Configs *VerificationSvixConfigs `json:"configs,omitempty"`
}

// The verification configs for Svix. Only included if the ?include=verification.configs query param is present
type VerificationSvixConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSynctera struct {
	Configs *VerificationSyncteraConfigs `json:"configs,omitempty"`
}

// The verification configs for Synctera. Only included if the ?include=verification.configs query param is present
type VerificationSyncteraConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationTebex struct {
	Configs *VerificationTebexConfigs `json:"configs,omitempty"`
}

// The verification configs for Tebex. Only included if the ?include=verification.configs query param is present
type VerificationTebexConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationTelnyx struct {
	Configs *VerificationTelnyxConfigs `json:"configs,omitempty"`
}

// The verification configs for Telnyx. Only included if the ?include=verification.configs query param is present
type VerificationTelnyxConfigs struct {
	PublicKey string `json:"public_key"`
}

type VerificationTokenIo struct {
	Configs *VerificationTokenIoConfigs `json:"configs,omitempty"`
}

// The verification configs for TokenIO. Only included if the ?include=verification.configs query param is present
type VerificationTokenIoConfigs struct {
	PublicKey string `json:"public_key"`
}

type VerificationTrello struct {
	Configs *VerificationTrelloConfigs `json:"configs,omitempty"`
}

// The verification configs for Trello. Only included if the ?include=verification.configs query param is present
type VerificationTrelloConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationTwilio struct {
	Configs *VerificationTwilioConfigs `json:"configs,omitempty"`
}

// The verification configs for Twilio. Only included if the ?include=verification.configs query param is present
type VerificationTwilioConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationTwitch struct {
	Configs *VerificationTwitchConfigs `json:"configs,omitempty"`
}

// The verification configs for Twitch. Only included if the ?include=verification.configs query param is present
type VerificationTwitchConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationTwitter struct {
	Configs *VerificationTwitterConfigs `json:"configs,omitempty"`
}

// The verification configs for Twitter. Only included if the ?include=verification.configs query param is present
type VerificationTwitterConfigs struct {
	ApiKey string `json:"api_key"`
}

type VerificationTypeform struct {
	Configs *VerificationTypeformConfigs `json:"configs,omitempty"`
}

// The verification configs for Typeform. Only included if the ?include=verification.configs query param is present
type VerificationTypeformConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationVercel struct {
	Configs *VerificationVercelConfigs `json:"configs,omitempty"`
}

// The verification configs for Vercel. Only included if the ?include=verification.configs query param is present
type VerificationVercelConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationVercelLogDrains struct {
	Configs *VerificationVercelLogDrainsConfigs `json:"configs,omitempty"`
}

// The verification configs for Vercel Log Drains. Only included if the ?include=verification.configs query param is present
type VerificationVercelLogDrainsConfigs struct {
	WebhookSecretKey      *string `json:"webhook_secret_key,omitempty"`
	VercelLogDrainsSecret string  `json:"vercel_log_drains_secret"`
}

type VerificationWix struct {
	Configs *VerificationWixConfigs `json:"configs,omitempty"`
}

// The verification configs for Wix. Only included if the ?include=verification.configs query param is present
type VerificationWixConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationWooCommerce struct {
	Configs *VerificationWooCommerceConfigs `json:"configs,omitempty"`
}

// The verification configs for WooCommerce. Only included if the ?include=verification.configs query param is present
type VerificationWooCommerceConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationWorkOs struct {
	Configs *VerificationWorkOsConfigs `json:"configs,omitempty"`
}

// The verification configs for WorkOS. Only included if the ?include=verification.configs query param is present
type VerificationWorkOsConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationXero struct {
	Configs *VerificationXeroConfigs `json:"configs,omitempty"`
}

// The verification configs for Xero. Only included if the ?include=verification.configs query param is present
type VerificationXeroConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationZoom struct {
	Configs *VerificationZoomConfigs `json:"configs,omitempty"`
}

// The verification configs for Zoom. Only included if the ?include=verification.configs query param is present
type VerificationZoomConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

// Period to rate limit attempts
type ConnectionCreateRequestDestinationRateLimitPeriod string

const (
	ConnectionCreateRequestDestinationRateLimitPeriodSecond     ConnectionCreateRequestDestinationRateLimitPeriod = "second"
	ConnectionCreateRequestDestinationRateLimitPeriodMinute     ConnectionCreateRequestDestinationRateLimitPeriod = "minute"
	ConnectionCreateRequestDestinationRateLimitPeriodHour       ConnectionCreateRequestDestinationRateLimitPeriod = "hour"
	ConnectionCreateRequestDestinationRateLimitPeriodConcurrent ConnectionCreateRequestDestinationRateLimitPeriod = "concurrent"
)

func NewConnectionCreateRequestDestinationRateLimitPeriodFromString(s string) (ConnectionCreateRequestDestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return ConnectionCreateRequestDestinationRateLimitPeriodSecond, nil
	case "minute":
		return ConnectionCreateRequestDestinationRateLimitPeriodMinute, nil
	case "hour":
		return ConnectionCreateRequestDestinationRateLimitPeriodHour, nil
	case "concurrent":
		return ConnectionCreateRequestDestinationRateLimitPeriodConcurrent, nil
	}
	var t ConnectionCreateRequestDestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionCreateRequestDestinationRateLimitPeriod) Ptr() *ConnectionCreateRequestDestinationRateLimitPeriod {
	return &c
}

// Period to rate limit attempts
type ConnectionUpsertRequestDestinationRateLimitPeriod string

const (
	ConnectionUpsertRequestDestinationRateLimitPeriodSecond     ConnectionUpsertRequestDestinationRateLimitPeriod = "second"
	ConnectionUpsertRequestDestinationRateLimitPeriodMinute     ConnectionUpsertRequestDestinationRateLimitPeriod = "minute"
	ConnectionUpsertRequestDestinationRateLimitPeriodHour       ConnectionUpsertRequestDestinationRateLimitPeriod = "hour"
	ConnectionUpsertRequestDestinationRateLimitPeriodConcurrent ConnectionUpsertRequestDestinationRateLimitPeriod = "concurrent"
)

func NewConnectionUpsertRequestDestinationRateLimitPeriodFromString(s string) (ConnectionUpsertRequestDestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return ConnectionUpsertRequestDestinationRateLimitPeriodSecond, nil
	case "minute":
		return ConnectionUpsertRequestDestinationRateLimitPeriodMinute, nil
	case "hour":
		return ConnectionUpsertRequestDestinationRateLimitPeriodHour, nil
	case "concurrent":
		return ConnectionUpsertRequestDestinationRateLimitPeriodConcurrent, nil
	}
	var t ConnectionUpsertRequestDestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionUpsertRequestDestinationRateLimitPeriod) Ptr() *ConnectionUpsertRequestDestinationRateLimitPeriod {
	return &c
}

// Filter by number of attempts
type EventBulkRetryCreateRequestQueryAttempts struct {
	typeName                                    string
	Integer                                     int
	EventBulkRetryCreateRequestQueryAttemptsAll *EventBulkRetryCreateRequestQueryAttemptsAll
}

func NewEventBulkRetryCreateRequestQueryAttemptsFromInteger(value int) *EventBulkRetryCreateRequestQueryAttempts {
	return &EventBulkRetryCreateRequestQueryAttempts{typeName: "integer", Integer: value}
}

func NewEventBulkRetryCreateRequestQueryAttemptsFromEventBulkRetryCreateRequestQueryAttemptsAll(value *EventBulkRetryCreateRequestQueryAttemptsAll) *EventBulkRetryCreateRequestQueryAttempts {
	return &EventBulkRetryCreateRequestQueryAttempts{typeName: "eventBulkRetryCreateRequestQueryAttemptsAll", EventBulkRetryCreateRequestQueryAttemptsAll: value}
}

func (e *EventBulkRetryCreateRequestQueryAttempts) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		e.typeName = "integer"
		e.Integer = valueInteger
		return nil
	}
	valueEventBulkRetryCreateRequestQueryAttemptsAll := new(EventBulkRetryCreateRequestQueryAttemptsAll)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryAttemptsAll); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryAttemptsAll"
		e.EventBulkRetryCreateRequestQueryAttemptsAll = valueEventBulkRetryCreateRequestQueryAttemptsAll
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryAttempts) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return json.Marshal(e.Integer)
	case "eventBulkRetryCreateRequestQueryAttemptsAll":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryAttemptsAll)
	}
}

type EventBulkRetryCreateRequestQueryAttemptsVisitor interface {
	VisitInteger(int) error
	VisitEventBulkRetryCreateRequestQueryAttemptsAll(*EventBulkRetryCreateRequestQueryAttemptsAll) error
}

func (e *EventBulkRetryCreateRequestQueryAttempts) Accept(visitor EventBulkRetryCreateRequestQueryAttemptsVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "eventBulkRetryCreateRequestQueryAttemptsAll":
		return visitor.VisitEventBulkRetryCreateRequestQueryAttemptsAll(e.EventBulkRetryCreateRequestQueryAttemptsAll)
	}
}

type EventBulkRetryCreateRequestQueryAttemptsAll struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	All      *bool `json:"all,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// URL Encoded string of the JSON to match to the data body
type EventBulkRetryCreateRequestQueryBody struct {
	typeName                                string
	String                                  string
	EventBulkRetryCreateRequestQueryBodyOne *EventBulkRetryCreateRequestQueryBodyOne
}

func NewEventBulkRetryCreateRequestQueryBodyFromString(value string) *EventBulkRetryCreateRequestQueryBody {
	return &EventBulkRetryCreateRequestQueryBody{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryBodyFromEventBulkRetryCreateRequestQueryBodyOne(value *EventBulkRetryCreateRequestQueryBodyOne) *EventBulkRetryCreateRequestQueryBody {
	return &EventBulkRetryCreateRequestQueryBody{typeName: "eventBulkRetryCreateRequestQueryBodyOne", EventBulkRetryCreateRequestQueryBodyOne: value}
}

func (e *EventBulkRetryCreateRequestQueryBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryBodyOne := new(EventBulkRetryCreateRequestQueryBodyOne)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryBodyOne); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryBodyOne"
		e.EventBulkRetryCreateRequestQueryBodyOne = valueEventBulkRetryCreateRequestQueryBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryBody) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryBodyOne":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryBodyOne)
	}
}

type EventBulkRetryCreateRequestQueryBodyVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryBodyOne(*EventBulkRetryCreateRequestQueryBodyOne) error
}

func (e *EventBulkRetryCreateRequestQueryBody) Accept(visitor EventBulkRetryCreateRequestQueryBodyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryBodyOne":
		return visitor.VisitEventBulkRetryCreateRequestQueryBodyOne(e.EventBulkRetryCreateRequestQueryBodyOne)
	}
}

type EventBulkRetryCreateRequestQueryBodyOne struct {
}

type EventBulkRetryCreateRequestQueryBulkRetryId struct {
	typeName   string
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryBulkRetryIdFromString(value string) *EventBulkRetryCreateRequestQueryBulkRetryId {
	return &EventBulkRetryCreateRequestQueryBulkRetryId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryBulkRetryIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryBulkRetryId {
	return &EventBulkRetryCreateRequestQueryBulkRetryId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryBulkRetryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryBulkRetryId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryBulkRetryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryBulkRetryId) Accept(visitor EventBulkRetryCreateRequestQueryBulkRetryIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by CLI IDs. `?[any]=true` operator for any CLI.
type EventBulkRetryCreateRequestQueryCliId struct {
	typeName                                 string
	String                                   string
	EventBulkRetryCreateRequestQueryCliIdAll *EventBulkRetryCreateRequestQueryCliIdAll
	StringList                               []string
}

func NewEventBulkRetryCreateRequestQueryCliIdFromString(value string) *EventBulkRetryCreateRequestQueryCliId {
	return &EventBulkRetryCreateRequestQueryCliId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryCliIdFromEventBulkRetryCreateRequestQueryCliIdAll(value *EventBulkRetryCreateRequestQueryCliIdAll) *EventBulkRetryCreateRequestQueryCliId {
	return &EventBulkRetryCreateRequestQueryCliId{typeName: "eventBulkRetryCreateRequestQueryCliIdAll", EventBulkRetryCreateRequestQueryCliIdAll: value}
}

func NewEventBulkRetryCreateRequestQueryCliIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryCliId {
	return &EventBulkRetryCreateRequestQueryCliId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryCliId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryCliIdAll := new(EventBulkRetryCreateRequestQueryCliIdAll)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryCliIdAll); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryCliIdAll"
		e.EventBulkRetryCreateRequestQueryCliIdAll = valueEventBulkRetryCreateRequestQueryCliIdAll
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryCliId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryCliIdAll":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryCliIdAll)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryCliIdVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryCliIdAll(*EventBulkRetryCreateRequestQueryCliIdAll) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryCliId) Accept(visitor EventBulkRetryCreateRequestQueryCliIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryCliIdAll":
		return visitor.VisitEventBulkRetryCreateRequestQueryCliIdAll(e.EventBulkRetryCreateRequestQueryCliIdAll)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryCliIdAll struct {
	Any *bool `json:"any,omitempty"`
	All *bool `json:"all,omitempty"`
}

type EventBulkRetryCreateRequestQueryCliUserId struct {
	typeName   string
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryCliUserIdFromString(value string) *EventBulkRetryCreateRequestQueryCliUserId {
	return &EventBulkRetryCreateRequestQueryCliUserId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryCliUserIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryCliUserId {
	return &EventBulkRetryCreateRequestQueryCliUserId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryCliUserId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryCliUserId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryCliUserIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryCliUserId) Accept(visitor EventBulkRetryCreateRequestQueryCliUserIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by `created_at` date using a date operator
type EventBulkRetryCreateRequestQueryCreatedAt struct {
	typeName                                     string
	DateTime                                     time.Time
	EventBulkRetryCreateRequestQueryCreatedAtAny *EventBulkRetryCreateRequestQueryCreatedAtAny
}

func NewEventBulkRetryCreateRequestQueryCreatedAtFromDateTime(value time.Time) *EventBulkRetryCreateRequestQueryCreatedAt {
	return &EventBulkRetryCreateRequestQueryCreatedAt{typeName: "dateTime", DateTime: value}
}

func NewEventBulkRetryCreateRequestQueryCreatedAtFromEventBulkRetryCreateRequestQueryCreatedAtAny(value *EventBulkRetryCreateRequestQueryCreatedAtAny) *EventBulkRetryCreateRequestQueryCreatedAt {
	return &EventBulkRetryCreateRequestQueryCreatedAt{typeName: "eventBulkRetryCreateRequestQueryCreatedAtAny", EventBulkRetryCreateRequestQueryCreatedAtAny: value}
}

func (e *EventBulkRetryCreateRequestQueryCreatedAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		e.typeName = "dateTime"
		e.DateTime = valueDateTime
		return nil
	}
	valueEventBulkRetryCreateRequestQueryCreatedAtAny := new(EventBulkRetryCreateRequestQueryCreatedAtAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryCreatedAtAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryCreatedAtAny"
		e.EventBulkRetryCreateRequestQueryCreatedAtAny = valueEventBulkRetryCreateRequestQueryCreatedAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryCreatedAt) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return json.Marshal(e.DateTime)
	case "eventBulkRetryCreateRequestQueryCreatedAtAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryCreatedAtAny)
	}
}

type EventBulkRetryCreateRequestQueryCreatedAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitEventBulkRetryCreateRequestQueryCreatedAtAny(*EventBulkRetryCreateRequestQueryCreatedAtAny) error
}

func (e *EventBulkRetryCreateRequestQueryCreatedAt) Accept(visitor EventBulkRetryCreateRequestQueryCreatedAtVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return visitor.VisitDateTime(e.DateTime)
	case "eventBulkRetryCreateRequestQueryCreatedAtAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryCreatedAtAny(e.EventBulkRetryCreateRequestQueryCreatedAtAny)
	}
}

type EventBulkRetryCreateRequestQueryCreatedAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// Filter by destination IDs
type EventBulkRetryCreateRequestQueryDestinationId struct {
	typeName string
	// Destination ID
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryDestinationIdFromString(value string) *EventBulkRetryCreateRequestQueryDestinationId {
	return &EventBulkRetryCreateRequestQueryDestinationId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryDestinationIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryDestinationId {
	return &EventBulkRetryCreateRequestQueryDestinationId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryDestinationId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryDestinationId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryDestinationIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryDestinationId) Accept(visitor EventBulkRetryCreateRequestQueryDestinationIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by error code code
type EventBulkRetryCreateRequestQueryErrorCode struct {
	typeName              string
	AttemptErrorCodes     AttemptErrorCodes
	AttemptErrorCodesList []AttemptErrorCodes
}

func NewEventBulkRetryCreateRequestQueryErrorCodeFromAttemptErrorCodes(value AttemptErrorCodes) *EventBulkRetryCreateRequestQueryErrorCode {
	return &EventBulkRetryCreateRequestQueryErrorCode{typeName: "attemptErrorCodes", AttemptErrorCodes: value}
}

func NewEventBulkRetryCreateRequestQueryErrorCodeFromAttemptErrorCodesList(value []AttemptErrorCodes) *EventBulkRetryCreateRequestQueryErrorCode {
	return &EventBulkRetryCreateRequestQueryErrorCode{typeName: "attemptErrorCodesList", AttemptErrorCodesList: value}
}

func (e *EventBulkRetryCreateRequestQueryErrorCode) UnmarshalJSON(data []byte) error {
	var valueAttemptErrorCodes AttemptErrorCodes
	if err := json.Unmarshal(data, &valueAttemptErrorCodes); err == nil {
		e.typeName = "attemptErrorCodes"
		e.AttemptErrorCodes = valueAttemptErrorCodes
		return nil
	}
	var valueAttemptErrorCodesList []AttemptErrorCodes
	if err := json.Unmarshal(data, &valueAttemptErrorCodesList); err == nil {
		e.typeName = "attemptErrorCodesList"
		e.AttemptErrorCodesList = valueAttemptErrorCodesList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryErrorCode) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "attemptErrorCodes":
		return json.Marshal(e.AttemptErrorCodes)
	case "attemptErrorCodesList":
		return json.Marshal(e.AttemptErrorCodesList)
	}
}

type EventBulkRetryCreateRequestQueryErrorCodeVisitor interface {
	VisitAttemptErrorCodes(AttemptErrorCodes) error
	VisitAttemptErrorCodesList([]AttemptErrorCodes) error
}

func (e *EventBulkRetryCreateRequestQueryErrorCode) Accept(visitor EventBulkRetryCreateRequestQueryErrorCodeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "attemptErrorCodes":
		return visitor.VisitAttemptErrorCodes(e.AttemptErrorCodes)
	case "attemptErrorCodesList":
		return visitor.VisitAttemptErrorCodesList(e.AttemptErrorCodesList)
	}
}

type EventBulkRetryCreateRequestQueryEventDataId struct {
	typeName   string
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryEventDataIdFromString(value string) *EventBulkRetryCreateRequestQueryEventDataId {
	return &EventBulkRetryCreateRequestQueryEventDataId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryEventDataIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryEventDataId {
	return &EventBulkRetryCreateRequestQueryEventDataId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryEventDataId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryEventDataId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryEventDataIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryEventDataId) Accept(visitor EventBulkRetryCreateRequestQueryEventDataIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// URL Encoded string of the JSON to match to the data headers
type EventBulkRetryCreateRequestQueryHeaders struct {
	typeName                                   string
	String                                     string
	EventBulkRetryCreateRequestQueryHeadersOne *EventBulkRetryCreateRequestQueryHeadersOne
}

func NewEventBulkRetryCreateRequestQueryHeadersFromString(value string) *EventBulkRetryCreateRequestQueryHeaders {
	return &EventBulkRetryCreateRequestQueryHeaders{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryHeadersFromEventBulkRetryCreateRequestQueryHeadersOne(value *EventBulkRetryCreateRequestQueryHeadersOne) *EventBulkRetryCreateRequestQueryHeaders {
	return &EventBulkRetryCreateRequestQueryHeaders{typeName: "eventBulkRetryCreateRequestQueryHeadersOne", EventBulkRetryCreateRequestQueryHeadersOne: value}
}

func (e *EventBulkRetryCreateRequestQueryHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryHeadersOne := new(EventBulkRetryCreateRequestQueryHeadersOne)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryHeadersOne); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryHeadersOne"
		e.EventBulkRetryCreateRequestQueryHeadersOne = valueEventBulkRetryCreateRequestQueryHeadersOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryHeaders) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryHeadersOne":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryHeadersOne)
	}
}

type EventBulkRetryCreateRequestQueryHeadersVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryHeadersOne(*EventBulkRetryCreateRequestQueryHeadersOne) error
}

func (e *EventBulkRetryCreateRequestQueryHeaders) Accept(visitor EventBulkRetryCreateRequestQueryHeadersVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryHeadersOne":
		return visitor.VisitEventBulkRetryCreateRequestQueryHeadersOne(e.EventBulkRetryCreateRequestQueryHeadersOne)
	}
}

type EventBulkRetryCreateRequestQueryHeadersOne struct {
}

// Filter by event IDs
type EventBulkRetryCreateRequestQueryId struct {
	typeName string
	// Event ID
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryIdFromString(value string) *EventBulkRetryCreateRequestQueryId {
	return &EventBulkRetryCreateRequestQueryId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryId {
	return &EventBulkRetryCreateRequestQueryId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryId) Accept(visitor EventBulkRetryCreateRequestQueryIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryIssueId struct {
	typeName   string
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryIssueIdFromString(value string) *EventBulkRetryCreateRequestQueryIssueId {
	return &EventBulkRetryCreateRequestQueryIssueId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryIssueIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryIssueId {
	return &EventBulkRetryCreateRequestQueryIssueId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryIssueId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryIssueId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryIssueIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryIssueId) Accept(visitor EventBulkRetryCreateRequestQueryIssueIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by `last_attempt_at` date using a date operator
type EventBulkRetryCreateRequestQueryLastAttemptAt struct {
	typeName                                         string
	DateTime                                         time.Time
	EventBulkRetryCreateRequestQueryLastAttemptAtAny *EventBulkRetryCreateRequestQueryLastAttemptAtAny
}

func NewEventBulkRetryCreateRequestQueryLastAttemptAtFromDateTime(value time.Time) *EventBulkRetryCreateRequestQueryLastAttemptAt {
	return &EventBulkRetryCreateRequestQueryLastAttemptAt{typeName: "dateTime", DateTime: value}
}

func NewEventBulkRetryCreateRequestQueryLastAttemptAtFromEventBulkRetryCreateRequestQueryLastAttemptAtAny(value *EventBulkRetryCreateRequestQueryLastAttemptAtAny) *EventBulkRetryCreateRequestQueryLastAttemptAt {
	return &EventBulkRetryCreateRequestQueryLastAttemptAt{typeName: "eventBulkRetryCreateRequestQueryLastAttemptAtAny", EventBulkRetryCreateRequestQueryLastAttemptAtAny: value}
}

func (e *EventBulkRetryCreateRequestQueryLastAttemptAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		e.typeName = "dateTime"
		e.DateTime = valueDateTime
		return nil
	}
	valueEventBulkRetryCreateRequestQueryLastAttemptAtAny := new(EventBulkRetryCreateRequestQueryLastAttemptAtAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryLastAttemptAtAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryLastAttemptAtAny"
		e.EventBulkRetryCreateRequestQueryLastAttemptAtAny = valueEventBulkRetryCreateRequestQueryLastAttemptAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryLastAttemptAt) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return json.Marshal(e.DateTime)
	case "eventBulkRetryCreateRequestQueryLastAttemptAtAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryLastAttemptAtAny)
	}
}

type EventBulkRetryCreateRequestQueryLastAttemptAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitEventBulkRetryCreateRequestQueryLastAttemptAtAny(*EventBulkRetryCreateRequestQueryLastAttemptAtAny) error
}

func (e *EventBulkRetryCreateRequestQueryLastAttemptAt) Accept(visitor EventBulkRetryCreateRequestQueryLastAttemptAtVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return visitor.VisitDateTime(e.DateTime)
	case "eventBulkRetryCreateRequestQueryLastAttemptAtAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryLastAttemptAtAny(e.EventBulkRetryCreateRequestQueryLastAttemptAtAny)
	}
}

type EventBulkRetryCreateRequestQueryLastAttemptAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
type EventBulkRetryCreateRequestQueryParsedQuery struct {
	typeName                                       string
	String                                         string
	EventBulkRetryCreateRequestQueryParsedQueryOne *EventBulkRetryCreateRequestQueryParsedQueryOne
}

func NewEventBulkRetryCreateRequestQueryParsedQueryFromString(value string) *EventBulkRetryCreateRequestQueryParsedQuery {
	return &EventBulkRetryCreateRequestQueryParsedQuery{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryParsedQueryFromEventBulkRetryCreateRequestQueryParsedQueryOne(value *EventBulkRetryCreateRequestQueryParsedQueryOne) *EventBulkRetryCreateRequestQueryParsedQuery {
	return &EventBulkRetryCreateRequestQueryParsedQuery{typeName: "eventBulkRetryCreateRequestQueryParsedQueryOne", EventBulkRetryCreateRequestQueryParsedQueryOne: value}
}

func (e *EventBulkRetryCreateRequestQueryParsedQuery) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryParsedQueryOne := new(EventBulkRetryCreateRequestQueryParsedQueryOne)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryParsedQueryOne); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryParsedQueryOne"
		e.EventBulkRetryCreateRequestQueryParsedQueryOne = valueEventBulkRetryCreateRequestQueryParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryParsedQuery) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryParsedQueryOne":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type EventBulkRetryCreateRequestQueryParsedQueryVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryParsedQueryOne(*EventBulkRetryCreateRequestQueryParsedQueryOne) error
}

func (e *EventBulkRetryCreateRequestQueryParsedQuery) Accept(visitor EventBulkRetryCreateRequestQueryParsedQueryVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryParsedQueryOne":
		return visitor.VisitEventBulkRetryCreateRequestQueryParsedQueryOne(e.EventBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type EventBulkRetryCreateRequestQueryParsedQueryOne struct {
}

// Filter by HTTP response status code
type EventBulkRetryCreateRequestQueryResponseStatus struct {
	typeName                                          string
	Integer                                           int
	EventBulkRetryCreateRequestQueryResponseStatusAll *EventBulkRetryCreateRequestQueryResponseStatusAll
	IntegerList                                       []int
}

func NewEventBulkRetryCreateRequestQueryResponseStatusFromInteger(value int) *EventBulkRetryCreateRequestQueryResponseStatus {
	return &EventBulkRetryCreateRequestQueryResponseStatus{typeName: "integer", Integer: value}
}

func NewEventBulkRetryCreateRequestQueryResponseStatusFromEventBulkRetryCreateRequestQueryResponseStatusAll(value *EventBulkRetryCreateRequestQueryResponseStatusAll) *EventBulkRetryCreateRequestQueryResponseStatus {
	return &EventBulkRetryCreateRequestQueryResponseStatus{typeName: "eventBulkRetryCreateRequestQueryResponseStatusAll", EventBulkRetryCreateRequestQueryResponseStatusAll: value}
}

func NewEventBulkRetryCreateRequestQueryResponseStatusFromIntegerList(value []int) *EventBulkRetryCreateRequestQueryResponseStatus {
	return &EventBulkRetryCreateRequestQueryResponseStatus{typeName: "integerList", IntegerList: value}
}

func (e *EventBulkRetryCreateRequestQueryResponseStatus) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		e.typeName = "integer"
		e.Integer = valueInteger
		return nil
	}
	valueEventBulkRetryCreateRequestQueryResponseStatusAll := new(EventBulkRetryCreateRequestQueryResponseStatusAll)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryResponseStatusAll); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryResponseStatusAll"
		e.EventBulkRetryCreateRequestQueryResponseStatusAll = valueEventBulkRetryCreateRequestQueryResponseStatusAll
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		e.typeName = "integerList"
		e.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryResponseStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return json.Marshal(e.Integer)
	case "eventBulkRetryCreateRequestQueryResponseStatusAll":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryResponseStatusAll)
	case "integerList":
		return json.Marshal(e.IntegerList)
	}
}

type EventBulkRetryCreateRequestQueryResponseStatusVisitor interface {
	VisitInteger(int) error
	VisitEventBulkRetryCreateRequestQueryResponseStatusAll(*EventBulkRetryCreateRequestQueryResponseStatusAll) error
	VisitIntegerList([]int) error
}

func (e *EventBulkRetryCreateRequestQueryResponseStatus) Accept(visitor EventBulkRetryCreateRequestQueryResponseStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "eventBulkRetryCreateRequestQueryResponseStatusAll":
		return visitor.VisitEventBulkRetryCreateRequestQueryResponseStatusAll(e.EventBulkRetryCreateRequestQueryResponseStatusAll)
	case "integerList":
		return visitor.VisitIntegerList(e.IntegerList)
	}
}

type EventBulkRetryCreateRequestQueryResponseStatusAll struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	All      *bool `json:"all,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// Filter by source IDs
type EventBulkRetryCreateRequestQuerySourceId struct {
	typeName string
	// Source ID
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQuerySourceIdFromString(value string) *EventBulkRetryCreateRequestQuerySourceId {
	return &EventBulkRetryCreateRequestQuerySourceId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQuerySourceIdFromStringList(value []string) *EventBulkRetryCreateRequestQuerySourceId {
	return &EventBulkRetryCreateRequestQuerySourceId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQuerySourceId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQuerySourceId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQuerySourceIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQuerySourceId) Accept(visitor EventBulkRetryCreateRequestQuerySourceIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Lifecyle status of the event
type EventBulkRetryCreateRequestQueryStatus struct {
	typeName        string
	EventStatus     EventStatus
	EventStatusList []EventStatus
}

func NewEventBulkRetryCreateRequestQueryStatusFromEventStatus(value EventStatus) *EventBulkRetryCreateRequestQueryStatus {
	return &EventBulkRetryCreateRequestQueryStatus{typeName: "eventStatus", EventStatus: value}
}

func NewEventBulkRetryCreateRequestQueryStatusFromEventStatusList(value []EventStatus) *EventBulkRetryCreateRequestQueryStatus {
	return &EventBulkRetryCreateRequestQueryStatus{typeName: "eventStatusList", EventStatusList: value}
}

func (e *EventBulkRetryCreateRequestQueryStatus) UnmarshalJSON(data []byte) error {
	var valueEventStatus EventStatus
	if err := json.Unmarshal(data, &valueEventStatus); err == nil {
		e.typeName = "eventStatus"
		e.EventStatus = valueEventStatus
		return nil
	}
	var valueEventStatusList []EventStatus
	if err := json.Unmarshal(data, &valueEventStatusList); err == nil {
		e.typeName = "eventStatusList"
		e.EventStatusList = valueEventStatusList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventStatus":
		return json.Marshal(e.EventStatus)
	case "eventStatusList":
		return json.Marshal(e.EventStatusList)
	}
}

type EventBulkRetryCreateRequestQueryStatusVisitor interface {
	VisitEventStatus(EventStatus) error
	VisitEventStatusList([]EventStatus) error
}

func (e *EventBulkRetryCreateRequestQueryStatus) Accept(visitor EventBulkRetryCreateRequestQueryStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventStatus":
		return visitor.VisitEventStatus(e.EventStatus)
	case "eventStatusList":
		return visitor.VisitEventStatusList(e.EventStatusList)
	}
}

// Filter by `successful_at` date using a date operator
type EventBulkRetryCreateRequestQuerySuccessfulAt struct {
	typeName                                        string
	DateTime                                        time.Time
	EventBulkRetryCreateRequestQuerySuccessfulAtAny *EventBulkRetryCreateRequestQuerySuccessfulAtAny
}

func NewEventBulkRetryCreateRequestQuerySuccessfulAtFromDateTime(value time.Time) *EventBulkRetryCreateRequestQuerySuccessfulAt {
	return &EventBulkRetryCreateRequestQuerySuccessfulAt{typeName: "dateTime", DateTime: value}
}

func NewEventBulkRetryCreateRequestQuerySuccessfulAtFromEventBulkRetryCreateRequestQuerySuccessfulAtAny(value *EventBulkRetryCreateRequestQuerySuccessfulAtAny) *EventBulkRetryCreateRequestQuerySuccessfulAt {
	return &EventBulkRetryCreateRequestQuerySuccessfulAt{typeName: "eventBulkRetryCreateRequestQuerySuccessfulAtAny", EventBulkRetryCreateRequestQuerySuccessfulAtAny: value}
}

func (e *EventBulkRetryCreateRequestQuerySuccessfulAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		e.typeName = "dateTime"
		e.DateTime = valueDateTime
		return nil
	}
	valueEventBulkRetryCreateRequestQuerySuccessfulAtAny := new(EventBulkRetryCreateRequestQuerySuccessfulAtAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQuerySuccessfulAtAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQuerySuccessfulAtAny"
		e.EventBulkRetryCreateRequestQuerySuccessfulAtAny = valueEventBulkRetryCreateRequestQuerySuccessfulAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQuerySuccessfulAt) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return json.Marshal(e.DateTime)
	case "eventBulkRetryCreateRequestQuerySuccessfulAtAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQuerySuccessfulAtAny)
	}
}

type EventBulkRetryCreateRequestQuerySuccessfulAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitEventBulkRetryCreateRequestQuerySuccessfulAtAny(*EventBulkRetryCreateRequestQuerySuccessfulAtAny) error
}

func (e *EventBulkRetryCreateRequestQuerySuccessfulAt) Accept(visitor EventBulkRetryCreateRequestQuerySuccessfulAtVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return visitor.VisitDateTime(e.DateTime)
	case "eventBulkRetryCreateRequestQuerySuccessfulAtAny":
		return visitor.VisitEventBulkRetryCreateRequestQuerySuccessfulAtAny(e.EventBulkRetryCreateRequestQuerySuccessfulAtAny)
	}
}

type EventBulkRetryCreateRequestQuerySuccessfulAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// Filter by webhook connection IDs
type EventBulkRetryCreateRequestQueryWebhookId struct {
	typeName string
	// Webhook ID
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryWebhookIdFromString(value string) *EventBulkRetryCreateRequestQueryWebhookId {
	return &EventBulkRetryCreateRequestQueryWebhookId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryWebhookIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryWebhookId {
	return &EventBulkRetryCreateRequestQueryWebhookId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryWebhookId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryWebhookId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryWebhookIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryWebhookId) Accept(visitor EventBulkRetryCreateRequestQueryWebhookIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// The cause of the ignored event
type IgnoredEventBulkRetryCreateRequestQueryCause struct {
	typeName   string
	String     string
	StringList []string
}

func NewIgnoredEventBulkRetryCreateRequestQueryCauseFromString(value string) *IgnoredEventBulkRetryCreateRequestQueryCause {
	return &IgnoredEventBulkRetryCreateRequestQueryCause{typeName: "string", String: value}
}

func NewIgnoredEventBulkRetryCreateRequestQueryCauseFromStringList(value []string) *IgnoredEventBulkRetryCreateRequestQueryCause {
	return &IgnoredEventBulkRetryCreateRequestQueryCause{typeName: "stringList", StringList: value}
}

func (i *IgnoredEventBulkRetryCreateRequestQueryCause) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IgnoredEventBulkRetryCreateRequestQueryCause) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IgnoredEventBulkRetryCreateRequestQueryCauseVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IgnoredEventBulkRetryCreateRequestQueryCause) Accept(visitor IgnoredEventBulkRetryCreateRequestQueryCauseVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Connection ID of the ignored event
type IgnoredEventBulkRetryCreateRequestQueryWebhookId struct {
	typeName   string
	String     string
	StringList []string
}

func NewIgnoredEventBulkRetryCreateRequestQueryWebhookIdFromString(value string) *IgnoredEventBulkRetryCreateRequestQueryWebhookId {
	return &IgnoredEventBulkRetryCreateRequestQueryWebhookId{typeName: "string", String: value}
}

func NewIgnoredEventBulkRetryCreateRequestQueryWebhookIdFromStringList(value []string) *IgnoredEventBulkRetryCreateRequestQueryWebhookId {
	return &IgnoredEventBulkRetryCreateRequestQueryWebhookId{typeName: "stringList", StringList: value}
}

func (i *IgnoredEventBulkRetryCreateRequestQueryWebhookId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IgnoredEventBulkRetryCreateRequestQueryWebhookId) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IgnoredEventBulkRetryCreateRequestQueryWebhookIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IgnoredEventBulkRetryCreateRequestQueryWebhookId) Accept(visitor IgnoredEventBulkRetryCreateRequestQueryWebhookIdVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// URL Encoded string of the JSON to match to the data body
type RequestBulkRetryCreateRequestQueryBody struct {
	typeName                                  string
	String                                    string
	RequestBulkRetryCreateRequestQueryBodyOne *RequestBulkRetryCreateRequestQueryBodyOne
}

func NewRequestBulkRetryCreateRequestQueryBodyFromString(value string) *RequestBulkRetryCreateRequestQueryBody {
	return &RequestBulkRetryCreateRequestQueryBody{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryBodyFromRequestBulkRetryCreateRequestQueryBodyOne(value *RequestBulkRetryCreateRequestQueryBodyOne) *RequestBulkRetryCreateRequestQueryBody {
	return &RequestBulkRetryCreateRequestQueryBody{typeName: "requestBulkRetryCreateRequestQueryBodyOne", RequestBulkRetryCreateRequestQueryBodyOne: value}
}

func (r *RequestBulkRetryCreateRequestQueryBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryBodyOne := new(RequestBulkRetryCreateRequestQueryBodyOne)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryBodyOne); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryBodyOne"
		r.RequestBulkRetryCreateRequestQueryBodyOne = valueRequestBulkRetryCreateRequestQueryBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryBody) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "requestBulkRetryCreateRequestQueryBodyOne":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryBodyOne)
	}
}

type RequestBulkRetryCreateRequestQueryBodyVisitor interface {
	VisitString(string) error
	VisitRequestBulkRetryCreateRequestQueryBodyOne(*RequestBulkRetryCreateRequestQueryBodyOne) error
}

func (r *RequestBulkRetryCreateRequestQueryBody) Accept(visitor RequestBulkRetryCreateRequestQueryBodyVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "requestBulkRetryCreateRequestQueryBodyOne":
		return visitor.VisitRequestBulkRetryCreateRequestQueryBodyOne(r.RequestBulkRetryCreateRequestQueryBodyOne)
	}
}

type RequestBulkRetryCreateRequestQueryBodyOne struct {
}

type RequestBulkRetryCreateRequestQueryBulkRetryId struct {
	typeName   string
	String     string
	StringList []string
}

func NewRequestBulkRetryCreateRequestQueryBulkRetryIdFromString(value string) *RequestBulkRetryCreateRequestQueryBulkRetryId {
	return &RequestBulkRetryCreateRequestQueryBulkRetryId{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryBulkRetryIdFromStringList(value []string) *RequestBulkRetryCreateRequestQueryBulkRetryId {
	return &RequestBulkRetryCreateRequestQueryBulkRetryId{typeName: "stringList", StringList: value}
}

func (r *RequestBulkRetryCreateRequestQueryBulkRetryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		r.typeName = "stringList"
		r.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryBulkRetryId) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "stringList":
		return json.Marshal(r.StringList)
	}
}

type RequestBulkRetryCreateRequestQueryBulkRetryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (r *RequestBulkRetryCreateRequestQueryBulkRetryId) Accept(visitor RequestBulkRetryCreateRequestQueryBulkRetryIdVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "stringList":
		return visitor.VisitStringList(r.StringList)
	}
}

// Filter by count of events
type RequestBulkRetryCreateRequestQueryEventsCount struct {
	typeName                                         string
	Integer                                          int
	RequestBulkRetryCreateRequestQueryEventsCountAll *RequestBulkRetryCreateRequestQueryEventsCountAll
	IntegerList                                      []int
}

func NewRequestBulkRetryCreateRequestQueryEventsCountFromInteger(value int) *RequestBulkRetryCreateRequestQueryEventsCount {
	return &RequestBulkRetryCreateRequestQueryEventsCount{typeName: "integer", Integer: value}
}

func NewRequestBulkRetryCreateRequestQueryEventsCountFromRequestBulkRetryCreateRequestQueryEventsCountAll(value *RequestBulkRetryCreateRequestQueryEventsCountAll) *RequestBulkRetryCreateRequestQueryEventsCount {
	return &RequestBulkRetryCreateRequestQueryEventsCount{typeName: "requestBulkRetryCreateRequestQueryEventsCountAll", RequestBulkRetryCreateRequestQueryEventsCountAll: value}
}

func NewRequestBulkRetryCreateRequestQueryEventsCountFromIntegerList(value []int) *RequestBulkRetryCreateRequestQueryEventsCount {
	return &RequestBulkRetryCreateRequestQueryEventsCount{typeName: "integerList", IntegerList: value}
}

func (r *RequestBulkRetryCreateRequestQueryEventsCount) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		r.typeName = "integer"
		r.Integer = valueInteger
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryEventsCountAll := new(RequestBulkRetryCreateRequestQueryEventsCountAll)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryEventsCountAll); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryEventsCountAll"
		r.RequestBulkRetryCreateRequestQueryEventsCountAll = valueRequestBulkRetryCreateRequestQueryEventsCountAll
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		r.typeName = "integerList"
		r.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryEventsCount) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return json.Marshal(r.Integer)
	case "requestBulkRetryCreateRequestQueryEventsCountAll":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryEventsCountAll)
	case "integerList":
		return json.Marshal(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryEventsCountVisitor interface {
	VisitInteger(int) error
	VisitRequestBulkRetryCreateRequestQueryEventsCountAll(*RequestBulkRetryCreateRequestQueryEventsCountAll) error
	VisitIntegerList([]int) error
}

func (r *RequestBulkRetryCreateRequestQueryEventsCount) Accept(visitor RequestBulkRetryCreateRequestQueryEventsCountVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return visitor.VisitInteger(r.Integer)
	case "requestBulkRetryCreateRequestQueryEventsCountAll":
		return visitor.VisitRequestBulkRetryCreateRequestQueryEventsCountAll(r.RequestBulkRetryCreateRequestQueryEventsCountAll)
	case "integerList":
		return visitor.VisitIntegerList(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryEventsCountAll struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	All      *bool `json:"all,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// URL Encoded string of the JSON to match to the data headers
type RequestBulkRetryCreateRequestQueryHeaders struct {
	typeName                                     string
	String                                       string
	RequestBulkRetryCreateRequestQueryHeadersOne *RequestBulkRetryCreateRequestQueryHeadersOne
}

func NewRequestBulkRetryCreateRequestQueryHeadersFromString(value string) *RequestBulkRetryCreateRequestQueryHeaders {
	return &RequestBulkRetryCreateRequestQueryHeaders{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryHeadersFromRequestBulkRetryCreateRequestQueryHeadersOne(value *RequestBulkRetryCreateRequestQueryHeadersOne) *RequestBulkRetryCreateRequestQueryHeaders {
	return &RequestBulkRetryCreateRequestQueryHeaders{typeName: "requestBulkRetryCreateRequestQueryHeadersOne", RequestBulkRetryCreateRequestQueryHeadersOne: value}
}

func (r *RequestBulkRetryCreateRequestQueryHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryHeadersOne := new(RequestBulkRetryCreateRequestQueryHeadersOne)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryHeadersOne); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryHeadersOne"
		r.RequestBulkRetryCreateRequestQueryHeadersOne = valueRequestBulkRetryCreateRequestQueryHeadersOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryHeaders) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "requestBulkRetryCreateRequestQueryHeadersOne":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryHeadersOne)
	}
}

type RequestBulkRetryCreateRequestQueryHeadersVisitor interface {
	VisitString(string) error
	VisitRequestBulkRetryCreateRequestQueryHeadersOne(*RequestBulkRetryCreateRequestQueryHeadersOne) error
}

func (r *RequestBulkRetryCreateRequestQueryHeaders) Accept(visitor RequestBulkRetryCreateRequestQueryHeadersVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "requestBulkRetryCreateRequestQueryHeadersOne":
		return visitor.VisitRequestBulkRetryCreateRequestQueryHeadersOne(r.RequestBulkRetryCreateRequestQueryHeadersOne)
	}
}

type RequestBulkRetryCreateRequestQueryHeadersOne struct {
}

// Filter by requests IDs
type RequestBulkRetryCreateRequestQueryId struct {
	typeName string
	// Request ID
	String     string
	StringList []string
}

func NewRequestBulkRetryCreateRequestQueryIdFromString(value string) *RequestBulkRetryCreateRequestQueryId {
	return &RequestBulkRetryCreateRequestQueryId{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryIdFromStringList(value []string) *RequestBulkRetryCreateRequestQueryId {
	return &RequestBulkRetryCreateRequestQueryId{typeName: "stringList", StringList: value}
}

func (r *RequestBulkRetryCreateRequestQueryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		r.typeName = "stringList"
		r.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryId) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "stringList":
		return json.Marshal(r.StringList)
	}
}

type RequestBulkRetryCreateRequestQueryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (r *RequestBulkRetryCreateRequestQueryId) Accept(visitor RequestBulkRetryCreateRequestQueryIdVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "stringList":
		return visitor.VisitStringList(r.StringList)
	}
}

// Filter by count of ignored events
type RequestBulkRetryCreateRequestQueryIgnoredCount struct {
	typeName                                          string
	Integer                                           int
	RequestBulkRetryCreateRequestQueryIgnoredCountAll *RequestBulkRetryCreateRequestQueryIgnoredCountAll
	IntegerList                                       []int
}

func NewRequestBulkRetryCreateRequestQueryIgnoredCountFromInteger(value int) *RequestBulkRetryCreateRequestQueryIgnoredCount {
	return &RequestBulkRetryCreateRequestQueryIgnoredCount{typeName: "integer", Integer: value}
}

func NewRequestBulkRetryCreateRequestQueryIgnoredCountFromRequestBulkRetryCreateRequestQueryIgnoredCountAll(value *RequestBulkRetryCreateRequestQueryIgnoredCountAll) *RequestBulkRetryCreateRequestQueryIgnoredCount {
	return &RequestBulkRetryCreateRequestQueryIgnoredCount{typeName: "requestBulkRetryCreateRequestQueryIgnoredCountAll", RequestBulkRetryCreateRequestQueryIgnoredCountAll: value}
}

func NewRequestBulkRetryCreateRequestQueryIgnoredCountFromIntegerList(value []int) *RequestBulkRetryCreateRequestQueryIgnoredCount {
	return &RequestBulkRetryCreateRequestQueryIgnoredCount{typeName: "integerList", IntegerList: value}
}

func (r *RequestBulkRetryCreateRequestQueryIgnoredCount) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		r.typeName = "integer"
		r.Integer = valueInteger
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryIgnoredCountAll := new(RequestBulkRetryCreateRequestQueryIgnoredCountAll)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryIgnoredCountAll); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryIgnoredCountAll"
		r.RequestBulkRetryCreateRequestQueryIgnoredCountAll = valueRequestBulkRetryCreateRequestQueryIgnoredCountAll
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		r.typeName = "integerList"
		r.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryIgnoredCount) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return json.Marshal(r.Integer)
	case "requestBulkRetryCreateRequestQueryIgnoredCountAll":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryIgnoredCountAll)
	case "integerList":
		return json.Marshal(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryIgnoredCountVisitor interface {
	VisitInteger(int) error
	VisitRequestBulkRetryCreateRequestQueryIgnoredCountAll(*RequestBulkRetryCreateRequestQueryIgnoredCountAll) error
	VisitIntegerList([]int) error
}

func (r *RequestBulkRetryCreateRequestQueryIgnoredCount) Accept(visitor RequestBulkRetryCreateRequestQueryIgnoredCountVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return visitor.VisitInteger(r.Integer)
	case "requestBulkRetryCreateRequestQueryIgnoredCountAll":
		return visitor.VisitRequestBulkRetryCreateRequestQueryIgnoredCountAll(r.RequestBulkRetryCreateRequestQueryIgnoredCountAll)
	case "integerList":
		return visitor.VisitIntegerList(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryIgnoredCountAll struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	All      *bool `json:"all,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// Filter by event ingested date
type RequestBulkRetryCreateRequestQueryIngestedAt struct {
	typeName                                        string
	DateTime                                        time.Time
	RequestBulkRetryCreateRequestQueryIngestedAtAny *RequestBulkRetryCreateRequestQueryIngestedAtAny
}

func NewRequestBulkRetryCreateRequestQueryIngestedAtFromDateTime(value time.Time) *RequestBulkRetryCreateRequestQueryIngestedAt {
	return &RequestBulkRetryCreateRequestQueryIngestedAt{typeName: "dateTime", DateTime: value}
}

func NewRequestBulkRetryCreateRequestQueryIngestedAtFromRequestBulkRetryCreateRequestQueryIngestedAtAny(value *RequestBulkRetryCreateRequestQueryIngestedAtAny) *RequestBulkRetryCreateRequestQueryIngestedAt {
	return &RequestBulkRetryCreateRequestQueryIngestedAt{typeName: "requestBulkRetryCreateRequestQueryIngestedAtAny", RequestBulkRetryCreateRequestQueryIngestedAtAny: value}
}

func (r *RequestBulkRetryCreateRequestQueryIngestedAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		r.typeName = "dateTime"
		r.DateTime = valueDateTime
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryIngestedAtAny := new(RequestBulkRetryCreateRequestQueryIngestedAtAny)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryIngestedAtAny); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryIngestedAtAny"
		r.RequestBulkRetryCreateRequestQueryIngestedAtAny = valueRequestBulkRetryCreateRequestQueryIngestedAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryIngestedAt) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "dateTime":
		return json.Marshal(r.DateTime)
	case "requestBulkRetryCreateRequestQueryIngestedAtAny":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryIngestedAtAny)
	}
}

type RequestBulkRetryCreateRequestQueryIngestedAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitRequestBulkRetryCreateRequestQueryIngestedAtAny(*RequestBulkRetryCreateRequestQueryIngestedAtAny) error
}

func (r *RequestBulkRetryCreateRequestQueryIngestedAt) Accept(visitor RequestBulkRetryCreateRequestQueryIngestedAtVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "dateTime":
		return visitor.VisitDateTime(r.DateTime)
	case "requestBulkRetryCreateRequestQueryIngestedAtAny":
		return visitor.VisitRequestBulkRetryCreateRequestQueryIngestedAtAny(r.RequestBulkRetryCreateRequestQueryIngestedAtAny)
	}
}

type RequestBulkRetryCreateRequestQueryIngestedAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
type RequestBulkRetryCreateRequestQueryParsedQuery struct {
	typeName                                         string
	String                                           string
	RequestBulkRetryCreateRequestQueryParsedQueryOne *RequestBulkRetryCreateRequestQueryParsedQueryOne
}

func NewRequestBulkRetryCreateRequestQueryParsedQueryFromString(value string) *RequestBulkRetryCreateRequestQueryParsedQuery {
	return &RequestBulkRetryCreateRequestQueryParsedQuery{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryParsedQueryFromRequestBulkRetryCreateRequestQueryParsedQueryOne(value *RequestBulkRetryCreateRequestQueryParsedQueryOne) *RequestBulkRetryCreateRequestQueryParsedQuery {
	return &RequestBulkRetryCreateRequestQueryParsedQuery{typeName: "requestBulkRetryCreateRequestQueryParsedQueryOne", RequestBulkRetryCreateRequestQueryParsedQueryOne: value}
}

func (r *RequestBulkRetryCreateRequestQueryParsedQuery) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryParsedQueryOne := new(RequestBulkRetryCreateRequestQueryParsedQueryOne)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryParsedQueryOne); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryParsedQueryOne"
		r.RequestBulkRetryCreateRequestQueryParsedQueryOne = valueRequestBulkRetryCreateRequestQueryParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryParsedQuery) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "requestBulkRetryCreateRequestQueryParsedQueryOne":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type RequestBulkRetryCreateRequestQueryParsedQueryVisitor interface {
	VisitString(string) error
	VisitRequestBulkRetryCreateRequestQueryParsedQueryOne(*RequestBulkRetryCreateRequestQueryParsedQueryOne) error
}

func (r *RequestBulkRetryCreateRequestQueryParsedQuery) Accept(visitor RequestBulkRetryCreateRequestQueryParsedQueryVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "requestBulkRetryCreateRequestQueryParsedQueryOne":
		return visitor.VisitRequestBulkRetryCreateRequestQueryParsedQueryOne(r.RequestBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type RequestBulkRetryCreateRequestQueryParsedQueryOne struct {
}

// Filter by rejection cause
type RequestBulkRetryCreateRequestQueryRejectionCause struct {
	typeName                  string
	RequestRejectionCause     RequestRejectionCause
	RequestRejectionCauseList []RequestRejectionCause
}

func NewRequestBulkRetryCreateRequestQueryRejectionCauseFromRequestRejectionCause(value RequestRejectionCause) *RequestBulkRetryCreateRequestQueryRejectionCause {
	return &RequestBulkRetryCreateRequestQueryRejectionCause{typeName: "requestRejectionCause", RequestRejectionCause: value}
}

func NewRequestBulkRetryCreateRequestQueryRejectionCauseFromRequestRejectionCauseList(value []RequestRejectionCause) *RequestBulkRetryCreateRequestQueryRejectionCause {
	return &RequestBulkRetryCreateRequestQueryRejectionCause{typeName: "requestRejectionCauseList", RequestRejectionCauseList: value}
}

func (r *RequestBulkRetryCreateRequestQueryRejectionCause) UnmarshalJSON(data []byte) error {
	var valueRequestRejectionCause RequestRejectionCause
	if err := json.Unmarshal(data, &valueRequestRejectionCause); err == nil {
		r.typeName = "requestRejectionCause"
		r.RequestRejectionCause = valueRequestRejectionCause
		return nil
	}
	var valueRequestRejectionCauseList []RequestRejectionCause
	if err := json.Unmarshal(data, &valueRequestRejectionCauseList); err == nil {
		r.typeName = "requestRejectionCauseList"
		r.RequestRejectionCauseList = valueRequestRejectionCauseList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryRejectionCause) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "requestRejectionCause":
		return json.Marshal(r.RequestRejectionCause)
	case "requestRejectionCauseList":
		return json.Marshal(r.RequestRejectionCauseList)
	}
}

type RequestBulkRetryCreateRequestQueryRejectionCauseVisitor interface {
	VisitRequestRejectionCause(RequestRejectionCause) error
	VisitRequestRejectionCauseList([]RequestRejectionCause) error
}

func (r *RequestBulkRetryCreateRequestQueryRejectionCause) Accept(visitor RequestBulkRetryCreateRequestQueryRejectionCauseVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "requestRejectionCause":
		return visitor.VisitRequestRejectionCause(r.RequestRejectionCause)
	case "requestRejectionCauseList":
		return visitor.VisitRequestRejectionCauseList(r.RequestRejectionCauseList)
	}
}

// Filter by source IDs
type RequestBulkRetryCreateRequestQuerySourceId struct {
	typeName string
	// Source ID
	String     string
	StringList []string
}

func NewRequestBulkRetryCreateRequestQuerySourceIdFromString(value string) *RequestBulkRetryCreateRequestQuerySourceId {
	return &RequestBulkRetryCreateRequestQuerySourceId{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQuerySourceIdFromStringList(value []string) *RequestBulkRetryCreateRequestQuerySourceId {
	return &RequestBulkRetryCreateRequestQuerySourceId{typeName: "stringList", StringList: value}
}

func (r *RequestBulkRetryCreateRequestQuerySourceId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		r.typeName = "stringList"
		r.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQuerySourceId) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "stringList":
		return json.Marshal(r.StringList)
	}
}

type RequestBulkRetryCreateRequestQuerySourceIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (r *RequestBulkRetryCreateRequestQuerySourceId) Accept(visitor RequestBulkRetryCreateRequestQuerySourceIdVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "stringList":
		return visitor.VisitStringList(r.StringList)
	}
}

// Filter by status
type RequestBulkRetryCreateRequestQueryStatus string

const (
	RequestBulkRetryCreateRequestQueryStatusAccepted RequestBulkRetryCreateRequestQueryStatus = "accepted"
	RequestBulkRetryCreateRequestQueryStatusRejected RequestBulkRetryCreateRequestQueryStatus = "rejected"
)

func NewRequestBulkRetryCreateRequestQueryStatusFromString(s string) (RequestBulkRetryCreateRequestQueryStatus, error) {
	switch s {
	case "accepted":
		return RequestBulkRetryCreateRequestQueryStatusAccepted, nil
	case "rejected":
		return RequestBulkRetryCreateRequestQueryStatusRejected, nil
	}
	var t RequestBulkRetryCreateRequestQueryStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestBulkRetryCreateRequestQueryStatus) Ptr() *RequestBulkRetryCreateRequestQueryStatus {
	return &r
}

// Body of the request
type TransformationRunRequestRequestBody struct {
	typeName                                string
	TransformationRunRequestRequestBodyZero *TransformationRunRequestRequestBodyZero
	String                                  string
}

func NewTransformationRunRequestRequestBodyFromTransformationRunRequestRequestBodyZero(value *TransformationRunRequestRequestBodyZero) *TransformationRunRequestRequestBody {
	return &TransformationRunRequestRequestBody{typeName: "transformationRunRequestRequestBodyZero", TransformationRunRequestRequestBodyZero: value}
}

func NewTransformationRunRequestRequestBodyFromString(value string) *TransformationRunRequestRequestBody {
	return &TransformationRunRequestRequestBody{typeName: "string", String: value}
}

func (t *TransformationRunRequestRequestBody) UnmarshalJSON(data []byte) error {
	valueTransformationRunRequestRequestBodyZero := new(TransformationRunRequestRequestBodyZero)
	if err := json.Unmarshal(data, &valueTransformationRunRequestRequestBodyZero); err == nil {
		t.typeName = "transformationRunRequestRequestBodyZero"
		t.TransformationRunRequestRequestBodyZero = valueTransformationRunRequestRequestBodyZero
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationRunRequestRequestBody) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationRunRequestRequestBodyZero":
		return json.Marshal(t.TransformationRunRequestRequestBodyZero)
	case "string":
		return json.Marshal(t.String)
	}
}

type TransformationRunRequestRequestBodyVisitor interface {
	VisitTransformationRunRequestRequestBodyZero(*TransformationRunRequestRequestBodyZero) error
	VisitString(string) error
}

func (t *TransformationRunRequestRequestBody) Accept(visitor TransformationRunRequestRequestBodyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationRunRequestRequestBodyZero":
		return visitor.VisitTransformationRunRequestRequestBodyZero(t.TransformationRunRequestRequestBodyZero)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TransformationRunRequestRequestBodyZero struct {
}

// JSON representation of the query params
type TransformationRunRequestRequestParsedQuery struct {
}
