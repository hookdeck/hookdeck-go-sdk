// This file was auto-generated by Fern from our API Definition.

package api

import (
	json "encoding/json"
	fmt "fmt"
	time "time"
)

type AddCustomHostname struct {
	// The custom hostname to attach to the workspace
	Hostname string `json:"hostname"`
}

// Error response model
type ApiErrorResponse struct {
	// Error code
	Code string `json:"code"`
	// Status code
	Status float64 `json:"status"`
	// Error description
	Message string                `json:"message"`
	Data    *ApiErrorResponseData `json:"data,omitempty"`
}

type ApiErrorResponseData struct {
}

type ApiKeyIntegrationConfigs struct {
	HeaderKey string `json:"header_key"`
	ApiKey    string `json:"api_key"`
}

type AttachedIntegrationToSource struct {
	Success bool `json:"success"`
}

// Error code of the delivery attempt
type AttemptErrorCodes string

const (
	AttemptErrorCodesCancelled                AttemptErrorCodes = "CANCELLED"
	AttemptErrorCodesTimeout                  AttemptErrorCodes = "TIMEOUT"
	AttemptErrorCodesNotFound                 AttemptErrorCodes = "NOT_FOUND"
	AttemptErrorCodesConnectionRefused        AttemptErrorCodes = "CONNECTION_REFUSED"
	AttemptErrorCodesConnectionReset          AttemptErrorCodes = "CONNECTION_RESET"
	AttemptErrorCodesMissingUrl               AttemptErrorCodes = "MISSING_URL"
	AttemptErrorCodesCli                      AttemptErrorCodes = "CLI"
	AttemptErrorCodesCliUnavailable           AttemptErrorCodes = "CLI_UNAVAILABLE"
	AttemptErrorCodesSelfSignedCert           AttemptErrorCodes = "SELF_SIGNED_CERT"
	AttemptErrorCodesErrTlsCertAltnameInvalid AttemptErrorCodes = "ERR_TLS_CERT_ALTNAME_INVALID"
	AttemptErrorCodesSslErrorCaUnknown        AttemptErrorCodes = "SSL_ERROR_CA_UNKNOWN"
	AttemptErrorCodesTtlExpired               AttemptErrorCodes = "TTL_EXPIRED"
	AttemptErrorCodesDataArchived             AttemptErrorCodes = "DATA_ARCHIVED"
	AttemptErrorCodesSslCertExpired           AttemptErrorCodes = "SSL_CERT_EXPIRED"
	AttemptErrorCodesBulkRetryCancelled       AttemptErrorCodes = "BULK_RETRY_CANCELLED"
	AttemptErrorCodesDnsLookupFailed          AttemptErrorCodes = "DNS_LOOKUP_FAILED"
	AttemptErrorCodesHostUnreachable          AttemptErrorCodes = "HOST_UNREACHABLE"
	AttemptErrorCodesProtocolError            AttemptErrorCodes = "PROTOCOL_ERROR"
	AttemptErrorCodesSocketClosed             AttemptErrorCodes = "SOCKET_CLOSED"
	AttemptErrorCodesUnknown                  AttemptErrorCodes = "UNKNOWN"
)

func NewAttemptErrorCodesFromString(s string) (AttemptErrorCodes, error) {
	switch s {
	case "CANCELLED":
		return AttemptErrorCodesCancelled, nil
	case "TIMEOUT":
		return AttemptErrorCodesTimeout, nil
	case "NOT_FOUND":
		return AttemptErrorCodesNotFound, nil
	case "CONNECTION_REFUSED":
		return AttemptErrorCodesConnectionRefused, nil
	case "CONNECTION_RESET":
		return AttemptErrorCodesConnectionReset, nil
	case "MISSING_URL":
		return AttemptErrorCodesMissingUrl, nil
	case "CLI":
		return AttemptErrorCodesCli, nil
	case "CLI_UNAVAILABLE":
		return AttemptErrorCodesCliUnavailable, nil
	case "SELF_SIGNED_CERT":
		return AttemptErrorCodesSelfSignedCert, nil
	case "ERR_TLS_CERT_ALTNAME_INVALID":
		return AttemptErrorCodesErrTlsCertAltnameInvalid, nil
	case "SSL_ERROR_CA_UNKNOWN":
		return AttemptErrorCodesSslErrorCaUnknown, nil
	case "TTL_EXPIRED":
		return AttemptErrorCodesTtlExpired, nil
	case "DATA_ARCHIVED":
		return AttemptErrorCodesDataArchived, nil
	case "SSL_CERT_EXPIRED":
		return AttemptErrorCodesSslCertExpired, nil
	case "BULK_RETRY_CANCELLED":
		return AttemptErrorCodesBulkRetryCancelled, nil
	case "DNS_LOOKUP_FAILED":
		return AttemptErrorCodesDnsLookupFailed, nil
	case "HOST_UNREACHABLE":
		return AttemptErrorCodesHostUnreachable, nil
	case "PROTOCOL_ERROR":
		return AttemptErrorCodesProtocolError, nil
	case "SOCKET_CLOSED":
		return AttemptErrorCodesSocketClosed, nil
	case "UNKNOWN":
		return AttemptErrorCodesUnknown, nil
	}
	var t AttemptErrorCodes
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptErrorCodes) Ptr() *AttemptErrorCodes {
	return &a
}

type AttemptListRequestDir string

const (
	AttemptListRequestDirAsc  AttemptListRequestDir = "asc"
	AttemptListRequestDirDesc AttemptListRequestDir = "desc"
)

func NewAttemptListRequestDirFromString(s string) (AttemptListRequestDir, error) {
	switch s {
	case "asc":
		return AttemptListRequestDirAsc, nil
	case "desc":
		return AttemptListRequestDirDesc, nil
	}
	var t AttemptListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptListRequestDir) Ptr() *AttemptListRequestDir {
	return &a
}

type AttemptState string

const (
	AttemptStateDelivering AttemptState = "DELIVERING"
	AttemptStateQueued     AttemptState = "QUEUED"
	AttemptStatePending    AttemptState = "PENDING"
	AttemptStateCompleted  AttemptState = "COMPLETED"
	AttemptStateHold       AttemptState = "HOLD"
)

func NewAttemptStateFromString(s string) (AttemptState, error) {
	switch s {
	case "DELIVERING":
		return AttemptStateDelivering, nil
	case "QUEUED":
		return AttemptStateQueued, nil
	case "PENDING":
		return AttemptStatePending, nil
	case "COMPLETED":
		return AttemptStateCompleted, nil
	case "HOLD":
		return AttemptStateHold, nil
	}
	var t AttemptState
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptState) Ptr() *AttemptState {
	return &a
}

// Attempt status
type AttemptStatus string

const (
	AttemptStatusQueued     AttemptStatus = "QUEUED"
	AttemptStatusFailed     AttemptStatus = "FAILED"
	AttemptStatusSuccessful AttemptStatus = "SUCCESSFUL"
	AttemptStatusHold       AttemptStatus = "HOLD"
)

func NewAttemptStatusFromString(s string) (AttemptStatus, error) {
	switch s {
	case "QUEUED":
		return AttemptStatusQueued, nil
	case "FAILED":
		return AttemptStatusFailed, nil
	case "SUCCESSFUL":
		return AttemptStatusSuccessful, nil
	case "HOLD":
		return AttemptStatusHold, nil
	}
	var t AttemptStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptStatus) Ptr() *AttemptStatus {
	return &a
}

// How the attempt was triggered
type AttemptTrigger string

const (
	AttemptTriggerInitial   AttemptTrigger = "INITIAL"
	AttemptTriggerManual    AttemptTrigger = "MANUAL"
	AttemptTriggerBulkRetry AttemptTrigger = "BULK_RETRY"
	AttemptTriggerUnpause   AttemptTrigger = "UNPAUSE"
	AttemptTriggerAutomatic AttemptTrigger = "AUTOMATIC"
)

func NewAttemptTriggerFromString(s string) (AttemptTrigger, error) {
	switch s {
	case "INITIAL":
		return AttemptTriggerInitial, nil
	case "MANUAL":
		return AttemptTriggerManual, nil
	case "BULK_RETRY":
		return AttemptTriggerBulkRetry, nil
	case "UNPAUSE":
		return AttemptTriggerUnpause, nil
	case "AUTOMATIC":
		return AttemptTriggerAutomatic, nil
	}
	var t AttemptTrigger
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (a AttemptTrigger) Ptr() *AttemptTrigger {
	return &a
}

// API Key
type AuthApiKey struct {
	Config *DestinationAuthMethodApiKeyConfig `json:"config,omitempty"`
}

// Basic Auth
type AuthBasicAuth struct {
	Config *DestinationAuthMethodBasicAuthConfig `json:"config,omitempty"`
}

// Bearer Token
type AuthBearerToken struct {
	Config *DestinationAuthMethodBearerTokenConfig `json:"config,omitempty"`
}

// Custom Signature
type AuthCustomSignature struct {
	Config *DestinationAuthMethodCustomSignatureConfig `json:"config,omitempty"`
}

// Hookdeck Signature
type AuthHookdeckSignature struct {
	Config *DestinationAuthMethodSignatureConfig `json:"config,omitempty"`
}

type BasicAuthIntegrationConfigs struct {
	Name     string `json:"name"`
	Password string `json:"password"`
}

type BatchOperation struct {
	// ID of the bulk retry
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// Query object to filter records
	Query *BatchOperationQuery `json:"query,omitempty"`
	// Date the bulk retry was created
	CreatedAt time.Time `json:"created_at"`
	// Last time the bulk retry was updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the bulk retry was cancelled
	CancelledAt *time.Time `json:"cancelled_at,omitempty"`
	// Date the bulk retry was completed
	CompletedAt *time.Time `json:"completed_at,omitempty"`
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Number of batches currently processed
	ProcessedBatch *int `json:"processed_batch,omitempty"`
	// Number of events that were successfully delivered
	CompletedCount *int `json:"completed_count,omitempty"`
	// Indicates if the bulk retry is currently in progress
	InProgress bool `json:"in_progress"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
	// Number of events that failed to be delivered
	FailedCount *int     `json:"failed_count,omitempty"`
	Number      *float64 `json:"number,omitempty"`
}

type BatchOperationPaginatedResult struct {
	Pagination *SeekPagination   `json:"pagination,omitempty"`
	Count      *int              `json:"count,omitempty"`
	Models     []*BatchOperation `json:"models,omitempty"`
}

// Query object to filter records
type BatchOperationQuery struct {
	typeName         string
	StringUnknownMap map[string]interface{}
	StringOptional   *string
}

func NewBatchOperationQueryFromStringUnknownMap(value map[string]interface{}) *BatchOperationQuery {
	return &BatchOperationQuery{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func NewBatchOperationQueryFromStringOptional(value *string) *BatchOperationQuery {
	return &BatchOperationQuery{typeName: "stringOptional", StringOptional: value}
}

func (b *BatchOperationQuery) UnmarshalJSON(data []byte) error {
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		b.typeName = "stringUnknownMap"
		b.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		b.typeName = "stringOptional"
		b.StringOptional = valueStringOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, b)
}

func (b BatchOperationQuery) MarshalJSON() ([]byte, error) {
	switch b.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "stringUnknownMap":
		return json.Marshal(b.StringUnknownMap)
	case "stringOptional":
		return json.Marshal(b.StringOptional)
	}
}

type BatchOperationQueryVisitor interface {
	VisitStringUnknownMap(map[string]interface{}) error
	VisitStringOptional(*string) error
}

func (b *BatchOperationQuery) Accept(visitor BatchOperationQueryVisitor) error {
	switch b.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", b.typeName, b)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(b.StringUnknownMap)
	case "stringOptional":
		return visitor.VisitStringOptional(b.StringOptional)
	}
}

type Bookmark struct {
	// ID of the bookmark
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// ID of the associated connection
	WebhookId string `json:"webhook_id"`
	// ID of the bookmarked event data
	EventDataId string `json:"event_data_id"`
	// Descriptive name of the bookmark
	Label string `json:"label"`
	// Alternate alias for the bookmark
	Alias *string         `json:"alias,omitempty"`
	Data  *ShortEventData `json:"data,omitempty"`
	// Date the bookmark was last manually triggered
	LastUsedAt *time.Time `json:"last_used_at,omitempty"`
	// Date the bookmark was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the bookmark was created
	CreatedAt time.Time `json:"created_at"`
}

type BookmarkListRequestDir string

const (
	BookmarkListRequestDirAsc  BookmarkListRequestDir = "asc"
	BookmarkListRequestDirDesc BookmarkListRequestDir = "desc"
)

func NewBookmarkListRequestDirFromString(s string) (BookmarkListRequestDir, error) {
	switch s {
	case "asc":
		return BookmarkListRequestDirAsc, nil
	case "desc":
		return BookmarkListRequestDirDesc, nil
	}
	var t BookmarkListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BookmarkListRequestDir) Ptr() *BookmarkListRequestDir {
	return &b
}

type BookmarkPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Bookmark     `json:"models,omitempty"`
}

// Bookmark target
type BookmarkTriggerRequestTarget string

const (
	BookmarkTriggerRequestTargetHttp BookmarkTriggerRequestTarget = "http"
	BookmarkTriggerRequestTargetCli  BookmarkTriggerRequestTarget = "cli"
)

func NewBookmarkTriggerRequestTargetFromString(s string) (BookmarkTriggerRequestTarget, error) {
	switch s {
	case "http":
		return BookmarkTriggerRequestTargetHttp, nil
	case "cli":
		return BookmarkTriggerRequestTargetCli, nil
	}
	var t BookmarkTriggerRequestTarget
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (b BookmarkTriggerRequestTarget) Ptr() *BookmarkTriggerRequestTarget {
	return &b
}

type Connection struct {
	// ID of the connection
	Id string `json:"id"`
	// Unique name of the connection for this source
	Name *string `json:"name,omitempty"`
	// Full name of the connection concatenated from source, connection and desitnation name
	FullName *string `json:"full_name,omitempty"`
	// Description of the connection
	Description *string `json:"description,omitempty"`
	// ID of the workspace
	TeamId      string       `json:"team_id"`
	Destination *Destination `json:"destination,omitempty"`
	Source      *Source      `json:"source,omitempty"`
	// Array of rules configured on the connection
	Rules []*Rule `json:"rules,omitempty"`
	// Date the connection was archived
	ArchivedAt *time.Time `json:"archived_at,omitempty"`
	// Date the connection was paused
	PausedAt *time.Time `json:"paused_at,omitempty"`
	// Date the connection was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the connection was created
	CreatedAt time.Time `json:"created_at"`
}

// Destination input object
type ConnectionCreateRequestDestination struct {
	// Name for the destination <span style="white-space: nowrap">`<= 155 characters`</span>
	Name string `json:"name"`
	// Description for the destination
	Description *string `json:"description,omitempty"`
	// Endpoint of the destination
	Url *string `json:"url,omitempty"`
	// Path for the CLI destination
	CliPath *string `json:"cli_path,omitempty"`
	// Period to rate limit attempts
	RateLimitPeriod *ConnectionCreateRequestDestinationRateLimitPeriod `json:"rate_limit_period,omitempty"`
	// Limit event attempts to receive per period
	RateLimit              *int                         `json:"rate_limit,omitempty"`
	HttpMethod             *DestinationHttpMethod       `json:"http_method,omitempty"`
	AuthMethod             *DestinationAuthMethodConfig `json:"auth_method,omitempty"`
	PathForwardingDisabled *bool                        `json:"path_forwarding_disabled,omitempty"`
}

// Period to rate limit attempts
type ConnectionCreateRequestDestinationRateLimitPeriod string

const (
	ConnectionCreateRequestDestinationRateLimitPeriodSecond ConnectionCreateRequestDestinationRateLimitPeriod = "second"
	ConnectionCreateRequestDestinationRateLimitPeriodMinute ConnectionCreateRequestDestinationRateLimitPeriod = "minute"
	ConnectionCreateRequestDestinationRateLimitPeriodHour   ConnectionCreateRequestDestinationRateLimitPeriod = "hour"
)

func NewConnectionCreateRequestDestinationRateLimitPeriodFromString(s string) (ConnectionCreateRequestDestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return ConnectionCreateRequestDestinationRateLimitPeriodSecond, nil
	case "minute":
		return ConnectionCreateRequestDestinationRateLimitPeriodMinute, nil
	case "hour":
		return ConnectionCreateRequestDestinationRateLimitPeriodHour, nil
	}
	var t ConnectionCreateRequestDestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionCreateRequestDestinationRateLimitPeriod) Ptr() *ConnectionCreateRequestDestinationRateLimitPeriod {
	return &c
}

// Source input object
type ConnectionCreateRequestSource struct {
	// A unique name for the source <span style="white-space: nowrap">`<= 155 characters`</span>
	Name string `json:"name"`
	// Description for the source
	Description        *string                  `json:"description,omitempty"`
	AllowedHttpMethods *SourceAllowedHttpMethod `json:"allowed_http_methods,omitempty"`
	CustomResponse     *SourceCustomResponse    `json:"custom_response,omitempty"`
	Verification       *VerificationConfig      `json:"verification,omitempty"`
}

type ConnectionDeleteResponse struct {
	// ID of the connection
	Id string `json:"id"`
}

type ConnectionListRequestDir string

const (
	ConnectionListRequestDirAsc  ConnectionListRequestDir = "asc"
	ConnectionListRequestDirDesc ConnectionListRequestDir = "desc"
)

func NewConnectionListRequestDirFromString(s string) (ConnectionListRequestDir, error) {
	switch s {
	case "asc":
		return ConnectionListRequestDirAsc, nil
	case "desc":
		return ConnectionListRequestDirDesc, nil
	}
	var t ConnectionListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionListRequestDir) Ptr() *ConnectionListRequestDir {
	return &c
}

type ConnectionListRequestOrderBy string

const (
	ConnectionListRequestOrderByCreatedAt             ConnectionListRequestOrderBy = "created_at"
	ConnectionListRequestOrderByUpdatedAt             ConnectionListRequestOrderBy = "updated_at"
	ConnectionListRequestOrderBySourcesUpdatedAt      ConnectionListRequestOrderBy = "sources.updated_at"
	ConnectionListRequestOrderBySourcesCreatedAt      ConnectionListRequestOrderBy = "sources.created_at"
	ConnectionListRequestOrderByDestinationsUpdatedAt ConnectionListRequestOrderBy = "destinations.updated_at"
	ConnectionListRequestOrderByDestinationsCreatedAt ConnectionListRequestOrderBy = "destinations.created_at"
)

func NewConnectionListRequestOrderByFromString(s string) (ConnectionListRequestOrderBy, error) {
	switch s {
	case "created_at":
		return ConnectionListRequestOrderByCreatedAt, nil
	case "updated_at":
		return ConnectionListRequestOrderByUpdatedAt, nil
	case "sources.updated_at":
		return ConnectionListRequestOrderBySourcesUpdatedAt, nil
	case "sources.created_at":
		return ConnectionListRequestOrderBySourcesCreatedAt, nil
	case "destinations.updated_at":
		return ConnectionListRequestOrderByDestinationsUpdatedAt, nil
	case "destinations.created_at":
		return ConnectionListRequestOrderByDestinationsCreatedAt, nil
	}
	var t ConnectionListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionListRequestOrderBy) Ptr() *ConnectionListRequestOrderBy {
	return &c
}

type ConnectionPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Connection   `json:"models,omitempty"`
}

// Destination input object
type ConnectionUpsertRequestDestination struct {
	// Name for the destination <span style="white-space: nowrap">`<= 155 characters`</span>
	Name string `json:"name"`
	// Description for the destination
	Description *string `json:"description,omitempty"`
	// Endpoint of the destination
	Url *string `json:"url,omitempty"`
	// Path for the CLI destination
	CliPath *string `json:"cli_path,omitempty"`
	// Period to rate limit attempts
	RateLimitPeriod *ConnectionUpsertRequestDestinationRateLimitPeriod `json:"rate_limit_period,omitempty"`
	// Limit event attempts to receive per period
	RateLimit              *int                         `json:"rate_limit,omitempty"`
	HttpMethod             *DestinationHttpMethod       `json:"http_method,omitempty"`
	AuthMethod             *DestinationAuthMethodConfig `json:"auth_method,omitempty"`
	PathForwardingDisabled *bool                        `json:"path_forwarding_disabled,omitempty"`
}

// Period to rate limit attempts
type ConnectionUpsertRequestDestinationRateLimitPeriod string

const (
	ConnectionUpsertRequestDestinationRateLimitPeriodSecond ConnectionUpsertRequestDestinationRateLimitPeriod = "second"
	ConnectionUpsertRequestDestinationRateLimitPeriodMinute ConnectionUpsertRequestDestinationRateLimitPeriod = "minute"
	ConnectionUpsertRequestDestinationRateLimitPeriodHour   ConnectionUpsertRequestDestinationRateLimitPeriod = "hour"
)

func NewConnectionUpsertRequestDestinationRateLimitPeriodFromString(s string) (ConnectionUpsertRequestDestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return ConnectionUpsertRequestDestinationRateLimitPeriodSecond, nil
	case "minute":
		return ConnectionUpsertRequestDestinationRateLimitPeriodMinute, nil
	case "hour":
		return ConnectionUpsertRequestDestinationRateLimitPeriodHour, nil
	}
	var t ConnectionUpsertRequestDestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConnectionUpsertRequestDestinationRateLimitPeriod) Ptr() *ConnectionUpsertRequestDestinationRateLimitPeriod {
	return &c
}

// Source input object
type ConnectionUpsertRequestSource struct {
	// A unique name for the source <span style="white-space: nowrap">`<= 155 characters`</span>
	Name string `json:"name"`
	// Description for the source
	Description        *string                  `json:"description,omitempty"`
	AllowedHttpMethods *SourceAllowedHttpMethod `json:"allowed_http_methods,omitempty"`
	CustomResponse     *SourceCustomResponse    `json:"custom_response,omitempty"`
	Verification       *VerificationConfig      `json:"verification,omitempty"`
}

type ConsoleLine struct {
	Type    ConsoleLineType `json:"type,omitempty"`
	Message string          `json:"message"`
}

type ConsoleLineType string

const (
	ConsoleLineTypeError ConsoleLineType = "error"
	ConsoleLineTypeLog   ConsoleLineType = "log"
	ConsoleLineTypeWarn  ConsoleLineType = "warn"
	ConsoleLineTypeInfo  ConsoleLineType = "info"
	ConsoleLineTypeDebug ConsoleLineType = "debug"
)

func NewConsoleLineTypeFromString(s string) (ConsoleLineType, error) {
	switch s {
	case "error":
		return ConsoleLineTypeError, nil
	case "log":
		return ConsoleLineTypeLog, nil
	case "warn":
		return ConsoleLineTypeWarn, nil
	case "info":
		return ConsoleLineTypeInfo, nil
	case "debug":
		return ConsoleLineTypeDebug, nil
	}
	var t ConsoleLineType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (c ConsoleLineType) Ptr() *ConsoleLineType {
	return &c
}

type DelayRule struct {
	// Delay to introduce in MS
	Delay int `json:"delay"`
	type_ string
}

func (d *DelayRule) Type() string {
	return d.type_
}

func (d *DelayRule) UnmarshalJSON(data []byte) error {
	type unmarshaler DelayRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*d = DelayRule(value)
	d.type_ = "delay"
	return nil
}

func (d *DelayRule) MarshalJSON() ([]byte, error) {
	type embed DelayRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*d),
		Type:  "delay",
	}
	return json.Marshal(marshaler)
}

type DeleteCustomDomainSchema struct {
	// The custom hostname ID
	Id string `json:"id"`
}

type DeletedBookmarkResponse struct {
	// Bookmark ID
	Id string `json:"id"`
}

type DeletedIntegration struct {
	Id string `json:"id"`
}

type DeletedIssueTriggerResponse struct {
	Id string `json:"id"`
}

// Delivery issue
type DeliveryIssue struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// ID of the team member who last updated the issue status
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                        `json:"created_at"`
	AggregationKeys *DeliveryIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *DeliveryIssueReference       `json:"reference,omitempty"`
}

// Keys used as the aggregation keys a 'delivery' type issue
type DeliveryIssueAggregationKeys struct {
	WebhookId      []string            `json:"webhook_id,omitempty"`
	ResponseStatus []float64           `json:"response_status,omitempty"`
	ErrorCode      []AttemptErrorCodes `json:"error_code,omitempty"`
}

// Delivery issue data
type DeliveryIssueData struct {
	TriggerEvent   *Event        `json:"trigger_event,omitempty"`
	TriggerAttempt *EventAttempt `json:"trigger_attempt,omitempty"`
}

// Reference to the event and attempt an issue is being created for.
type DeliveryIssueReference struct {
	EventId   string `json:"event_id"`
	AttemptId string `json:"attempt_id"`
}

// Delivery issue
type DeliveryIssueWithData struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// ID of the team member who last updated the issue status
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                        `json:"created_at"`
	AggregationKeys *DeliveryIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *DeliveryIssueReference       `json:"reference,omitempty"`
	Data            *DeliveryIssueData            `json:"data,omitempty"`
}

// Associated [Destination](#destination-object) object
type Destination struct {
	// ID of the destination
	Id string `json:"id"`
	// A unique, human-friendly name for the destination
	Name string `json:"name"`
	// Description of the destination
	Description *string `json:"description,omitempty"`
	// ID of the workspace
	TeamId                 string `json:"team_id"`
	PathForwardingDisabled *bool  `json:"path_forwarding_disabled,omitempty"`
	// HTTP endpoint of the destination
	Url *string `json:"url,omitempty"`
	// Path for the CLI destination
	CliPath *string `json:"cli_path,omitempty"`
	// Limit event attempts to receive per period. Max value is workspace plan's max attempts thoughput.
	RateLimit       *int                         `json:"rate_limit,omitempty"`
	RateLimitPeriod *DestinationRateLimitPeriod  `json:"rate_limit_period,omitempty"`
	HttpMethod      *DestinationHttpMethod       `json:"http_method,omitempty"`
	AuthMethod      *DestinationAuthMethodConfig `json:"auth_method,omitempty"`
	// Date the destination was archived
	ArchivedAt *time.Time `json:"archived_at,omitempty"`
	// Date the destination was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the destination was created
	CreatedAt time.Time `json:"created_at"`
}

// API key config for the destination's auth method
type DestinationAuthMethodApiKeyConfig struct {
	// Key for the API key auth
	Key string `json:"key"`
	// API key for the API key auth
	ApiKey string `json:"api_key"`
	// Whether the API key should be sent as a header or a query parameter
	To *DestinationAuthMethodApiKeyConfigTo `json:"to,omitempty"`
}

// Whether the API key should be sent as a header or a query parameter
type DestinationAuthMethodApiKeyConfigTo string

const (
	DestinationAuthMethodApiKeyConfigToHeader DestinationAuthMethodApiKeyConfigTo = "header"
	DestinationAuthMethodApiKeyConfigToQuery  DestinationAuthMethodApiKeyConfigTo = "query"
)

func NewDestinationAuthMethodApiKeyConfigToFromString(s string) (DestinationAuthMethodApiKeyConfigTo, error) {
	switch s {
	case "header":
		return DestinationAuthMethodApiKeyConfigToHeader, nil
	case "query":
		return DestinationAuthMethodApiKeyConfigToQuery, nil
	}
	var t DestinationAuthMethodApiKeyConfigTo
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationAuthMethodApiKeyConfigTo) Ptr() *DestinationAuthMethodApiKeyConfigTo {
	return &d
}

// Basic auth config for the destination's auth method
type DestinationAuthMethodBasicAuthConfig struct {
	// Username for basic auth
	Username string `json:"username"`
	// Password for basic auth
	Password string `json:"password"`
}

// Bearer token config for the destination's auth method
type DestinationAuthMethodBearerTokenConfig struct {
	// Token for the bearer token auth
	Token string `json:"token"`
}

// Config for the destination's auth method
type DestinationAuthMethodConfig struct {
	Type              string
	HookdeckSignature *AuthHookdeckSignature
	BasicAuth         *AuthBasicAuth
	ApiKey            *AuthApiKey
	BearerToken       *AuthBearerToken
	CustomSignature   *AuthCustomSignature
}

func NewDestinationAuthMethodConfigFromHookdeckSignature(value *AuthHookdeckSignature) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "HOOKDECK_SIGNATURE", HookdeckSignature: value}
}

func NewDestinationAuthMethodConfigFromBasicAuth(value *AuthBasicAuth) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "BASIC_AUTH", BasicAuth: value}
}

func NewDestinationAuthMethodConfigFromApiKey(value *AuthApiKey) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "API_KEY", ApiKey: value}
}

func NewDestinationAuthMethodConfigFromBearerToken(value *AuthBearerToken) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "BEARER_TOKEN", BearerToken: value}
}

func NewDestinationAuthMethodConfigFromCustomSignature(value *AuthCustomSignature) *DestinationAuthMethodConfig {
	return &DestinationAuthMethodConfig{Type: "CUSTOM_SIGNATURE", CustomSignature: value}
}

func (d *DestinationAuthMethodConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	d.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "HOOKDECK_SIGNATURE":
		value := new(AuthHookdeckSignature)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.HookdeckSignature = value
	case "BASIC_AUTH":
		value := new(AuthBasicAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.BasicAuth = value
	case "API_KEY":
		value := new(AuthApiKey)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.ApiKey = value
	case "BEARER_TOKEN":
		value := new(AuthBearerToken)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.BearerToken = value
	case "CUSTOM_SIGNATURE":
		value := new(AuthCustomSignature)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		d.CustomSignature = value
	}
	return nil
}

func (d DestinationAuthMethodConfig) MarshalJSON() ([]byte, error) {
	switch d.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", d.Type, d)
	case "HOOKDECK_SIGNATURE":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthHookdeckSignature
		}{
			Type:                  d.Type,
			AuthHookdeckSignature: d.HookdeckSignature,
		}
		return json.Marshal(marshaler)
	case "BASIC_AUTH":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthBasicAuth
		}{
			Type:          d.Type,
			AuthBasicAuth: d.BasicAuth,
		}
		return json.Marshal(marshaler)
	case "API_KEY":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthApiKey
		}{
			Type:       d.Type,
			AuthApiKey: d.ApiKey,
		}
		return json.Marshal(marshaler)
	case "BEARER_TOKEN":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthBearerToken
		}{
			Type:            d.Type,
			AuthBearerToken: d.BearerToken,
		}
		return json.Marshal(marshaler)
	case "CUSTOM_SIGNATURE":
		var marshaler = struct {
			Type string `json:"type"`
			*AuthCustomSignature
		}{
			Type:                d.Type,
			AuthCustomSignature: d.CustomSignature,
		}
		return json.Marshal(marshaler)
	}
}

type DestinationAuthMethodConfigVisitor interface {
	VisitHookdeckSignature(*AuthHookdeckSignature) error
	VisitBasicAuth(*AuthBasicAuth) error
	VisitApiKey(*AuthApiKey) error
	VisitBearerToken(*AuthBearerToken) error
	VisitCustomSignature(*AuthCustomSignature) error
}

func (d *DestinationAuthMethodConfig) Accept(visitor DestinationAuthMethodConfigVisitor) error {
	switch d.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", d.Type, d)
	case "HOOKDECK_SIGNATURE":
		return visitor.VisitHookdeckSignature(d.HookdeckSignature)
	case "BASIC_AUTH":
		return visitor.VisitBasicAuth(d.BasicAuth)
	case "API_KEY":
		return visitor.VisitApiKey(d.ApiKey)
	case "BEARER_TOKEN":
		return visitor.VisitBearerToken(d.BearerToken)
	case "CUSTOM_SIGNATURE":
		return visitor.VisitCustomSignature(d.CustomSignature)
	}
}

// Custom signature config for the destination's auth method
type DestinationAuthMethodCustomSignatureConfig struct {
	// Key for the custom signature auth
	Key string `json:"key"`
	// Signing secret for the custom signature auth. If left empty a secret will be generated for you.
	SigningSecret *string `json:"signing_secret,omitempty"`
}

// Empty config for the destination's auth method
type DestinationAuthMethodSignatureConfig struct {
}

// Period to rate limit attempts
type DestinationCreateRequestRateLimitPeriod string

const (
	DestinationCreateRequestRateLimitPeriodSecond DestinationCreateRequestRateLimitPeriod = "second"
	DestinationCreateRequestRateLimitPeriodMinute DestinationCreateRequestRateLimitPeriod = "minute"
	DestinationCreateRequestRateLimitPeriodHour   DestinationCreateRequestRateLimitPeriod = "hour"
)

func NewDestinationCreateRequestRateLimitPeriodFromString(s string) (DestinationCreateRequestRateLimitPeriod, error) {
	switch s {
	case "second":
		return DestinationCreateRequestRateLimitPeriodSecond, nil
	case "minute":
		return DestinationCreateRequestRateLimitPeriodMinute, nil
	case "hour":
		return DestinationCreateRequestRateLimitPeriodHour, nil
	}
	var t DestinationCreateRequestRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationCreateRequestRateLimitPeriod) Ptr() *DestinationCreateRequestRateLimitPeriod {
	return &d
}

type DestinationDeleteResponse struct {
	// ID of the destination
	Id string `json:"id"`
}

// HTTP method used on requests sent to the destination, overrides the method used on requests sent to the source.
type DestinationHttpMethod string

const (
	DestinationHttpMethodGet    DestinationHttpMethod = "GET"
	DestinationHttpMethodPost   DestinationHttpMethod = "POST"
	DestinationHttpMethodPut    DestinationHttpMethod = "PUT"
	DestinationHttpMethodPatch  DestinationHttpMethod = "PATCH"
	DestinationHttpMethodDelete DestinationHttpMethod = "DELETE"
)

func NewDestinationHttpMethodFromString(s string) (DestinationHttpMethod, error) {
	switch s {
	case "GET":
		return DestinationHttpMethodGet, nil
	case "POST":
		return DestinationHttpMethodPost, nil
	case "PUT":
		return DestinationHttpMethodPut, nil
	case "PATCH":
		return DestinationHttpMethodPatch, nil
	case "DELETE":
		return DestinationHttpMethodDelete, nil
	}
	var t DestinationHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationHttpMethod) Ptr() *DestinationHttpMethod {
	return &d
}

type DestinationListRequestDir string

const (
	DestinationListRequestDirAsc  DestinationListRequestDir = "asc"
	DestinationListRequestDirDesc DestinationListRequestDir = "desc"
)

func NewDestinationListRequestDirFromString(s string) (DestinationListRequestDir, error) {
	switch s {
	case "asc":
		return DestinationListRequestDirAsc, nil
	case "desc":
		return DestinationListRequestDirDesc, nil
	}
	var t DestinationListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationListRequestDir) Ptr() *DestinationListRequestDir {
	return &d
}

type DestinationPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Destination  `json:"models,omitempty"`
}

// Period to rate limit attempts
type DestinationRateLimitPeriod string

const (
	DestinationRateLimitPeriodSecond DestinationRateLimitPeriod = "second"
	DestinationRateLimitPeriodMinute DestinationRateLimitPeriod = "minute"
	DestinationRateLimitPeriodHour   DestinationRateLimitPeriod = "hour"
)

func NewDestinationRateLimitPeriodFromString(s string) (DestinationRateLimitPeriod, error) {
	switch s {
	case "second":
		return DestinationRateLimitPeriodSecond, nil
	case "minute":
		return DestinationRateLimitPeriodMinute, nil
	case "hour":
		return DestinationRateLimitPeriodHour, nil
	}
	var t DestinationRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationRateLimitPeriod) Ptr() *DestinationRateLimitPeriod {
	return &d
}

// Period to rate limit attempts
type DestinationUpdateRequestRateLimitPeriod string

const (
	DestinationUpdateRequestRateLimitPeriodSecond DestinationUpdateRequestRateLimitPeriod = "second"
	DestinationUpdateRequestRateLimitPeriodMinute DestinationUpdateRequestRateLimitPeriod = "minute"
	DestinationUpdateRequestRateLimitPeriodHour   DestinationUpdateRequestRateLimitPeriod = "hour"
)

func NewDestinationUpdateRequestRateLimitPeriodFromString(s string) (DestinationUpdateRequestRateLimitPeriod, error) {
	switch s {
	case "second":
		return DestinationUpdateRequestRateLimitPeriodSecond, nil
	case "minute":
		return DestinationUpdateRequestRateLimitPeriodMinute, nil
	case "hour":
		return DestinationUpdateRequestRateLimitPeriodHour, nil
	}
	var t DestinationUpdateRequestRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationUpdateRequestRateLimitPeriod) Ptr() *DestinationUpdateRequestRateLimitPeriod {
	return &d
}

// Period to rate limit attempts
type DestinationUpsertRequestRateLimitPeriod string

const (
	DestinationUpsertRequestRateLimitPeriodSecond DestinationUpsertRequestRateLimitPeriod = "second"
	DestinationUpsertRequestRateLimitPeriodMinute DestinationUpsertRequestRateLimitPeriod = "minute"
	DestinationUpsertRequestRateLimitPeriodHour   DestinationUpsertRequestRateLimitPeriod = "hour"
)

func NewDestinationUpsertRequestRateLimitPeriodFromString(s string) (DestinationUpsertRequestRateLimitPeriod, error) {
	switch s {
	case "second":
		return DestinationUpsertRequestRateLimitPeriodSecond, nil
	case "minute":
		return DestinationUpsertRequestRateLimitPeriodMinute, nil
	case "hour":
		return DestinationUpsertRequestRateLimitPeriodHour, nil
	}
	var t DestinationUpsertRequestRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DestinationUpsertRequestRateLimitPeriod) Ptr() *DestinationUpsertRequestRateLimitPeriod {
	return &d
}

type DetachedIntegrationFromSource struct {
}

type Event struct {
	// ID of the event
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// ID of the associated connection
	WebhookId string `json:"webhook_id"`
	// ID of the associated source
	SourceId string `json:"source_id"`
	// ID of the associated destination
	DestinationId string `json:"destination_id"`
	// ID of the event data
	EventDataId string `json:"event_data_id"`
	// ID of the request that created the event
	RequestId string `json:"request_id"`
	// Number of delivery attempts made
	Attempts int `json:"attempts"`
	// Date of the most recently attempted retry
	LastAttemptAt *time.Time `json:"last_attempt_at,omitempty"`
	// Date of the next scheduled retry
	NextAttemptAt *time.Time `json:"next_attempt_at,omitempty"`
	// Event status
	ResponseStatus *int               `json:"response_status,omitempty"`
	ErrorCode      *AttemptErrorCodes `json:"error_code,omitempty"`
	Status         EventStatus        `json:"status,omitempty"`
	// Date of the latest successful attempt
	SuccessfulAt *time.Time `json:"successful_at,omitempty"`
	// ID of the CLI the event is sent to
	CliId *string `json:"cli_id,omitempty"`
	// Date the event was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the event was created
	CreatedAt time.Time       `json:"created_at"`
	Data      *ShortEventData `json:"data,omitempty"`
}

type EventArray = []*Event

type EventAttempt struct {
	// Attempt ID
	Id string `json:"id"`
	// Team ID
	TeamId string `json:"team_id"`
	// Event ID
	EventId string `json:"event_id"`
	// Attempt's HTTP response code
	ResponseStatus *int `json:"response_status,omitempty"`
	// Sequential number of attempts (up to and including this one) made for the associated event
	AttemptNumber *int               `json:"attempt_number,omitempty"`
	Trigger       *AttemptTrigger    `json:"trigger,omitempty"`
	ErrorCode     *AttemptErrorCodes `json:"error_code,omitempty"`
	Body          *EventAttemptBody  `json:"body,omitempty"`
	// URL of the destination where delivery was attempted
	RequestedUrl *string `json:"requested_url,omitempty"`
	// HTTP method used to deliver the attempt
	HttpMethod *EventAttemptHttpMethod `json:"http_method,omitempty"`
	// ID of associated bulk retry
	BulkRetryId *string       `json:"bulk_retry_id,omitempty"`
	Status      AttemptStatus `json:"status,omitempty"`
	// Date the attempt was successful
	SuccessfulAt *time.Time `json:"successful_at,omitempty"`
	// Date the attempt was delivered
	DeliveredAt *time.Time `json:"delivered_at,omitempty"`
	// Date the destination responded to this attempt
	RespondedAt *time.Time `json:"responded_at,omitempty"`
	// Time elapsed between attempt initiation and final delivery (in ms)
	DeliveryLatency *int `json:"delivery_latency,omitempty"`
	// Time elapsed between attempt initiation and a response from the destination (in ms)
	ResponseLatency *int `json:"response_latency,omitempty"`
	// Date the attempt was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the attempt was created
	CreatedAt time.Time     `json:"created_at"`
	State     *AttemptState `json:"state,omitempty"`
	// Date the attempt was archived
	ArchivedAt    *string `json:"archived_at,omitempty"`
	DestinationId *string `json:"destination_id,omitempty"`
}

type EventAttemptBody struct {
	typeName string
	// Response body from the destination
	EventAttemptBodyZeroOptional *EventAttemptBodyZero
	// Response body from the destination
	StringOptional *string
}

func NewEventAttemptBodyFromEventAttemptBodyZeroOptional(value *EventAttemptBodyZero) *EventAttemptBody {
	return &EventAttemptBody{typeName: "eventAttemptBodyZeroOptional", EventAttemptBodyZeroOptional: value}
}

func NewEventAttemptBodyFromStringOptional(value *string) *EventAttemptBody {
	return &EventAttemptBody{typeName: "stringOptional", StringOptional: value}
}

func (e *EventAttemptBody) UnmarshalJSON(data []byte) error {
	var valueEventAttemptBodyZeroOptional *EventAttemptBodyZero
	if err := json.Unmarshal(data, &valueEventAttemptBodyZeroOptional); err == nil {
		e.typeName = "eventAttemptBodyZeroOptional"
		e.EventAttemptBodyZeroOptional = valueEventAttemptBodyZeroOptional
		return nil
	}
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		e.typeName = "stringOptional"
		e.StringOptional = valueStringOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventAttemptBody) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventAttemptBodyZeroOptional":
		return json.Marshal(e.EventAttemptBodyZeroOptional)
	case "stringOptional":
		return json.Marshal(e.StringOptional)
	}
}

type EventAttemptBodyVisitor interface {
	VisitEventAttemptBodyZeroOptional(*EventAttemptBodyZero) error
	VisitStringOptional(*string) error
}

func (e *EventAttemptBody) Accept(visitor EventAttemptBodyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventAttemptBodyZeroOptional":
		return visitor.VisitEventAttemptBodyZeroOptional(e.EventAttemptBodyZeroOptional)
	case "stringOptional":
		return visitor.VisitStringOptional(e.StringOptional)
	}
}

// Response body from the destination
type EventAttemptBodyZero struct {
}

// HTTP method used to deliver the attempt
type EventAttemptHttpMethod string

const (
	EventAttemptHttpMethodGet    EventAttemptHttpMethod = "GET"
	EventAttemptHttpMethodPost   EventAttemptHttpMethod = "POST"
	EventAttemptHttpMethodPut    EventAttemptHttpMethod = "PUT"
	EventAttemptHttpMethodPatch  EventAttemptHttpMethod = "PATCH"
	EventAttemptHttpMethodDelete EventAttemptHttpMethod = "DELETE"
)

func NewEventAttemptHttpMethodFromString(s string) (EventAttemptHttpMethod, error) {
	switch s {
	case "GET":
		return EventAttemptHttpMethodGet, nil
	case "POST":
		return EventAttemptHttpMethodPost, nil
	case "PUT":
		return EventAttemptHttpMethodPut, nil
	case "PATCH":
		return EventAttemptHttpMethodPatch, nil
	case "DELETE":
		return EventAttemptHttpMethodDelete, nil
	}
	var t EventAttemptHttpMethod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventAttemptHttpMethod) Ptr() *EventAttemptHttpMethod {
	return &e
}

type EventAttemptPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*EventAttempt `json:"models,omitempty"`
}

// Filter properties for the events to be included in the bulk retry
type EventBulkRetryCreateRequestQuery struct {
	// Filter by event IDs
	Id *EventBulkRetryCreateRequestQueryId `json:"id,omitempty"`
	// Lifecyle status of the event
	Status *EventBulkRetryCreateRequestQueryStatus `json:"status,omitempty"`
	// Filter by webhook connection IDs
	WebhookId *EventBulkRetryCreateRequestQueryWebhookId `json:"webhook_id,omitempty"`
	// Filter by destination IDs
	DestinationId *EventBulkRetryCreateRequestQueryDestinationId `json:"destination_id,omitempty"`
	// Filter by source IDs
	SourceId *EventBulkRetryCreateRequestQuerySourceId `json:"source_id,omitempty"`
	// Filter by number of attempts
	Attempts *EventBulkRetryCreateRequestQueryAttempts `json:"attempts,omitempty"`
	// Filter by HTTP response status code
	ResponseStatus *EventBulkRetryCreateRequestQueryResponseStatus `json:"response_status,omitempty"`
	// Filter by `successful_at` date using a date operator
	SuccessfulAt *EventBulkRetryCreateRequestQuerySuccessfulAt `json:"successful_at,omitempty"`
	// Filter by `created_at` date using a date operator
	CreatedAt *EventBulkRetryCreateRequestQueryCreatedAt `json:"created_at,omitempty"`
	// Filter by error code code
	ErrorCode *EventBulkRetryCreateRequestQueryErrorCode `json:"error_code,omitempty"`
	// Filter by CLI IDs. `?[any]=true` operator for any CLI.
	CliId *EventBulkRetryCreateRequestQueryCliId `json:"cli_id,omitempty"`
	// Filter by `last_attempt_at` date using a date operator
	LastAttemptAt *EventBulkRetryCreateRequestQueryLastAttemptAt `json:"last_attempt_at,omitempty"`
	// URL Encoded string of the value to match partially to the body, headers, parsed_query or path
	SearchTerm *string `json:"search_term,omitempty"`
	// URL Encoded string of the JSON to match to the data headers
	Headers *EventBulkRetryCreateRequestQueryHeaders `json:"headers,omitempty"`
	// URL Encoded string of the JSON to match to the data body
	Body *EventBulkRetryCreateRequestQueryBody `json:"body,omitempty"`
	// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
	ParsedQuery *EventBulkRetryCreateRequestQueryParsedQuery `json:"parsed_query,omitempty"`
	// URL Encoded string of the value to match partially to the path
	Path        *string                                      `json:"path,omitempty"`
	CliUserId   *EventBulkRetryCreateRequestQueryCliUserId   `json:"cli_user_id,omitempty"`
	IssueId     *EventBulkRetryCreateRequestQueryIssueId     `json:"issue_id,omitempty"`
	EventDataId *EventBulkRetryCreateRequestQueryEventDataId `json:"event_data_id,omitempty"`
	BulkRetryId *EventBulkRetryCreateRequestQueryBulkRetryId `json:"bulk_retry_id,omitempty"`
}

// Filter by number of attempts
type EventBulkRetryCreateRequestQueryAttempts struct {
	typeName                                    string
	Integer                                     int
	EventBulkRetryCreateRequestQueryAttemptsAny *EventBulkRetryCreateRequestQueryAttemptsAny
}

func NewEventBulkRetryCreateRequestQueryAttemptsFromInteger(value int) *EventBulkRetryCreateRequestQueryAttempts {
	return &EventBulkRetryCreateRequestQueryAttempts{typeName: "integer", Integer: value}
}

func NewEventBulkRetryCreateRequestQueryAttemptsFromEventBulkRetryCreateRequestQueryAttemptsAny(value *EventBulkRetryCreateRequestQueryAttemptsAny) *EventBulkRetryCreateRequestQueryAttempts {
	return &EventBulkRetryCreateRequestQueryAttempts{typeName: "eventBulkRetryCreateRequestQueryAttemptsAny", EventBulkRetryCreateRequestQueryAttemptsAny: value}
}

func (e *EventBulkRetryCreateRequestQueryAttempts) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		e.typeName = "integer"
		e.Integer = valueInteger
		return nil
	}
	valueEventBulkRetryCreateRequestQueryAttemptsAny := new(EventBulkRetryCreateRequestQueryAttemptsAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryAttemptsAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryAttemptsAny"
		e.EventBulkRetryCreateRequestQueryAttemptsAny = valueEventBulkRetryCreateRequestQueryAttemptsAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryAttempts) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return json.Marshal(e.Integer)
	case "eventBulkRetryCreateRequestQueryAttemptsAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryAttemptsAny)
	}
}

type EventBulkRetryCreateRequestQueryAttemptsVisitor interface {
	VisitInteger(int) error
	VisitEventBulkRetryCreateRequestQueryAttemptsAny(*EventBulkRetryCreateRequestQueryAttemptsAny) error
}

func (e *EventBulkRetryCreateRequestQueryAttempts) Accept(visitor EventBulkRetryCreateRequestQueryAttemptsVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "eventBulkRetryCreateRequestQueryAttemptsAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryAttemptsAny(e.EventBulkRetryCreateRequestQueryAttemptsAny)
	}
}

type EventBulkRetryCreateRequestQueryAttemptsAny struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// URL Encoded string of the JSON to match to the data body
type EventBulkRetryCreateRequestQueryBody struct {
	typeName                                string
	String                                  string
	EventBulkRetryCreateRequestQueryBodyOne *EventBulkRetryCreateRequestQueryBodyOne
}

func NewEventBulkRetryCreateRequestQueryBodyFromString(value string) *EventBulkRetryCreateRequestQueryBody {
	return &EventBulkRetryCreateRequestQueryBody{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryBodyFromEventBulkRetryCreateRequestQueryBodyOne(value *EventBulkRetryCreateRequestQueryBodyOne) *EventBulkRetryCreateRequestQueryBody {
	return &EventBulkRetryCreateRequestQueryBody{typeName: "eventBulkRetryCreateRequestQueryBodyOne", EventBulkRetryCreateRequestQueryBodyOne: value}
}

func (e *EventBulkRetryCreateRequestQueryBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryBodyOne := new(EventBulkRetryCreateRequestQueryBodyOne)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryBodyOne); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryBodyOne"
		e.EventBulkRetryCreateRequestQueryBodyOne = valueEventBulkRetryCreateRequestQueryBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryBody) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryBodyOne":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryBodyOne)
	}
}

type EventBulkRetryCreateRequestQueryBodyVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryBodyOne(*EventBulkRetryCreateRequestQueryBodyOne) error
}

func (e *EventBulkRetryCreateRequestQueryBody) Accept(visitor EventBulkRetryCreateRequestQueryBodyVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryBodyOne":
		return visitor.VisitEventBulkRetryCreateRequestQueryBodyOne(e.EventBulkRetryCreateRequestQueryBodyOne)
	}
}

type EventBulkRetryCreateRequestQueryBodyOne struct {
}

type EventBulkRetryCreateRequestQueryBulkRetryId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryBulkRetryIdFromString(value string) *EventBulkRetryCreateRequestQueryBulkRetryId {
	return &EventBulkRetryCreateRequestQueryBulkRetryId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryBulkRetryIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryBulkRetryId {
	return &EventBulkRetryCreateRequestQueryBulkRetryId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryBulkRetryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryBulkRetryId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryBulkRetryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryBulkRetryId) Accept(visitor EventBulkRetryCreateRequestQueryBulkRetryIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by CLI IDs. `?[any]=true` operator for any CLI.
type EventBulkRetryCreateRequestQueryCliId struct {
	typeName                                 string
	String                                   string
	EventBulkRetryCreateRequestQueryCliIdAny *EventBulkRetryCreateRequestQueryCliIdAny
	StringList                               []string
}

func NewEventBulkRetryCreateRequestQueryCliIdFromString(value string) *EventBulkRetryCreateRequestQueryCliId {
	return &EventBulkRetryCreateRequestQueryCliId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryCliIdFromEventBulkRetryCreateRequestQueryCliIdAny(value *EventBulkRetryCreateRequestQueryCliIdAny) *EventBulkRetryCreateRequestQueryCliId {
	return &EventBulkRetryCreateRequestQueryCliId{typeName: "eventBulkRetryCreateRequestQueryCliIdAny", EventBulkRetryCreateRequestQueryCliIdAny: value}
}

func NewEventBulkRetryCreateRequestQueryCliIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryCliId {
	return &EventBulkRetryCreateRequestQueryCliId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryCliId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryCliIdAny := new(EventBulkRetryCreateRequestQueryCliIdAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryCliIdAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryCliIdAny"
		e.EventBulkRetryCreateRequestQueryCliIdAny = valueEventBulkRetryCreateRequestQueryCliIdAny
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryCliId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryCliIdAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryCliIdAny)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryCliIdVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryCliIdAny(*EventBulkRetryCreateRequestQueryCliIdAny) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryCliId) Accept(visitor EventBulkRetryCreateRequestQueryCliIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryCliIdAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryCliIdAny(e.EventBulkRetryCreateRequestQueryCliIdAny)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryCliIdAny struct {
	Any *bool `json:"any,omitempty"`
}

type EventBulkRetryCreateRequestQueryCliUserId struct {
	typeName   string
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryCliUserIdFromString(value string) *EventBulkRetryCreateRequestQueryCliUserId {
	return &EventBulkRetryCreateRequestQueryCliUserId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryCliUserIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryCliUserId {
	return &EventBulkRetryCreateRequestQueryCliUserId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryCliUserId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryCliUserId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryCliUserIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryCliUserId) Accept(visitor EventBulkRetryCreateRequestQueryCliUserIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by `created_at` date using a date operator
type EventBulkRetryCreateRequestQueryCreatedAt struct {
	typeName                                     string
	DateTime                                     time.Time
	EventBulkRetryCreateRequestQueryCreatedAtAny *EventBulkRetryCreateRequestQueryCreatedAtAny
}

func NewEventBulkRetryCreateRequestQueryCreatedAtFromDateTime(value time.Time) *EventBulkRetryCreateRequestQueryCreatedAt {
	return &EventBulkRetryCreateRequestQueryCreatedAt{typeName: "dateTime", DateTime: value}
}

func NewEventBulkRetryCreateRequestQueryCreatedAtFromEventBulkRetryCreateRequestQueryCreatedAtAny(value *EventBulkRetryCreateRequestQueryCreatedAtAny) *EventBulkRetryCreateRequestQueryCreatedAt {
	return &EventBulkRetryCreateRequestQueryCreatedAt{typeName: "eventBulkRetryCreateRequestQueryCreatedAtAny", EventBulkRetryCreateRequestQueryCreatedAtAny: value}
}

func (e *EventBulkRetryCreateRequestQueryCreatedAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		e.typeName = "dateTime"
		e.DateTime = valueDateTime
		return nil
	}
	valueEventBulkRetryCreateRequestQueryCreatedAtAny := new(EventBulkRetryCreateRequestQueryCreatedAtAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryCreatedAtAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryCreatedAtAny"
		e.EventBulkRetryCreateRequestQueryCreatedAtAny = valueEventBulkRetryCreateRequestQueryCreatedAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryCreatedAt) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return json.Marshal(e.DateTime)
	case "eventBulkRetryCreateRequestQueryCreatedAtAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryCreatedAtAny)
	}
}

type EventBulkRetryCreateRequestQueryCreatedAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitEventBulkRetryCreateRequestQueryCreatedAtAny(*EventBulkRetryCreateRequestQueryCreatedAtAny) error
}

func (e *EventBulkRetryCreateRequestQueryCreatedAt) Accept(visitor EventBulkRetryCreateRequestQueryCreatedAtVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return visitor.VisitDateTime(e.DateTime)
	case "eventBulkRetryCreateRequestQueryCreatedAtAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryCreatedAtAny(e.EventBulkRetryCreateRequestQueryCreatedAtAny)
	}
}

type EventBulkRetryCreateRequestQueryCreatedAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// Filter by destination IDs
type EventBulkRetryCreateRequestQueryDestinationId struct {
	typeName string
	// Destination ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryDestinationIdFromString(value string) *EventBulkRetryCreateRequestQueryDestinationId {
	return &EventBulkRetryCreateRequestQueryDestinationId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryDestinationIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryDestinationId {
	return &EventBulkRetryCreateRequestQueryDestinationId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryDestinationId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryDestinationId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryDestinationIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryDestinationId) Accept(visitor EventBulkRetryCreateRequestQueryDestinationIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by error code code
type EventBulkRetryCreateRequestQueryErrorCode struct {
	typeName              string
	AttemptErrorCodes     AttemptErrorCodes
	AttemptErrorCodesList []AttemptErrorCodes
}

func NewEventBulkRetryCreateRequestQueryErrorCodeFromAttemptErrorCodes(value AttemptErrorCodes) *EventBulkRetryCreateRequestQueryErrorCode {
	return &EventBulkRetryCreateRequestQueryErrorCode{typeName: "attemptErrorCodes", AttemptErrorCodes: value}
}

func NewEventBulkRetryCreateRequestQueryErrorCodeFromAttemptErrorCodesList(value []AttemptErrorCodes) *EventBulkRetryCreateRequestQueryErrorCode {
	return &EventBulkRetryCreateRequestQueryErrorCode{typeName: "attemptErrorCodesList", AttemptErrorCodesList: value}
}

func (e *EventBulkRetryCreateRequestQueryErrorCode) UnmarshalJSON(data []byte) error {
	var valueAttemptErrorCodes AttemptErrorCodes
	if err := json.Unmarshal(data, &valueAttemptErrorCodes); err == nil {
		e.typeName = "attemptErrorCodes"
		e.AttemptErrorCodes = valueAttemptErrorCodes
		return nil
	}
	var valueAttemptErrorCodesList []AttemptErrorCodes
	if err := json.Unmarshal(data, &valueAttemptErrorCodesList); err == nil {
		e.typeName = "attemptErrorCodesList"
		e.AttemptErrorCodesList = valueAttemptErrorCodesList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryErrorCode) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "attemptErrorCodes":
		return json.Marshal(e.AttemptErrorCodes)
	case "attemptErrorCodesList":
		return json.Marshal(e.AttemptErrorCodesList)
	}
}

type EventBulkRetryCreateRequestQueryErrorCodeVisitor interface {
	VisitAttemptErrorCodes(AttemptErrorCodes) error
	VisitAttemptErrorCodesList([]AttemptErrorCodes) error
}

func (e *EventBulkRetryCreateRequestQueryErrorCode) Accept(visitor EventBulkRetryCreateRequestQueryErrorCodeVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "attemptErrorCodes":
		return visitor.VisitAttemptErrorCodes(e.AttemptErrorCodes)
	case "attemptErrorCodesList":
		return visitor.VisitAttemptErrorCodesList(e.AttemptErrorCodesList)
	}
}

type EventBulkRetryCreateRequestQueryEventDataId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryEventDataIdFromString(value string) *EventBulkRetryCreateRequestQueryEventDataId {
	return &EventBulkRetryCreateRequestQueryEventDataId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryEventDataIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryEventDataId {
	return &EventBulkRetryCreateRequestQueryEventDataId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryEventDataId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryEventDataId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryEventDataIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryEventDataId) Accept(visitor EventBulkRetryCreateRequestQueryEventDataIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// URL Encoded string of the JSON to match to the data headers
type EventBulkRetryCreateRequestQueryHeaders struct {
	typeName                                   string
	String                                     string
	EventBulkRetryCreateRequestQueryHeadersOne *EventBulkRetryCreateRequestQueryHeadersOne
}

func NewEventBulkRetryCreateRequestQueryHeadersFromString(value string) *EventBulkRetryCreateRequestQueryHeaders {
	return &EventBulkRetryCreateRequestQueryHeaders{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryHeadersFromEventBulkRetryCreateRequestQueryHeadersOne(value *EventBulkRetryCreateRequestQueryHeadersOne) *EventBulkRetryCreateRequestQueryHeaders {
	return &EventBulkRetryCreateRequestQueryHeaders{typeName: "eventBulkRetryCreateRequestQueryHeadersOne", EventBulkRetryCreateRequestQueryHeadersOne: value}
}

func (e *EventBulkRetryCreateRequestQueryHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryHeadersOne := new(EventBulkRetryCreateRequestQueryHeadersOne)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryHeadersOne); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryHeadersOne"
		e.EventBulkRetryCreateRequestQueryHeadersOne = valueEventBulkRetryCreateRequestQueryHeadersOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryHeaders) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryHeadersOne":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryHeadersOne)
	}
}

type EventBulkRetryCreateRequestQueryHeadersVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryHeadersOne(*EventBulkRetryCreateRequestQueryHeadersOne) error
}

func (e *EventBulkRetryCreateRequestQueryHeaders) Accept(visitor EventBulkRetryCreateRequestQueryHeadersVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryHeadersOne":
		return visitor.VisitEventBulkRetryCreateRequestQueryHeadersOne(e.EventBulkRetryCreateRequestQueryHeadersOne)
	}
}

type EventBulkRetryCreateRequestQueryHeadersOne struct {
}

// Filter by event IDs
type EventBulkRetryCreateRequestQueryId struct {
	typeName string
	// Event ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryIdFromString(value string) *EventBulkRetryCreateRequestQueryId {
	return &EventBulkRetryCreateRequestQueryId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryId {
	return &EventBulkRetryCreateRequestQueryId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryId) Accept(visitor EventBulkRetryCreateRequestQueryIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryIssueId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryIssueIdFromString(value string) *EventBulkRetryCreateRequestQueryIssueId {
	return &EventBulkRetryCreateRequestQueryIssueId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryIssueIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryIssueId {
	return &EventBulkRetryCreateRequestQueryIssueId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryIssueId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryIssueId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryIssueIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryIssueId) Accept(visitor EventBulkRetryCreateRequestQueryIssueIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Filter by `last_attempt_at` date using a date operator
type EventBulkRetryCreateRequestQueryLastAttemptAt struct {
	typeName                                         string
	DateTime                                         time.Time
	EventBulkRetryCreateRequestQueryLastAttemptAtAny *EventBulkRetryCreateRequestQueryLastAttemptAtAny
}

func NewEventBulkRetryCreateRequestQueryLastAttemptAtFromDateTime(value time.Time) *EventBulkRetryCreateRequestQueryLastAttemptAt {
	return &EventBulkRetryCreateRequestQueryLastAttemptAt{typeName: "dateTime", DateTime: value}
}

func NewEventBulkRetryCreateRequestQueryLastAttemptAtFromEventBulkRetryCreateRequestQueryLastAttemptAtAny(value *EventBulkRetryCreateRequestQueryLastAttemptAtAny) *EventBulkRetryCreateRequestQueryLastAttemptAt {
	return &EventBulkRetryCreateRequestQueryLastAttemptAt{typeName: "eventBulkRetryCreateRequestQueryLastAttemptAtAny", EventBulkRetryCreateRequestQueryLastAttemptAtAny: value}
}

func (e *EventBulkRetryCreateRequestQueryLastAttemptAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		e.typeName = "dateTime"
		e.DateTime = valueDateTime
		return nil
	}
	valueEventBulkRetryCreateRequestQueryLastAttemptAtAny := new(EventBulkRetryCreateRequestQueryLastAttemptAtAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryLastAttemptAtAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryLastAttemptAtAny"
		e.EventBulkRetryCreateRequestQueryLastAttemptAtAny = valueEventBulkRetryCreateRequestQueryLastAttemptAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryLastAttemptAt) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return json.Marshal(e.DateTime)
	case "eventBulkRetryCreateRequestQueryLastAttemptAtAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryLastAttemptAtAny)
	}
}

type EventBulkRetryCreateRequestQueryLastAttemptAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitEventBulkRetryCreateRequestQueryLastAttemptAtAny(*EventBulkRetryCreateRequestQueryLastAttemptAtAny) error
}

func (e *EventBulkRetryCreateRequestQueryLastAttemptAt) Accept(visitor EventBulkRetryCreateRequestQueryLastAttemptAtVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return visitor.VisitDateTime(e.DateTime)
	case "eventBulkRetryCreateRequestQueryLastAttemptAtAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryLastAttemptAtAny(e.EventBulkRetryCreateRequestQueryLastAttemptAtAny)
	}
}

type EventBulkRetryCreateRequestQueryLastAttemptAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
type EventBulkRetryCreateRequestQueryParsedQuery struct {
	typeName                                       string
	String                                         string
	EventBulkRetryCreateRequestQueryParsedQueryOne *EventBulkRetryCreateRequestQueryParsedQueryOne
}

func NewEventBulkRetryCreateRequestQueryParsedQueryFromString(value string) *EventBulkRetryCreateRequestQueryParsedQuery {
	return &EventBulkRetryCreateRequestQueryParsedQuery{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryParsedQueryFromEventBulkRetryCreateRequestQueryParsedQueryOne(value *EventBulkRetryCreateRequestQueryParsedQueryOne) *EventBulkRetryCreateRequestQueryParsedQuery {
	return &EventBulkRetryCreateRequestQueryParsedQuery{typeName: "eventBulkRetryCreateRequestQueryParsedQueryOne", EventBulkRetryCreateRequestQueryParsedQueryOne: value}
}

func (e *EventBulkRetryCreateRequestQueryParsedQuery) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	valueEventBulkRetryCreateRequestQueryParsedQueryOne := new(EventBulkRetryCreateRequestQueryParsedQueryOne)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryParsedQueryOne); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryParsedQueryOne"
		e.EventBulkRetryCreateRequestQueryParsedQueryOne = valueEventBulkRetryCreateRequestQueryParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryParsedQuery) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "eventBulkRetryCreateRequestQueryParsedQueryOne":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type EventBulkRetryCreateRequestQueryParsedQueryVisitor interface {
	VisitString(string) error
	VisitEventBulkRetryCreateRequestQueryParsedQueryOne(*EventBulkRetryCreateRequestQueryParsedQueryOne) error
}

func (e *EventBulkRetryCreateRequestQueryParsedQuery) Accept(visitor EventBulkRetryCreateRequestQueryParsedQueryVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "eventBulkRetryCreateRequestQueryParsedQueryOne":
		return visitor.VisitEventBulkRetryCreateRequestQueryParsedQueryOne(e.EventBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type EventBulkRetryCreateRequestQueryParsedQueryOne struct {
}

// Filter by HTTP response status code
type EventBulkRetryCreateRequestQueryResponseStatus struct {
	typeName                                          string
	Integer                                           int
	EventBulkRetryCreateRequestQueryResponseStatusAny *EventBulkRetryCreateRequestQueryResponseStatusAny
	IntegerList                                       []int
}

func NewEventBulkRetryCreateRequestQueryResponseStatusFromInteger(value int) *EventBulkRetryCreateRequestQueryResponseStatus {
	return &EventBulkRetryCreateRequestQueryResponseStatus{typeName: "integer", Integer: value}
}

func NewEventBulkRetryCreateRequestQueryResponseStatusFromEventBulkRetryCreateRequestQueryResponseStatusAny(value *EventBulkRetryCreateRequestQueryResponseStatusAny) *EventBulkRetryCreateRequestQueryResponseStatus {
	return &EventBulkRetryCreateRequestQueryResponseStatus{typeName: "eventBulkRetryCreateRequestQueryResponseStatusAny", EventBulkRetryCreateRequestQueryResponseStatusAny: value}
}

func NewEventBulkRetryCreateRequestQueryResponseStatusFromIntegerList(value []int) *EventBulkRetryCreateRequestQueryResponseStatus {
	return &EventBulkRetryCreateRequestQueryResponseStatus{typeName: "integerList", IntegerList: value}
}

func (e *EventBulkRetryCreateRequestQueryResponseStatus) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		e.typeName = "integer"
		e.Integer = valueInteger
		return nil
	}
	valueEventBulkRetryCreateRequestQueryResponseStatusAny := new(EventBulkRetryCreateRequestQueryResponseStatusAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQueryResponseStatusAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQueryResponseStatusAny"
		e.EventBulkRetryCreateRequestQueryResponseStatusAny = valueEventBulkRetryCreateRequestQueryResponseStatusAny
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		e.typeName = "integerList"
		e.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryResponseStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return json.Marshal(e.Integer)
	case "eventBulkRetryCreateRequestQueryResponseStatusAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQueryResponseStatusAny)
	case "integerList":
		return json.Marshal(e.IntegerList)
	}
}

type EventBulkRetryCreateRequestQueryResponseStatusVisitor interface {
	VisitInteger(int) error
	VisitEventBulkRetryCreateRequestQueryResponseStatusAny(*EventBulkRetryCreateRequestQueryResponseStatusAny) error
	VisitIntegerList([]int) error
}

func (e *EventBulkRetryCreateRequestQueryResponseStatus) Accept(visitor EventBulkRetryCreateRequestQueryResponseStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "integer":
		return visitor.VisitInteger(e.Integer)
	case "eventBulkRetryCreateRequestQueryResponseStatusAny":
		return visitor.VisitEventBulkRetryCreateRequestQueryResponseStatusAny(e.EventBulkRetryCreateRequestQueryResponseStatusAny)
	case "integerList":
		return visitor.VisitIntegerList(e.IntegerList)
	}
}

type EventBulkRetryCreateRequestQueryResponseStatusAny struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// Filter by source IDs
type EventBulkRetryCreateRequestQuerySourceId struct {
	typeName string
	// Source ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQuerySourceIdFromString(value string) *EventBulkRetryCreateRequestQuerySourceId {
	return &EventBulkRetryCreateRequestQuerySourceId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQuerySourceIdFromStringList(value []string) *EventBulkRetryCreateRequestQuerySourceId {
	return &EventBulkRetryCreateRequestQuerySourceId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQuerySourceId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQuerySourceId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQuerySourceIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQuerySourceId) Accept(visitor EventBulkRetryCreateRequestQuerySourceIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

// Lifecyle status of the event
type EventBulkRetryCreateRequestQueryStatus struct {
	typeName        string
	EventStatus     EventStatus
	EventStatusList []EventStatus
}

func NewEventBulkRetryCreateRequestQueryStatusFromEventStatus(value EventStatus) *EventBulkRetryCreateRequestQueryStatus {
	return &EventBulkRetryCreateRequestQueryStatus{typeName: "eventStatus", EventStatus: value}
}

func NewEventBulkRetryCreateRequestQueryStatusFromEventStatusList(value []EventStatus) *EventBulkRetryCreateRequestQueryStatus {
	return &EventBulkRetryCreateRequestQueryStatus{typeName: "eventStatusList", EventStatusList: value}
}

func (e *EventBulkRetryCreateRequestQueryStatus) UnmarshalJSON(data []byte) error {
	var valueEventStatus EventStatus
	if err := json.Unmarshal(data, &valueEventStatus); err == nil {
		e.typeName = "eventStatus"
		e.EventStatus = valueEventStatus
		return nil
	}
	var valueEventStatusList []EventStatus
	if err := json.Unmarshal(data, &valueEventStatusList); err == nil {
		e.typeName = "eventStatusList"
		e.EventStatusList = valueEventStatusList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryStatus) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventStatus":
		return json.Marshal(e.EventStatus)
	case "eventStatusList":
		return json.Marshal(e.EventStatusList)
	}
}

type EventBulkRetryCreateRequestQueryStatusVisitor interface {
	VisitEventStatus(EventStatus) error
	VisitEventStatusList([]EventStatus) error
}

func (e *EventBulkRetryCreateRequestQueryStatus) Accept(visitor EventBulkRetryCreateRequestQueryStatusVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "eventStatus":
		return visitor.VisitEventStatus(e.EventStatus)
	case "eventStatusList":
		return visitor.VisitEventStatusList(e.EventStatusList)
	}
}

// Filter by `successful_at` date using a date operator
type EventBulkRetryCreateRequestQuerySuccessfulAt struct {
	typeName                                        string
	DateTime                                        time.Time
	EventBulkRetryCreateRequestQuerySuccessfulAtAny *EventBulkRetryCreateRequestQuerySuccessfulAtAny
}

func NewEventBulkRetryCreateRequestQuerySuccessfulAtFromDateTime(value time.Time) *EventBulkRetryCreateRequestQuerySuccessfulAt {
	return &EventBulkRetryCreateRequestQuerySuccessfulAt{typeName: "dateTime", DateTime: value}
}

func NewEventBulkRetryCreateRequestQuerySuccessfulAtFromEventBulkRetryCreateRequestQuerySuccessfulAtAny(value *EventBulkRetryCreateRequestQuerySuccessfulAtAny) *EventBulkRetryCreateRequestQuerySuccessfulAt {
	return &EventBulkRetryCreateRequestQuerySuccessfulAt{typeName: "eventBulkRetryCreateRequestQuerySuccessfulAtAny", EventBulkRetryCreateRequestQuerySuccessfulAtAny: value}
}

func (e *EventBulkRetryCreateRequestQuerySuccessfulAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		e.typeName = "dateTime"
		e.DateTime = valueDateTime
		return nil
	}
	valueEventBulkRetryCreateRequestQuerySuccessfulAtAny := new(EventBulkRetryCreateRequestQuerySuccessfulAtAny)
	if err := json.Unmarshal(data, &valueEventBulkRetryCreateRequestQuerySuccessfulAtAny); err == nil {
		e.typeName = "eventBulkRetryCreateRequestQuerySuccessfulAtAny"
		e.EventBulkRetryCreateRequestQuerySuccessfulAtAny = valueEventBulkRetryCreateRequestQuerySuccessfulAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQuerySuccessfulAt) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return json.Marshal(e.DateTime)
	case "eventBulkRetryCreateRequestQuerySuccessfulAtAny":
		return json.Marshal(e.EventBulkRetryCreateRequestQuerySuccessfulAtAny)
	}
}

type EventBulkRetryCreateRequestQuerySuccessfulAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitEventBulkRetryCreateRequestQuerySuccessfulAtAny(*EventBulkRetryCreateRequestQuerySuccessfulAtAny) error
}

func (e *EventBulkRetryCreateRequestQuerySuccessfulAt) Accept(visitor EventBulkRetryCreateRequestQuerySuccessfulAtVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "dateTime":
		return visitor.VisitDateTime(e.DateTime)
	case "eventBulkRetryCreateRequestQuerySuccessfulAtAny":
		return visitor.VisitEventBulkRetryCreateRequestQuerySuccessfulAtAny(e.EventBulkRetryCreateRequestQuerySuccessfulAtAny)
	}
}

type EventBulkRetryCreateRequestQuerySuccessfulAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// Filter by webhook connection IDs
type EventBulkRetryCreateRequestQueryWebhookId struct {
	typeName string
	// Webhook ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewEventBulkRetryCreateRequestQueryWebhookIdFromString(value string) *EventBulkRetryCreateRequestQueryWebhookId {
	return &EventBulkRetryCreateRequestQueryWebhookId{typeName: "string", String: value}
}

func NewEventBulkRetryCreateRequestQueryWebhookIdFromStringList(value []string) *EventBulkRetryCreateRequestQueryWebhookId {
	return &EventBulkRetryCreateRequestQueryWebhookId{typeName: "stringList", StringList: value}
}

func (e *EventBulkRetryCreateRequestQueryWebhookId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		e.typeName = "string"
		e.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		e.typeName = "stringList"
		e.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, e)
}

func (e EventBulkRetryCreateRequestQueryWebhookId) MarshalJSON() ([]byte, error) {
	switch e.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return json.Marshal(e.String)
	case "stringList":
		return json.Marshal(e.StringList)
	}
}

type EventBulkRetryCreateRequestQueryWebhookIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (e *EventBulkRetryCreateRequestQueryWebhookId) Accept(visitor EventBulkRetryCreateRequestQueryWebhookIdVisitor) error {
	switch e.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", e.typeName, e)
	case "string":
		return visitor.VisitString(e.String)
	case "stringList":
		return visitor.VisitStringList(e.StringList)
	}
}

type EventBulkRetryListRequestDir string

const (
	EventBulkRetryListRequestDirAsc  EventBulkRetryListRequestDir = "asc"
	EventBulkRetryListRequestDirDesc EventBulkRetryListRequestDir = "desc"
)

func NewEventBulkRetryListRequestDirFromString(s string) (EventBulkRetryListRequestDir, error) {
	switch s {
	case "asc":
		return EventBulkRetryListRequestDirAsc, nil
	case "desc":
		return EventBulkRetryListRequestDirDesc, nil
	}
	var t EventBulkRetryListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventBulkRetryListRequestDir) Ptr() *EventBulkRetryListRequestDir {
	return &e
}

type EventBulkRetryPlanResponse struct {
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
}

// Sort direction
type EventListRequestDir string

const (
	EventListRequestDirAsc  EventListRequestDir = "asc"
	EventListRequestDirDesc EventListRequestDir = "desc"
)

func NewEventListRequestDirFromString(s string) (EventListRequestDir, error) {
	switch s {
	case "asc":
		return EventListRequestDirAsc, nil
	case "desc":
		return EventListRequestDirDesc, nil
	}
	var t EventListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventListRequestDir) Ptr() *EventListRequestDir {
	return &e
}

// Sort key
type EventListRequestOrderBy string

const (
	EventListRequestOrderByLastAttemptAt EventListRequestOrderBy = "last_attempt_at"
	EventListRequestOrderByCreatedAt     EventListRequestOrderBy = "created_at"
)

func NewEventListRequestOrderByFromString(s string) (EventListRequestOrderBy, error) {
	switch s {
	case "last_attempt_at":
		return EventListRequestOrderByLastAttemptAt, nil
	case "created_at":
		return EventListRequestOrderByCreatedAt, nil
	}
	var t EventListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventListRequestOrderBy) Ptr() *EventListRequestOrderBy {
	return &e
}

type EventPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Event        `json:"models,omitempty"`
}

type EventStatus string

const (
	EventStatusScheduled  EventStatus = "SCHEDULED"
	EventStatusQueued     EventStatus = "QUEUED"
	EventStatusHold       EventStatus = "HOLD"
	EventStatusSuccessful EventStatus = "SUCCESSFUL"
	EventStatusFailed     EventStatus = "FAILED"
)

func NewEventStatusFromString(s string) (EventStatus, error) {
	switch s {
	case "SCHEDULED":
		return EventStatusScheduled, nil
	case "QUEUED":
		return EventStatusQueued, nil
	case "HOLD":
		return EventStatusHold, nil
	case "SUCCESSFUL":
		return EventStatusSuccessful, nil
	case "FAILED":
		return EventStatusFailed, nil
	}
	var t EventStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventStatus) Ptr() *EventStatus {
	return &e
}

type FilterRule struct {
	Headers *FilterRuleProperty `json:"headers,omitempty"`
	Body    *FilterRuleProperty `json:"body,omitempty"`
	Query   *FilterRuleProperty `json:"query,omitempty"`
	Path    *FilterRuleProperty `json:"path,omitempty"`
	type_   string
}

func (f *FilterRule) Type() string {
	return f.type_
}

func (f *FilterRule) UnmarshalJSON(data []byte) error {
	type unmarshaler FilterRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*f = FilterRule(value)
	f.type_ = "filter"
	return nil
}

func (f *FilterRule) MarshalJSON() ([]byte, error) {
	type embed FilterRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*f),
		Type:  "filter",
	}
	return json.Marshal(marshaler)
}

// JSON using our filter syntax to filter on request headers
type FilterRuleProperty struct {
	typeName                 string
	StringOptional           *string
	DoubleOptional           *float64
	BooleanOptional          *bool
	StringUnknownMapOptional map[string]interface{}
}

func NewFilterRulePropertyFromStringOptional(value *string) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "stringOptional", StringOptional: value}
}

func NewFilterRulePropertyFromDoubleOptional(value *float64) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "doubleOptional", DoubleOptional: value}
}

func NewFilterRulePropertyFromBooleanOptional(value *bool) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "booleanOptional", BooleanOptional: value}
}

func NewFilterRulePropertyFromStringUnknownMapOptional(value map[string]interface{}) *FilterRuleProperty {
	return &FilterRuleProperty{typeName: "stringUnknownMapOptional", StringUnknownMapOptional: value}
}

func (f *FilterRuleProperty) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		f.typeName = "stringOptional"
		f.StringOptional = valueStringOptional
		return nil
	}
	var valueDoubleOptional *float64
	if err := json.Unmarshal(data, &valueDoubleOptional); err == nil {
		f.typeName = "doubleOptional"
		f.DoubleOptional = valueDoubleOptional
		return nil
	}
	var valueBooleanOptional *bool
	if err := json.Unmarshal(data, &valueBooleanOptional); err == nil {
		f.typeName = "booleanOptional"
		f.BooleanOptional = valueBooleanOptional
		return nil
	}
	var valueStringUnknownMapOptional map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMapOptional); err == nil {
		f.typeName = "stringUnknownMapOptional"
		f.StringUnknownMapOptional = valueStringUnknownMapOptional
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, f)
}

func (f FilterRuleProperty) MarshalJSON() ([]byte, error) {
	switch f.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringOptional":
		return json.Marshal(f.StringOptional)
	case "doubleOptional":
		return json.Marshal(f.DoubleOptional)
	case "booleanOptional":
		return json.Marshal(f.BooleanOptional)
	case "stringUnknownMapOptional":
		return json.Marshal(f.StringUnknownMapOptional)
	}
}

type FilterRulePropertyVisitor interface {
	VisitStringOptional(*string) error
	VisitDoubleOptional(*float64) error
	VisitBooleanOptional(*bool) error
	VisitStringUnknownMapOptional(map[string]interface{}) error
}

func (f *FilterRuleProperty) Accept(visitor FilterRulePropertyVisitor) error {
	switch f.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", f.typeName, f)
	case "stringOptional":
		return visitor.VisitStringOptional(f.StringOptional)
	case "doubleOptional":
		return visitor.VisitDoubleOptional(f.DoubleOptional)
	case "booleanOptional":
		return visitor.VisitBooleanOptional(f.BooleanOptional)
	case "stringUnknownMapOptional":
		return visitor.VisitStringUnknownMapOptional(f.StringUnknownMapOptional)
	}
}

type FilteredMeta string

const (
	FilteredMetaBody    FilteredMeta = "body"
	FilteredMetaHeaders FilteredMeta = "headers"
	FilteredMetaPath    FilteredMeta = "path"
	FilteredMetaQuery   FilteredMeta = "query"
)

func NewFilteredMetaFromString(s string) (FilteredMeta, error) {
	switch s {
	case "body":
		return FilteredMetaBody, nil
	case "headers":
		return FilteredMetaHeaders, nil
	case "path":
		return FilteredMetaPath, nil
	case "query":
		return FilteredMetaQuery, nil
	}
	var t FilteredMeta
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (f FilteredMeta) Ptr() *FilteredMeta {
	return &f
}

type HandledApiKeyIntegrationConfigs struct {
	ApiKey string `json:"api_key"`
}

type HandledHmacConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type HmacAlgorithms string

const (
	HmacAlgorithmsMd5    HmacAlgorithms = "md5"
	HmacAlgorithmsSha1   HmacAlgorithms = "sha1"
	HmacAlgorithmsSha256 HmacAlgorithms = "sha256"
	HmacAlgorithmsSha512 HmacAlgorithms = "sha512"
)

func NewHmacAlgorithmsFromString(s string) (HmacAlgorithms, error) {
	switch s {
	case "md5":
		return HmacAlgorithmsMd5, nil
	case "sha1":
		return HmacAlgorithmsSha1, nil
	case "sha256":
		return HmacAlgorithmsSha256, nil
	case "sha512":
		return HmacAlgorithmsSha512, nil
	}
	var t HmacAlgorithms
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HmacAlgorithms) Ptr() *HmacAlgorithms {
	return &h
}

type HmacIntegrationConfigs struct {
	WebhookSecretKey string                         `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms                 `json:"algorithm,omitempty"`
	HeaderKey        string                         `json:"header_key"`
	Encoding         HmacIntegrationConfigsEncoding `json:"encoding,omitempty"`
}

type HmacIntegrationConfigsEncoding string

const (
	HmacIntegrationConfigsEncodingBase64 HmacIntegrationConfigsEncoding = "base64"
	HmacIntegrationConfigsEncodingHex    HmacIntegrationConfigsEncoding = "hex"
)

func NewHmacIntegrationConfigsEncodingFromString(s string) (HmacIntegrationConfigsEncoding, error) {
	switch s {
	case "base64":
		return HmacIntegrationConfigsEncodingBase64, nil
	case "hex":
		return HmacIntegrationConfigsEncodingHex, nil
	}
	var t HmacIntegrationConfigsEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (h HmacIntegrationConfigsEncoding) Ptr() *HmacIntegrationConfigsEncoding {
	return &h
}

type IgnoredEvent struct {
	Id        string            `json:"id"`
	TeamId    string            `json:"team_id"`
	WebhookId string            `json:"webhook_id"`
	Cause     IgnoredEventCause `json:"cause,omitempty"`
	RequestId string            `json:"request_id"`
	Meta      *IgnoredEventMeta `json:"meta,omitempty"`
	UpdatedAt time.Time         `json:"updated_at"`
	CreatedAt time.Time         `json:"created_at"`
}

// Filter by the bulk retry ignored event query object
type IgnoredEventBulkRetryCreateRequestQuery struct {
	// The cause of the ignored event
	Cause *IgnoredEventBulkRetryCreateRequestQueryCause `json:"cause,omitempty"`
	// Connection ID of the ignored event
	WebhookId *IgnoredEventBulkRetryCreateRequestQueryWebhookId `json:"webhook_id,omitempty"`
	// The associated transformation ID (only applicable to the cause `TRANSFORMATION_FAILED`) <span style="white-space: nowrap">`<= 255 characters`</span>
	TransformationId *string `json:"transformation_id,omitempty"`
}

// The cause of the ignored event
type IgnoredEventBulkRetryCreateRequestQueryCause struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewIgnoredEventBulkRetryCreateRequestQueryCauseFromString(value string) *IgnoredEventBulkRetryCreateRequestQueryCause {
	return &IgnoredEventBulkRetryCreateRequestQueryCause{typeName: "string", String: value}
}

func NewIgnoredEventBulkRetryCreateRequestQueryCauseFromStringList(value []string) *IgnoredEventBulkRetryCreateRequestQueryCause {
	return &IgnoredEventBulkRetryCreateRequestQueryCause{typeName: "stringList", StringList: value}
}

func (i *IgnoredEventBulkRetryCreateRequestQueryCause) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IgnoredEventBulkRetryCreateRequestQueryCause) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IgnoredEventBulkRetryCreateRequestQueryCauseVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IgnoredEventBulkRetryCreateRequestQueryCause) Accept(visitor IgnoredEventBulkRetryCreateRequestQueryCauseVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Connection ID of the ignored event
type IgnoredEventBulkRetryCreateRequestQueryWebhookId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewIgnoredEventBulkRetryCreateRequestQueryWebhookIdFromString(value string) *IgnoredEventBulkRetryCreateRequestQueryWebhookId {
	return &IgnoredEventBulkRetryCreateRequestQueryWebhookId{typeName: "string", String: value}
}

func NewIgnoredEventBulkRetryCreateRequestQueryWebhookIdFromStringList(value []string) *IgnoredEventBulkRetryCreateRequestQueryWebhookId {
	return &IgnoredEventBulkRetryCreateRequestQueryWebhookId{typeName: "stringList", StringList: value}
}

func (i *IgnoredEventBulkRetryCreateRequestQueryWebhookId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IgnoredEventBulkRetryCreateRequestQueryWebhookId) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IgnoredEventBulkRetryCreateRequestQueryWebhookIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IgnoredEventBulkRetryCreateRequestQueryWebhookId) Accept(visitor IgnoredEventBulkRetryCreateRequestQueryWebhookIdVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

type IgnoredEventBulkRetryListRequestDir string

const (
	IgnoredEventBulkRetryListRequestDirAsc  IgnoredEventBulkRetryListRequestDir = "asc"
	IgnoredEventBulkRetryListRequestDirDesc IgnoredEventBulkRetryListRequestDir = "desc"
)

func NewIgnoredEventBulkRetryListRequestDirFromString(s string) (IgnoredEventBulkRetryListRequestDir, error) {
	switch s {
	case "asc":
		return IgnoredEventBulkRetryListRequestDirAsc, nil
	case "desc":
		return IgnoredEventBulkRetryListRequestDirDesc, nil
	}
	var t IgnoredEventBulkRetryListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IgnoredEventBulkRetryListRequestDir) Ptr() *IgnoredEventBulkRetryListRequestDir {
	return &i
}

type IgnoredEventBulkRetryPlanResponse struct {
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
}

type IgnoredEventCause string

const (
	IgnoredEventCauseArchived             IgnoredEventCause = "ARCHIVED"
	IgnoredEventCauseFiltered             IgnoredEventCause = "FILTERED"
	IgnoredEventCauseTransformationFailed IgnoredEventCause = "TRANSFORMATION_FAILED"
	IgnoredEventCauseCliDisconnected      IgnoredEventCause = "CLI_DISCONNECTED"
)

func NewIgnoredEventCauseFromString(s string) (IgnoredEventCause, error) {
	switch s {
	case "ARCHIVED":
		return IgnoredEventCauseArchived, nil
	case "FILTERED":
		return IgnoredEventCauseFiltered, nil
	case "TRANSFORMATION_FAILED":
		return IgnoredEventCauseTransformationFailed, nil
	case "CLI_DISCONNECTED":
		return IgnoredEventCauseCliDisconnected, nil
	}
	var t IgnoredEventCause
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IgnoredEventCause) Ptr() *IgnoredEventCause {
	return &i
}

type IgnoredEventMeta struct {
	typeName                 string
	FilteredMeta             FilteredMeta
	TransformationFailedMeta *TransformationFailedMeta
}

func NewIgnoredEventMetaFromFilteredMeta(value FilteredMeta) *IgnoredEventMeta {
	return &IgnoredEventMeta{typeName: "filteredMeta", FilteredMeta: value}
}

func NewIgnoredEventMetaFromTransformationFailedMeta(value *TransformationFailedMeta) *IgnoredEventMeta {
	return &IgnoredEventMeta{typeName: "transformationFailedMeta", TransformationFailedMeta: value}
}

func (i *IgnoredEventMeta) UnmarshalJSON(data []byte) error {
	var valueFilteredMeta FilteredMeta
	if err := json.Unmarshal(data, &valueFilteredMeta); err == nil {
		i.typeName = "filteredMeta"
		i.FilteredMeta = valueFilteredMeta
		return nil
	}
	valueTransformationFailedMeta := new(TransformationFailedMeta)
	if err := json.Unmarshal(data, &valueTransformationFailedMeta); err == nil {
		i.typeName = "transformationFailedMeta"
		i.TransformationFailedMeta = valueTransformationFailedMeta
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IgnoredEventMeta) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "filteredMeta":
		return json.Marshal(i.FilteredMeta)
	case "transformationFailedMeta":
		return json.Marshal(i.TransformationFailedMeta)
	}
}

type IgnoredEventMetaVisitor interface {
	VisitFilteredMeta(FilteredMeta) error
	VisitTransformationFailedMeta(*TransformationFailedMeta) error
}

func (i *IgnoredEventMeta) Accept(visitor IgnoredEventMetaVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "filteredMeta":
		return visitor.VisitFilteredMeta(i.FilteredMeta)
	case "transformationFailedMeta":
		return visitor.VisitTransformationFailedMeta(i.TransformationFailedMeta)
	}
}

type IgnoredEventPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*IgnoredEvent `json:"models,omitempty"`
}

type Integration struct {
	// ID of the integration
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// Label of the integration
	Label    string              `json:"label"`
	Provider IntegrationProvider `json:"provider,omitempty"`
	// List of features to enable (see features list below)
	Features []IntegrationFeature `json:"features,omitempty"`
	// Decrypted Key/Value object of the associated configuration for that provider
	Configs *IntegrationConfigs `json:"configs,omitempty"`
	// List of source IDs the integration is attached to
	Sources []string `json:"sources,omitempty"`
	// Date the integration was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the integration was created
	CreatedAt time.Time `json:"created_at"`
}

// Decrypted Key/Value object of the associated configuration for that provider
type IntegrationConfigs struct {
	typeName                        string
	HmacIntegrationConfigs          *HmacIntegrationConfigs
	ApiKeyIntegrationConfigs        *ApiKeyIntegrationConfigs
	HandledApiKeyIntegrationConfigs *HandledApiKeyIntegrationConfigs
	HandledHmacConfigs              *HandledHmacConfigs
	BasicAuthIntegrationConfigs     *BasicAuthIntegrationConfigs
	ShopifyIntegrationConfigs       *ShopifyIntegrationConfigs
	IntegrationConfigsSix           *IntegrationConfigsSix
}

func NewIntegrationConfigsFromHmacIntegrationConfigs(value *HmacIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "hmacIntegrationConfigs", HmacIntegrationConfigs: value}
}

func NewIntegrationConfigsFromApiKeyIntegrationConfigs(value *ApiKeyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "apiKeyIntegrationConfigs", ApiKeyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromHandledApiKeyIntegrationConfigs(value *HandledApiKeyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "handledApiKeyIntegrationConfigs", HandledApiKeyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromHandledHmacConfigs(value *HandledHmacConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "handledHmacConfigs", HandledHmacConfigs: value}
}

func NewIntegrationConfigsFromBasicAuthIntegrationConfigs(value *BasicAuthIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "basicAuthIntegrationConfigs", BasicAuthIntegrationConfigs: value}
}

func NewIntegrationConfigsFromShopifyIntegrationConfigs(value *ShopifyIntegrationConfigs) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "shopifyIntegrationConfigs", ShopifyIntegrationConfigs: value}
}

func NewIntegrationConfigsFromIntegrationConfigsSix(value *IntegrationConfigsSix) *IntegrationConfigs {
	return &IntegrationConfigs{typeName: "integrationConfigsSix", IntegrationConfigsSix: value}
}

func (i *IntegrationConfigs) UnmarshalJSON(data []byte) error {
	valueHmacIntegrationConfigs := new(HmacIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHmacIntegrationConfigs); err == nil {
		i.typeName = "hmacIntegrationConfigs"
		i.HmacIntegrationConfigs = valueHmacIntegrationConfigs
		return nil
	}
	valueApiKeyIntegrationConfigs := new(ApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueApiKeyIntegrationConfigs); err == nil {
		i.typeName = "apiKeyIntegrationConfigs"
		i.ApiKeyIntegrationConfigs = valueApiKeyIntegrationConfigs
		return nil
	}
	valueHandledApiKeyIntegrationConfigs := new(HandledApiKeyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueHandledApiKeyIntegrationConfigs); err == nil {
		i.typeName = "handledApiKeyIntegrationConfigs"
		i.HandledApiKeyIntegrationConfigs = valueHandledApiKeyIntegrationConfigs
		return nil
	}
	valueHandledHmacConfigs := new(HandledHmacConfigs)
	if err := json.Unmarshal(data, &valueHandledHmacConfigs); err == nil {
		i.typeName = "handledHmacConfigs"
		i.HandledHmacConfigs = valueHandledHmacConfigs
		return nil
	}
	valueBasicAuthIntegrationConfigs := new(BasicAuthIntegrationConfigs)
	if err := json.Unmarshal(data, &valueBasicAuthIntegrationConfigs); err == nil {
		i.typeName = "basicAuthIntegrationConfigs"
		i.BasicAuthIntegrationConfigs = valueBasicAuthIntegrationConfigs
		return nil
	}
	valueShopifyIntegrationConfigs := new(ShopifyIntegrationConfigs)
	if err := json.Unmarshal(data, &valueShopifyIntegrationConfigs); err == nil {
		i.typeName = "shopifyIntegrationConfigs"
		i.ShopifyIntegrationConfigs = valueShopifyIntegrationConfigs
		return nil
	}
	valueIntegrationConfigsSix := new(IntegrationConfigsSix)
	if err := json.Unmarshal(data, &valueIntegrationConfigsSix); err == nil {
		i.typeName = "integrationConfigsSix"
		i.IntegrationConfigsSix = valueIntegrationConfigsSix
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IntegrationConfigs) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "hmacIntegrationConfigs":
		return json.Marshal(i.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return json.Marshal(i.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return json.Marshal(i.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return json.Marshal(i.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return json.Marshal(i.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return json.Marshal(i.ShopifyIntegrationConfigs)
	case "integrationConfigsSix":
		return json.Marshal(i.IntegrationConfigsSix)
	}
}

type IntegrationConfigsVisitor interface {
	VisitHmacIntegrationConfigs(*HmacIntegrationConfigs) error
	VisitApiKeyIntegrationConfigs(*ApiKeyIntegrationConfigs) error
	VisitHandledApiKeyIntegrationConfigs(*HandledApiKeyIntegrationConfigs) error
	VisitHandledHmacConfigs(*HandledHmacConfigs) error
	VisitBasicAuthIntegrationConfigs(*BasicAuthIntegrationConfigs) error
	VisitShopifyIntegrationConfigs(*ShopifyIntegrationConfigs) error
	VisitIntegrationConfigsSix(*IntegrationConfigsSix) error
}

func (i *IntegrationConfigs) Accept(visitor IntegrationConfigsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "hmacIntegrationConfigs":
		return visitor.VisitHmacIntegrationConfigs(i.HmacIntegrationConfigs)
	case "apiKeyIntegrationConfigs":
		return visitor.VisitApiKeyIntegrationConfigs(i.ApiKeyIntegrationConfigs)
	case "handledApiKeyIntegrationConfigs":
		return visitor.VisitHandledApiKeyIntegrationConfigs(i.HandledApiKeyIntegrationConfigs)
	case "handledHmacConfigs":
		return visitor.VisitHandledHmacConfigs(i.HandledHmacConfigs)
	case "basicAuthIntegrationConfigs":
		return visitor.VisitBasicAuthIntegrationConfigs(i.BasicAuthIntegrationConfigs)
	case "shopifyIntegrationConfigs":
		return visitor.VisitShopifyIntegrationConfigs(i.ShopifyIntegrationConfigs)
	case "integrationConfigsSix":
		return visitor.VisitIntegrationConfigsSix(i.IntegrationConfigsSix)
	}
}

type IntegrationConfigsSix struct {
}

type IntegrationFeature string

const (
	IntegrationFeatureVerification IntegrationFeature = "VERIFICATION"
	IntegrationFeatureHandshake    IntegrationFeature = "HANDSHAKE"
	IntegrationFeaturePolling      IntegrationFeature = "POLLING"
)

func NewIntegrationFeatureFromString(s string) (IntegrationFeature, error) {
	switch s {
	case "VERIFICATION":
		return IntegrationFeatureVerification, nil
	case "HANDSHAKE":
		return IntegrationFeatureHandshake, nil
	case "POLLING":
		return IntegrationFeaturePolling, nil
	}
	var t IntegrationFeature
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationFeature) Ptr() *IntegrationFeature {
	return &i
}

type IntegrationPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Integration  `json:"models,omitempty"`
}

type IntegrationProvider string

const (
	IntegrationProviderHmac           IntegrationProvider = "hmac"
	IntegrationProviderBasicAuth      IntegrationProvider = "basic_auth"
	IntegrationProviderApiKey         IntegrationProvider = "api_key"
	IntegrationProviderTwitter        IntegrationProvider = "twitter"
	IntegrationProviderStripe         IntegrationProvider = "stripe"
	IntegrationProviderRecharge       IntegrationProvider = "recharge"
	IntegrationProviderGithub         IntegrationProvider = "github"
	IntegrationProviderShopify        IntegrationProvider = "shopify"
	IntegrationProviderPostmark       IntegrationProvider = "postmark"
	IntegrationProviderTypeform       IntegrationProvider = "typeform"
	IntegrationProviderXero           IntegrationProvider = "xero"
	IntegrationProviderSvix           IntegrationProvider = "svix"
	IntegrationProviderZoom           IntegrationProvider = "zoom"
	IntegrationProviderAkeneo         IntegrationProvider = "akeneo"
	IntegrationProviderAdyen          IntegrationProvider = "adyen"
	IntegrationProviderGitlab         IntegrationProvider = "gitlab"
	IntegrationProviderPropertyFinder IntegrationProvider = "property-finder"
	IntegrationProviderWoocommerce    IntegrationProvider = "woocommerce"
	IntegrationProviderOura           IntegrationProvider = "oura"
	IntegrationProviderCommercelayer  IntegrationProvider = "commercelayer"
	IntegrationProviderMailgun        IntegrationProvider = "mailgun"
	IntegrationProviderPipedrive      IntegrationProvider = "pipedrive"
	IntegrationProviderSendgrid       IntegrationProvider = "sendgrid"
	IntegrationProviderWorkos         IntegrationProvider = "workos"
	IntegrationProviderSynctera       IntegrationProvider = "synctera"
	IntegrationProviderAwsSns         IntegrationProvider = "aws_sns"
	IntegrationProviderThreeDEye      IntegrationProvider = "three_d_eye"
)

func NewIntegrationProviderFromString(s string) (IntegrationProvider, error) {
	switch s {
	case "hmac":
		return IntegrationProviderHmac, nil
	case "basic_auth":
		return IntegrationProviderBasicAuth, nil
	case "api_key":
		return IntegrationProviderApiKey, nil
	case "twitter":
		return IntegrationProviderTwitter, nil
	case "stripe":
		return IntegrationProviderStripe, nil
	case "recharge":
		return IntegrationProviderRecharge, nil
	case "github":
		return IntegrationProviderGithub, nil
	case "shopify":
		return IntegrationProviderShopify, nil
	case "postmark":
		return IntegrationProviderPostmark, nil
	case "typeform":
		return IntegrationProviderTypeform, nil
	case "xero":
		return IntegrationProviderXero, nil
	case "svix":
		return IntegrationProviderSvix, nil
	case "zoom":
		return IntegrationProviderZoom, nil
	case "akeneo":
		return IntegrationProviderAkeneo, nil
	case "adyen":
		return IntegrationProviderAdyen, nil
	case "gitlab":
		return IntegrationProviderGitlab, nil
	case "property-finder":
		return IntegrationProviderPropertyFinder, nil
	case "woocommerce":
		return IntegrationProviderWoocommerce, nil
	case "oura":
		return IntegrationProviderOura, nil
	case "commercelayer":
		return IntegrationProviderCommercelayer, nil
	case "mailgun":
		return IntegrationProviderMailgun, nil
	case "pipedrive":
		return IntegrationProviderPipedrive, nil
	case "sendgrid":
		return IntegrationProviderSendgrid, nil
	case "workos":
		return IntegrationProviderWorkos, nil
	case "synctera":
		return IntegrationProviderSynctera, nil
	case "aws_sns":
		return IntegrationProviderAwsSns, nil
	case "three_d_eye":
		return IntegrationProviderThreeDEye, nil
	}
	var t IntegrationProvider
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IntegrationProvider) Ptr() *IntegrationProvider {
	return &i
}

// Issue
type Issue struct {
	Type           string
	Delivery       *DeliveryIssue
	Transformation *TransformationIssue
}

func NewIssueFromDelivery(value *DeliveryIssue) *Issue {
	return &Issue{Type: "delivery", Delivery: value}
}

func NewIssueFromTransformation(value *TransformationIssue) *Issue {
	return &Issue{Type: "transformation", Transformation: value}
}

func (i *Issue) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "delivery":
		value := new(DeliveryIssue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Delivery = value
	case "transformation":
		value := new(TransformationIssue)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Transformation = value
	}
	return nil
}

func (i Issue) MarshalJSON() ([]byte, error) {
	switch i.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		var marshaler = struct {
			Type string `json:"type"`
			*DeliveryIssue
		}{
			Type:          i.Type,
			DeliveryIssue: i.Delivery,
		}
		return json.Marshal(marshaler)
	case "transformation":
		var marshaler = struct {
			Type string `json:"type"`
			*TransformationIssue
		}{
			Type:                i.Type,
			TransformationIssue: i.Transformation,
		}
		return json.Marshal(marshaler)
	}
}

type IssueVisitor interface {
	VisitDelivery(*DeliveryIssue) error
	VisitTransformation(*TransformationIssue) error
}

func (i *Issue) Accept(visitor IssueVisitor) error {
	switch i.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		return visitor.VisitDelivery(i.Delivery)
	case "transformation":
		return visitor.VisitTransformation(i.Transformation)
	}
}

type IssueCount struct {
	// Number of issues
	Count int `json:"count"`
}

type IssueCountRequestDir string

const (
	IssueCountRequestDirAsc  IssueCountRequestDir = "asc"
	IssueCountRequestDirDesc IssueCountRequestDir = "desc"
)

func NewIssueCountRequestDirFromString(s string) (IssueCountRequestDir, error) {
	switch s {
	case "asc":
		return IssueCountRequestDirAsc, nil
	case "desc":
		return IssueCountRequestDirDesc, nil
	}
	var t IssueCountRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueCountRequestDir) Ptr() *IssueCountRequestDir {
	return &i
}

type IssueCountRequestOrderBy string

const (
	IssueCountRequestOrderByCreatedAt   IssueCountRequestOrderBy = "created_at"
	IssueCountRequestOrderByFirstSeenAt IssueCountRequestOrderBy = "first_seen_at"
	IssueCountRequestOrderByLastSeenAt  IssueCountRequestOrderBy = "last_seen_at"
	IssueCountRequestOrderByOpenedAt    IssueCountRequestOrderBy = "opened_at"
	IssueCountRequestOrderByStatus      IssueCountRequestOrderBy = "status"
)

func NewIssueCountRequestOrderByFromString(s string) (IssueCountRequestOrderBy, error) {
	switch s {
	case "created_at":
		return IssueCountRequestOrderByCreatedAt, nil
	case "first_seen_at":
		return IssueCountRequestOrderByFirstSeenAt, nil
	case "last_seen_at":
		return IssueCountRequestOrderByLastSeenAt, nil
	case "opened_at":
		return IssueCountRequestOrderByOpenedAt, nil
	case "status":
		return IssueCountRequestOrderByStatus, nil
	}
	var t IssueCountRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueCountRequestOrderBy) Ptr() *IssueCountRequestOrderBy {
	return &i
}

// Issue status
type IssueCountRequestStatus string

const (
	IssueCountRequestStatusOpened       IssueCountRequestStatus = "OPENED"
	IssueCountRequestStatusIgnored      IssueCountRequestStatus = "IGNORED"
	IssueCountRequestStatusAcknowledged IssueCountRequestStatus = "ACKNOWLEDGED"
	IssueCountRequestStatusResolved     IssueCountRequestStatus = "RESOLVED"
)

func NewIssueCountRequestStatusFromString(s string) (IssueCountRequestStatus, error) {
	switch s {
	case "OPENED":
		return IssueCountRequestStatusOpened, nil
	case "IGNORED":
		return IssueCountRequestStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueCountRequestStatusAcknowledged, nil
	case "RESOLVED":
		return IssueCountRequestStatusResolved, nil
	}
	var t IssueCountRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueCountRequestStatus) Ptr() *IssueCountRequestStatus {
	return &i
}

// Issue type
type IssueCountRequestType string

const (
	IssueCountRequestTypeDelivery       IssueCountRequestType = "delivery"
	IssueCountRequestTypeTransformation IssueCountRequestType = "transformation"
	IssueCountRequestTypeBackpressure   IssueCountRequestType = "backpressure"
)

func NewIssueCountRequestTypeFromString(s string) (IssueCountRequestType, error) {
	switch s {
	case "delivery":
		return IssueCountRequestTypeDelivery, nil
	case "transformation":
		return IssueCountRequestTypeTransformation, nil
	case "backpressure":
		return IssueCountRequestTypeBackpressure, nil
	}
	var t IssueCountRequestType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueCountRequestType) Ptr() *IssueCountRequestType {
	return &i
}

type IssueListRequestDir string

const (
	IssueListRequestDirAsc  IssueListRequestDir = "asc"
	IssueListRequestDirDesc IssueListRequestDir = "desc"
)

func NewIssueListRequestDirFromString(s string) (IssueListRequestDir, error) {
	switch s {
	case "asc":
		return IssueListRequestDirAsc, nil
	case "desc":
		return IssueListRequestDirDesc, nil
	}
	var t IssueListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueListRequestDir) Ptr() *IssueListRequestDir {
	return &i
}

type IssueListRequestOrderBy string

const (
	IssueListRequestOrderByCreatedAt   IssueListRequestOrderBy = "created_at"
	IssueListRequestOrderByFirstSeenAt IssueListRequestOrderBy = "first_seen_at"
	IssueListRequestOrderByLastSeenAt  IssueListRequestOrderBy = "last_seen_at"
	IssueListRequestOrderByOpenedAt    IssueListRequestOrderBy = "opened_at"
	IssueListRequestOrderByStatus      IssueListRequestOrderBy = "status"
)

func NewIssueListRequestOrderByFromString(s string) (IssueListRequestOrderBy, error) {
	switch s {
	case "created_at":
		return IssueListRequestOrderByCreatedAt, nil
	case "first_seen_at":
		return IssueListRequestOrderByFirstSeenAt, nil
	case "last_seen_at":
		return IssueListRequestOrderByLastSeenAt, nil
	case "opened_at":
		return IssueListRequestOrderByOpenedAt, nil
	case "status":
		return IssueListRequestOrderByStatus, nil
	}
	var t IssueListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueListRequestOrderBy) Ptr() *IssueListRequestOrderBy {
	return &i
}

// Issue status
type IssueListRequestStatus string

const (
	IssueListRequestStatusOpened       IssueListRequestStatus = "OPENED"
	IssueListRequestStatusIgnored      IssueListRequestStatus = "IGNORED"
	IssueListRequestStatusAcknowledged IssueListRequestStatus = "ACKNOWLEDGED"
	IssueListRequestStatusResolved     IssueListRequestStatus = "RESOLVED"
)

func NewIssueListRequestStatusFromString(s string) (IssueListRequestStatus, error) {
	switch s {
	case "OPENED":
		return IssueListRequestStatusOpened, nil
	case "IGNORED":
		return IssueListRequestStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueListRequestStatusAcknowledged, nil
	case "RESOLVED":
		return IssueListRequestStatusResolved, nil
	}
	var t IssueListRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueListRequestStatus) Ptr() *IssueListRequestStatus {
	return &i
}

// Issue type
type IssueListRequestType string

const (
	IssueListRequestTypeDelivery       IssueListRequestType = "delivery"
	IssueListRequestTypeTransformation IssueListRequestType = "transformation"
	IssueListRequestTypeBackpressure   IssueListRequestType = "backpressure"
)

func NewIssueListRequestTypeFromString(s string) (IssueListRequestType, error) {
	switch s {
	case "delivery":
		return IssueListRequestTypeDelivery, nil
	case "transformation":
		return IssueListRequestTypeTransformation, nil
	case "backpressure":
		return IssueListRequestTypeBackpressure, nil
	}
	var t IssueListRequestType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueListRequestType) Ptr() *IssueListRequestType {
	return &i
}

// Issue status
type IssueStatus string

const (
	IssueStatusOpened       IssueStatus = "OPENED"
	IssueStatusIgnored      IssueStatus = "IGNORED"
	IssueStatusAcknowledged IssueStatus = "ACKNOWLEDGED"
	IssueStatusResolved     IssueStatus = "RESOLVED"
)

func NewIssueStatusFromString(s string) (IssueStatus, error) {
	switch s {
	case "OPENED":
		return IssueStatusOpened, nil
	case "IGNORED":
		return IssueStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueStatusAcknowledged, nil
	case "RESOLVED":
		return IssueStatusResolved, nil
	}
	var t IssueStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueStatus) Ptr() *IssueStatus {
	return &i
}

type IssueTrigger struct {
	// ID of the issue trigger
	Id string `json:"id"`
	// ID of the workspace
	TeamId *string `json:"team_id,omitempty"`
	// Optional unique name to use as reference when using the API
	Name     *string                `json:"name,omitempty"`
	Type     IssueType              `json:"type,omitempty"`
	Configs  *IssueTriggerReference `json:"configs,omitempty"`
	Channels *IssueTriggerChannels  `json:"channels,omitempty"`
	// ISO timestamp for when the issue trigger was disabled
	DisabledAt *time.Time `json:"disabled_at,omitempty"`
	// ISO timestamp for when the issue trigger was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// ISO timestamp for when the issue trigger was created
	CreatedAt time.Time `json:"created_at"`
	// ISO timestamp for when the issue trigger was deleted
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
}

// Configurations for a 'Backpressure' issue trigger
type IssueTriggerBackpressureConfigs struct {
	Delay IssueTriggerBackpressureDelay `json:"delay"`
	// A pattern to match on the destination name or array of destination IDs. Use `*` as wildcard.
	Destinations *IssueTriggerBackpressureConfigsDestinations `json:"destinations,omitempty"`
}

// A pattern to match on the destination name or array of destination IDs. Use `*` as wildcard.
type IssueTriggerBackpressureConfigsDestinations struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerBackpressureConfigsDestinationsFromString(value string) *IssueTriggerBackpressureConfigsDestinations {
	return &IssueTriggerBackpressureConfigsDestinations{typeName: "string", String: value}
}

func NewIssueTriggerBackpressureConfigsDestinationsFromStringList(value []string) *IssueTriggerBackpressureConfigsDestinations {
	return &IssueTriggerBackpressureConfigsDestinations{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerBackpressureConfigsDestinations) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerBackpressureConfigsDestinations) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerBackpressureConfigsDestinationsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerBackpressureConfigsDestinations) Accept(visitor IssueTriggerBackpressureConfigsDestinationsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// The minimum delay (backpressure) to open the issue for min of 1 minute (60000) and max of 1 day (86400000)
type IssueTriggerBackpressureDelay = int

// Notification channels object for the specific channel type
type IssueTriggerChannels struct {
	Slack    *IssueTriggerSlackChannel       `json:"slack,omitempty"`
	Opsgenie *IssueTriggerIntegrationChannel `json:"opsgenie,omitempty"`
	Email    *IssueTriggerEmailChannel       `json:"email,omitempty"`
}

// Configuration object for the specific issue type selected
type IssueTriggerCreateRequestConfigs struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewIssueTriggerCreateRequestConfigsFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerCreateRequestConfigs {
	return &IssueTriggerCreateRequestConfigs{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerCreateRequestConfigsFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerCreateRequestConfigs {
	return &IssueTriggerCreateRequestConfigs{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerCreateRequestConfigsFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerCreateRequestConfigs {
	return &IssueTriggerCreateRequestConfigs{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerCreateRequestConfigs) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typeName = "issueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typeName = "issueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typeName = "issueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerCreateRequestConfigs) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
}

type IssueTriggerCreateRequestConfigsVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerCreateRequestConfigs) Accept(visitor IssueTriggerCreateRequestConfigsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
}

// Configurations for a 'delivery' issue trigger
type IssueTriggerDeliveryConfigs struct {
	Strategy IssueTriggerStrategy `json:"strategy,omitempty"`
	// A pattern to match on the connection name or array of connection IDs. Use `*` as wildcard.
	Connections *IssueTriggerDeliveryConfigsConnections `json:"connections,omitempty"`
}

// A pattern to match on the connection name or array of connection IDs. Use `*` as wildcard.
type IssueTriggerDeliveryConfigsConnections struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerDeliveryConfigsConnectionsFromString(value string) *IssueTriggerDeliveryConfigsConnections {
	return &IssueTriggerDeliveryConfigsConnections{typeName: "string", String: value}
}

func NewIssueTriggerDeliveryConfigsConnectionsFromStringList(value []string) *IssueTriggerDeliveryConfigsConnections {
	return &IssueTriggerDeliveryConfigsConnections{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerDeliveryConfigsConnections) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerDeliveryConfigsConnections) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerDeliveryConfigsConnectionsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerDeliveryConfigsConnections) Accept(visitor IssueTriggerDeliveryConfigsConnectionsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Email channel for an issue trigger
type IssueTriggerEmailChannel struct {
}

// Integration channel for an issue trigger
type IssueTriggerIntegrationChannel struct {
}

type IssueTriggerListRequestDir string

const (
	IssueTriggerListRequestDirAsc  IssueTriggerListRequestDir = "asc"
	IssueTriggerListRequestDirDesc IssueTriggerListRequestDir = "desc"
)

func NewIssueTriggerListRequestDirFromString(s string) (IssueTriggerListRequestDir, error) {
	switch s {
	case "asc":
		return IssueTriggerListRequestDirAsc, nil
	case "desc":
		return IssueTriggerListRequestDirDesc, nil
	}
	var t IssueTriggerListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueTriggerListRequestDir) Ptr() *IssueTriggerListRequestDir {
	return &i
}

type IssueTriggerListRequestOrderBy string

const (
	IssueTriggerListRequestOrderByCreatedAt IssueTriggerListRequestOrderBy = "created_at"
	IssueTriggerListRequestOrderByType      IssueTriggerListRequestOrderBy = "type"
)

func NewIssueTriggerListRequestOrderByFromString(s string) (IssueTriggerListRequestOrderBy, error) {
	switch s {
	case "created_at":
		return IssueTriggerListRequestOrderByCreatedAt, nil
	case "type":
		return IssueTriggerListRequestOrderByType, nil
	}
	var t IssueTriggerListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueTriggerListRequestOrderBy) Ptr() *IssueTriggerListRequestOrderBy {
	return &i
}

type IssueTriggerPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*IssueTrigger `json:"models,omitempty"`
}

// Configuration object for the specific issue type selected
type IssueTriggerReference struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewIssueTriggerReferenceFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerReferenceFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerReferenceFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerReference {
	return &IssueTriggerReference{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerReference) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typeName = "issueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typeName = "issueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typeName = "issueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerReference) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
}

type IssueTriggerReferenceVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerReference) Accept(visitor IssueTriggerReferenceVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
}

// Slack channel for an issue trigger
type IssueTriggerSlackChannel struct {
	// Channel name
	ChannelName string `json:"channel_name"`
}

// The strategy uses to open the issue
type IssueTriggerStrategy string

const (
	IssueTriggerStrategyFirstAttempt IssueTriggerStrategy = "first_attempt"
	IssueTriggerStrategyFinalAttempt IssueTriggerStrategy = "final_attempt"
)

func NewIssueTriggerStrategyFromString(s string) (IssueTriggerStrategy, error) {
	switch s {
	case "first_attempt":
		return IssueTriggerStrategyFirstAttempt, nil
	case "final_attempt":
		return IssueTriggerStrategyFinalAttempt, nil
	}
	var t IssueTriggerStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueTriggerStrategy) Ptr() *IssueTriggerStrategy {
	return &i
}

// Configurations for a 'Transformation' issue trigger
type IssueTriggerTransformationConfigs struct {
	LogLevel TransformationExecutionLogLevel `json:"log_level,omitempty"`
	// A pattern to match on the transformation name or array of transformation IDs. Use `*` as wildcard.
	Transformations *IssueTriggerTransformationConfigsTransformations `json:"transformations,omitempty"`
}

// A pattern to match on the transformation name or array of transformation IDs. Use `*` as wildcard.
type IssueTriggerTransformationConfigsTransformations struct {
	typeName   string
	String     string
	StringList []string
}

func NewIssueTriggerTransformationConfigsTransformationsFromString(value string) *IssueTriggerTransformationConfigsTransformations {
	return &IssueTriggerTransformationConfigsTransformations{typeName: "string", String: value}
}

func NewIssueTriggerTransformationConfigsTransformationsFromStringList(value []string) *IssueTriggerTransformationConfigsTransformations {
	return &IssueTriggerTransformationConfigsTransformations{typeName: "stringList", StringList: value}
}

func (i *IssueTriggerTransformationConfigsTransformations) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		i.typeName = "string"
		i.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		i.typeName = "stringList"
		i.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerTransformationConfigsTransformations) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return json.Marshal(i.String)
	case "stringList":
		return json.Marshal(i.StringList)
	}
}

type IssueTriggerTransformationConfigsTransformationsVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (i *IssueTriggerTransformationConfigsTransformations) Accept(visitor IssueTriggerTransformationConfigsTransformationsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "string":
		return visitor.VisitString(i.String)
	case "stringList":
		return visitor.VisitStringList(i.StringList)
	}
}

// Configuration object for the specific issue type selected
type IssueTriggerUpdateRequestConfigs struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewIssueTriggerUpdateRequestConfigsFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerUpdateRequestConfigs {
	return &IssueTriggerUpdateRequestConfigs{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerUpdateRequestConfigsFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerUpdateRequestConfigs {
	return &IssueTriggerUpdateRequestConfigs{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerUpdateRequestConfigsFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerUpdateRequestConfigs {
	return &IssueTriggerUpdateRequestConfigs{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerUpdateRequestConfigs) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typeName = "issueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typeName = "issueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typeName = "issueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerUpdateRequestConfigs) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
}

type IssueTriggerUpdateRequestConfigsVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerUpdateRequestConfigs) Accept(visitor IssueTriggerUpdateRequestConfigsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
}

// Configuration object for the specific issue type selected
type IssueTriggerUpsertRequestConfigs struct {
	typeName                          string
	IssueTriggerDeliveryConfigs       *IssueTriggerDeliveryConfigs
	IssueTriggerTransformationConfigs *IssueTriggerTransformationConfigs
	IssueTriggerBackpressureConfigs   *IssueTriggerBackpressureConfigs
}

func NewIssueTriggerUpsertRequestConfigsFromIssueTriggerDeliveryConfigs(value *IssueTriggerDeliveryConfigs) *IssueTriggerUpsertRequestConfigs {
	return &IssueTriggerUpsertRequestConfigs{typeName: "issueTriggerDeliveryConfigs", IssueTriggerDeliveryConfigs: value}
}

func NewIssueTriggerUpsertRequestConfigsFromIssueTriggerTransformationConfigs(value *IssueTriggerTransformationConfigs) *IssueTriggerUpsertRequestConfigs {
	return &IssueTriggerUpsertRequestConfigs{typeName: "issueTriggerTransformationConfigs", IssueTriggerTransformationConfigs: value}
}

func NewIssueTriggerUpsertRequestConfigsFromIssueTriggerBackpressureConfigs(value *IssueTriggerBackpressureConfigs) *IssueTriggerUpsertRequestConfigs {
	return &IssueTriggerUpsertRequestConfigs{typeName: "issueTriggerBackpressureConfigs", IssueTriggerBackpressureConfigs: value}
}

func (i *IssueTriggerUpsertRequestConfigs) UnmarshalJSON(data []byte) error {
	valueIssueTriggerDeliveryConfigs := new(IssueTriggerDeliveryConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerDeliveryConfigs); err == nil {
		i.typeName = "issueTriggerDeliveryConfigs"
		i.IssueTriggerDeliveryConfigs = valueIssueTriggerDeliveryConfigs
		return nil
	}
	valueIssueTriggerTransformationConfigs := new(IssueTriggerTransformationConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerTransformationConfigs); err == nil {
		i.typeName = "issueTriggerTransformationConfigs"
		i.IssueTriggerTransformationConfigs = valueIssueTriggerTransformationConfigs
		return nil
	}
	valueIssueTriggerBackpressureConfigs := new(IssueTriggerBackpressureConfigs)
	if err := json.Unmarshal(data, &valueIssueTriggerBackpressureConfigs); err == nil {
		i.typeName = "issueTriggerBackpressureConfigs"
		i.IssueTriggerBackpressureConfigs = valueIssueTriggerBackpressureConfigs
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, i)
}

func (i IssueTriggerUpsertRequestConfigs) MarshalJSON() ([]byte, error) {
	switch i.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return json.Marshal(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return json.Marshal(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return json.Marshal(i.IssueTriggerBackpressureConfigs)
	}
}

type IssueTriggerUpsertRequestConfigsVisitor interface {
	VisitIssueTriggerDeliveryConfigs(*IssueTriggerDeliveryConfigs) error
	VisitIssueTriggerTransformationConfigs(*IssueTriggerTransformationConfigs) error
	VisitIssueTriggerBackpressureConfigs(*IssueTriggerBackpressureConfigs) error
}

func (i *IssueTriggerUpsertRequestConfigs) Accept(visitor IssueTriggerUpsertRequestConfigsVisitor) error {
	switch i.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", i.typeName, i)
	case "issueTriggerDeliveryConfigs":
		return visitor.VisitIssueTriggerDeliveryConfigs(i.IssueTriggerDeliveryConfigs)
	case "issueTriggerTransformationConfigs":
		return visitor.VisitIssueTriggerTransformationConfigs(i.IssueTriggerTransformationConfigs)
	case "issueTriggerBackpressureConfigs":
		return visitor.VisitIssueTriggerBackpressureConfigs(i.IssueTriggerBackpressureConfigs)
	}
}

// Issue type
type IssueType string

const (
	IssueTypeDelivery       IssueType = "delivery"
	IssueTypeTransformation IssueType = "transformation"
	IssueTypeBackpressure   IssueType = "backpressure"
)

func NewIssueTypeFromString(s string) (IssueType, error) {
	switch s {
	case "delivery":
		return IssueTypeDelivery, nil
	case "transformation":
		return IssueTypeTransformation, nil
	case "backpressure":
		return IssueTypeBackpressure, nil
	}
	var t IssueType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueType) Ptr() *IssueType {
	return &i
}

// New status
type IssueUpdateRequestStatus string

const (
	IssueUpdateRequestStatusOpened       IssueUpdateRequestStatus = "OPENED"
	IssueUpdateRequestStatusIgnored      IssueUpdateRequestStatus = "IGNORED"
	IssueUpdateRequestStatusAcknowledged IssueUpdateRequestStatus = "ACKNOWLEDGED"
	IssueUpdateRequestStatusResolved     IssueUpdateRequestStatus = "RESOLVED"
)

func NewIssueUpdateRequestStatusFromString(s string) (IssueUpdateRequestStatus, error) {
	switch s {
	case "OPENED":
		return IssueUpdateRequestStatusOpened, nil
	case "IGNORED":
		return IssueUpdateRequestStatusIgnored, nil
	case "ACKNOWLEDGED":
		return IssueUpdateRequestStatusAcknowledged, nil
	case "RESOLVED":
		return IssueUpdateRequestStatusResolved, nil
	}
	var t IssueUpdateRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (i IssueUpdateRequestStatus) Ptr() *IssueUpdateRequestStatus {
	return &i
}

type IssueWithData struct {
	Type           string
	Delivery       *DeliveryIssueWithData
	Transformation *TransformationIssueWithData
}

func NewIssueWithDataFromDelivery(value *DeliveryIssueWithData) *IssueWithData {
	return &IssueWithData{Type: "delivery", Delivery: value}
}

func NewIssueWithDataFromTransformation(value *TransformationIssueWithData) *IssueWithData {
	return &IssueWithData{Type: "transformation", Transformation: value}
}

func (i *IssueWithData) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	i.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "delivery":
		value := new(DeliveryIssueWithData)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Delivery = value
	case "transformation":
		value := new(TransformationIssueWithData)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		i.Transformation = value
	}
	return nil
}

func (i IssueWithData) MarshalJSON() ([]byte, error) {
	switch i.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		var marshaler = struct {
			Type string `json:"type"`
			*DeliveryIssueWithData
		}{
			Type:                  i.Type,
			DeliveryIssueWithData: i.Delivery,
		}
		return json.Marshal(marshaler)
	case "transformation":
		var marshaler = struct {
			Type string `json:"type"`
			*TransformationIssueWithData
		}{
			Type:                        i.Type,
			TransformationIssueWithData: i.Transformation,
		}
		return json.Marshal(marshaler)
	}
}

type IssueWithDataVisitor interface {
	VisitDelivery(*DeliveryIssueWithData) error
	VisitTransformation(*TransformationIssueWithData) error
}

func (i *IssueWithData) Accept(visitor IssueWithDataVisitor) error {
	switch i.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", i.Type, i)
	case "delivery":
		return visitor.VisitDelivery(i.Delivery)
	case "transformation":
		return visitor.VisitTransformation(i.Transformation)
	}
}

type IssueWithDataPaginatedResult struct {
	Pagination *SeekPagination  `json:"pagination,omitempty"`
	Count      *int             `json:"count,omitempty"`
	Models     []*IssueWithData `json:"models,omitempty"`
}

type ListCustomDomainSchema = []*ListCustomDomainSchemaItem

type ListCustomDomainSchemaItem struct {
	Id                    *string                                          `json:"id,omitempty"`
	Hostname              *string                                          `json:"hostname,omitempty"`
	Status                *string                                          `json:"status,omitempty"`
	Ssl                   *ListCustomDomainSchemaItemSsl                   `json:"ssl,omitempty"`
	VerificationErrors    []string                                         `json:"verification_errors,omitempty"`
	OwnershipVerification *ListCustomDomainSchemaItemOwnershipVerification `json:"ownership_verification,omitempty"`
	CreatedAt             *string                                          `json:"created_at,omitempty"`
}

type ListCustomDomainSchemaItemOwnershipVerification struct {
	Type  *string `json:"type,omitempty"`
	Name  *string `json:"name,omitempty"`
	Value *string `json:"value,omitempty"`
}

type ListCustomDomainSchemaItemSsl struct {
	Id                   *string                                                  `json:"id,omitempty"`
	Type                 *string                                                  `json:"type,omitempty"`
	Method               *string                                                  `json:"method,omitempty"`
	Status               *string                                                  `json:"status,omitempty"`
	TxtName              *string                                                  `json:"txt_name,omitempty"`
	TxtValue             *string                                                  `json:"txt_value,omitempty"`
	ValidationRecords    []*ListCustomDomainSchemaItemSslValidationRecordsItem    `json:"validation_records,omitempty"`
	DcvDelegationRecords []*ListCustomDomainSchemaItemSslDcvDelegationRecordsItem `json:"dcv_delegation_records,omitempty"`
	Settings             *ListCustomDomainSchemaItemSslSettings                   `json:"settings,omitempty"`
	BundleMethod         *string                                                  `json:"bundle_method,omitempty"`
	Wildcard             *bool                                                    `json:"wildcard,omitempty"`
	CertificateAuthority *string                                                  `json:"certificate_authority,omitempty"`
}

type ListCustomDomainSchemaItemSslDcvDelegationRecordsItem struct {
	Cname       *string `json:"cname,omitempty"`
	CnameTarget *string `json:"cname_target,omitempty"`
}

type ListCustomDomainSchemaItemSslSettings struct {
	MinTlsVersion *string `json:"min_tls_version,omitempty"`
}

type ListCustomDomainSchemaItemSslValidationRecordsItem struct {
	Status   *string `json:"status,omitempty"`
	TxtName  *string `json:"txt_name,omitempty"`
	TxtValue *string `json:"txt_value,omitempty"`
}

type OrderByDirection string

const (
	OrderByDirectionasc  OrderByDirection = "asc"
	OrderByDirectiondesc OrderByDirection = "desc"
	OrderByDirectionASC  OrderByDirection = "ASC"
	OrderByDirectionDESC OrderByDirection = "DESC"
)

func NewOrderByDirectionFromString(s string) (OrderByDirection, error) {
	switch s {
	case "asc":
		return OrderByDirectionasc, nil
	case "desc":
		return OrderByDirectiondesc, nil
	case "ASC":
		return OrderByDirectionASC, nil
	case "DESC":
		return OrderByDirectionDESC, nil
	}
	var t OrderByDirection
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (o OrderByDirection) Ptr() *OrderByDirection {
	return &o
}

type RawBody struct {
	Body string `json:"body"`
}

type Request struct {
	// ID of the request
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// Whether or not the request was verified when received
	Verified *bool `json:"verified,omitempty"`
	// ID of the request data
	OriginalEventDataId *string               `json:"original_event_data_id,omitempty"`
	RejectionCause      RequestRejectionCause `json:"rejection_cause,omitempty"`
	// The priority attributed to the request when received
	IngestPriority *RequestIngestPriority `json:"ingest_priority,omitempty"`
	// The time the request was originally received
	IngestedAt *time.Time `json:"ingested_at,omitempty"`
	// ID of the associated source
	SourceId string `json:"source_id"`
	// The count of events created from this request (CLI events not included)
	EventsCount *int `json:"events_count,omitempty"`
	// The count of CLI events created from this request
	CliEventsCount *int `json:"cli_events_count,omitempty"`
	IgnoredCount   *int `json:"ignored_count,omitempty"`
	// Date the event was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the event was created
	CreatedAt time.Time       `json:"created_at"`
	Data      *ShortEventData `json:"data,omitempty"`
}

// Filter properties for the events to be included in the bulk retry, use query parameters of [Requests](#requests)
type RequestBulkRetryCreateRequestQuery struct {
	// Filter by requests IDs
	Id *RequestBulkRetryCreateRequestQueryId `json:"id,omitempty"`
	// Filter by status
	Status *RequestBulkRetryCreateRequestQueryStatus `json:"status,omitempty"`
	// Filter by rejection cause
	RejectionCause *RequestBulkRetryCreateRequestQueryRejectionCause `json:"rejection_cause,omitempty"`
	// Filter by source IDs
	SourceId *RequestBulkRetryCreateRequestQuerySourceId `json:"source_id,omitempty"`
	// Filter by verification status
	Verified *bool `json:"verified,omitempty"`
	// URL Encoded string of the value to match partially to the body, headers, parsed_query or path
	SearchTerm *string `json:"search_term,omitempty"`
	// URL Encoded string of the JSON to match to the data headers
	Headers *RequestBulkRetryCreateRequestQueryHeaders `json:"headers,omitempty"`
	// URL Encoded string of the JSON to match to the data body
	Body *RequestBulkRetryCreateRequestQueryBody `json:"body,omitempty"`
	// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
	ParsedQuery *RequestBulkRetryCreateRequestQueryParsedQuery `json:"parsed_query,omitempty"`
	// URL Encoded string of the value to match partially to the path
	Path *string `json:"path,omitempty"`
	// Filter by count of ignored events
	IgnoredCount *RequestBulkRetryCreateRequestQueryIgnoredCount `json:"ignored_count,omitempty"`
	// Filter by count of events
	EventsCount *RequestBulkRetryCreateRequestQueryEventsCount `json:"events_count,omitempty"`
	// Filter by event ingested date
	IngestedAt  *RequestBulkRetryCreateRequestQueryIngestedAt  `json:"ingested_at,omitempty"`
	BulkRetryId *RequestBulkRetryCreateRequestQueryBulkRetryId `json:"bulk_retry_id,omitempty"`
}

// URL Encoded string of the JSON to match to the data body
type RequestBulkRetryCreateRequestQueryBody struct {
	typeName                                  string
	String                                    string
	RequestBulkRetryCreateRequestQueryBodyOne *RequestBulkRetryCreateRequestQueryBodyOne
}

func NewRequestBulkRetryCreateRequestQueryBodyFromString(value string) *RequestBulkRetryCreateRequestQueryBody {
	return &RequestBulkRetryCreateRequestQueryBody{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryBodyFromRequestBulkRetryCreateRequestQueryBodyOne(value *RequestBulkRetryCreateRequestQueryBodyOne) *RequestBulkRetryCreateRequestQueryBody {
	return &RequestBulkRetryCreateRequestQueryBody{typeName: "requestBulkRetryCreateRequestQueryBodyOne", RequestBulkRetryCreateRequestQueryBodyOne: value}
}

func (r *RequestBulkRetryCreateRequestQueryBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryBodyOne := new(RequestBulkRetryCreateRequestQueryBodyOne)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryBodyOne); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryBodyOne"
		r.RequestBulkRetryCreateRequestQueryBodyOne = valueRequestBulkRetryCreateRequestQueryBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryBody) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "requestBulkRetryCreateRequestQueryBodyOne":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryBodyOne)
	}
}

type RequestBulkRetryCreateRequestQueryBodyVisitor interface {
	VisitString(string) error
	VisitRequestBulkRetryCreateRequestQueryBodyOne(*RequestBulkRetryCreateRequestQueryBodyOne) error
}

func (r *RequestBulkRetryCreateRequestQueryBody) Accept(visitor RequestBulkRetryCreateRequestQueryBodyVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "requestBulkRetryCreateRequestQueryBodyOne":
		return visitor.VisitRequestBulkRetryCreateRequestQueryBodyOne(r.RequestBulkRetryCreateRequestQueryBodyOne)
	}
}

type RequestBulkRetryCreateRequestQueryBodyOne struct {
}

type RequestBulkRetryCreateRequestQueryBulkRetryId struct {
	typeName string
	// <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewRequestBulkRetryCreateRequestQueryBulkRetryIdFromString(value string) *RequestBulkRetryCreateRequestQueryBulkRetryId {
	return &RequestBulkRetryCreateRequestQueryBulkRetryId{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryBulkRetryIdFromStringList(value []string) *RequestBulkRetryCreateRequestQueryBulkRetryId {
	return &RequestBulkRetryCreateRequestQueryBulkRetryId{typeName: "stringList", StringList: value}
}

func (r *RequestBulkRetryCreateRequestQueryBulkRetryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		r.typeName = "stringList"
		r.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryBulkRetryId) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "stringList":
		return json.Marshal(r.StringList)
	}
}

type RequestBulkRetryCreateRequestQueryBulkRetryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (r *RequestBulkRetryCreateRequestQueryBulkRetryId) Accept(visitor RequestBulkRetryCreateRequestQueryBulkRetryIdVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "stringList":
		return visitor.VisitStringList(r.StringList)
	}
}

// Filter by count of events
type RequestBulkRetryCreateRequestQueryEventsCount struct {
	typeName                                         string
	Integer                                          int
	RequestBulkRetryCreateRequestQueryEventsCountAny *RequestBulkRetryCreateRequestQueryEventsCountAny
	IntegerList                                      []int
}

func NewRequestBulkRetryCreateRequestQueryEventsCountFromInteger(value int) *RequestBulkRetryCreateRequestQueryEventsCount {
	return &RequestBulkRetryCreateRequestQueryEventsCount{typeName: "integer", Integer: value}
}

func NewRequestBulkRetryCreateRequestQueryEventsCountFromRequestBulkRetryCreateRequestQueryEventsCountAny(value *RequestBulkRetryCreateRequestQueryEventsCountAny) *RequestBulkRetryCreateRequestQueryEventsCount {
	return &RequestBulkRetryCreateRequestQueryEventsCount{typeName: "requestBulkRetryCreateRequestQueryEventsCountAny", RequestBulkRetryCreateRequestQueryEventsCountAny: value}
}

func NewRequestBulkRetryCreateRequestQueryEventsCountFromIntegerList(value []int) *RequestBulkRetryCreateRequestQueryEventsCount {
	return &RequestBulkRetryCreateRequestQueryEventsCount{typeName: "integerList", IntegerList: value}
}

func (r *RequestBulkRetryCreateRequestQueryEventsCount) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		r.typeName = "integer"
		r.Integer = valueInteger
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryEventsCountAny := new(RequestBulkRetryCreateRequestQueryEventsCountAny)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryEventsCountAny); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryEventsCountAny"
		r.RequestBulkRetryCreateRequestQueryEventsCountAny = valueRequestBulkRetryCreateRequestQueryEventsCountAny
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		r.typeName = "integerList"
		r.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryEventsCount) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return json.Marshal(r.Integer)
	case "requestBulkRetryCreateRequestQueryEventsCountAny":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryEventsCountAny)
	case "integerList":
		return json.Marshal(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryEventsCountVisitor interface {
	VisitInteger(int) error
	VisitRequestBulkRetryCreateRequestQueryEventsCountAny(*RequestBulkRetryCreateRequestQueryEventsCountAny) error
	VisitIntegerList([]int) error
}

func (r *RequestBulkRetryCreateRequestQueryEventsCount) Accept(visitor RequestBulkRetryCreateRequestQueryEventsCountVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return visitor.VisitInteger(r.Integer)
	case "requestBulkRetryCreateRequestQueryEventsCountAny":
		return visitor.VisitRequestBulkRetryCreateRequestQueryEventsCountAny(r.RequestBulkRetryCreateRequestQueryEventsCountAny)
	case "integerList":
		return visitor.VisitIntegerList(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryEventsCountAny struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// URL Encoded string of the JSON to match to the data headers
type RequestBulkRetryCreateRequestQueryHeaders struct {
	typeName                                     string
	String                                       string
	RequestBulkRetryCreateRequestQueryHeadersOne *RequestBulkRetryCreateRequestQueryHeadersOne
}

func NewRequestBulkRetryCreateRequestQueryHeadersFromString(value string) *RequestBulkRetryCreateRequestQueryHeaders {
	return &RequestBulkRetryCreateRequestQueryHeaders{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryHeadersFromRequestBulkRetryCreateRequestQueryHeadersOne(value *RequestBulkRetryCreateRequestQueryHeadersOne) *RequestBulkRetryCreateRequestQueryHeaders {
	return &RequestBulkRetryCreateRequestQueryHeaders{typeName: "requestBulkRetryCreateRequestQueryHeadersOne", RequestBulkRetryCreateRequestQueryHeadersOne: value}
}

func (r *RequestBulkRetryCreateRequestQueryHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryHeadersOne := new(RequestBulkRetryCreateRequestQueryHeadersOne)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryHeadersOne); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryHeadersOne"
		r.RequestBulkRetryCreateRequestQueryHeadersOne = valueRequestBulkRetryCreateRequestQueryHeadersOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryHeaders) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "requestBulkRetryCreateRequestQueryHeadersOne":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryHeadersOne)
	}
}

type RequestBulkRetryCreateRequestQueryHeadersVisitor interface {
	VisitString(string) error
	VisitRequestBulkRetryCreateRequestQueryHeadersOne(*RequestBulkRetryCreateRequestQueryHeadersOne) error
}

func (r *RequestBulkRetryCreateRequestQueryHeaders) Accept(visitor RequestBulkRetryCreateRequestQueryHeadersVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "requestBulkRetryCreateRequestQueryHeadersOne":
		return visitor.VisitRequestBulkRetryCreateRequestQueryHeadersOne(r.RequestBulkRetryCreateRequestQueryHeadersOne)
	}
}

type RequestBulkRetryCreateRequestQueryHeadersOne struct {
}

// Filter by requests IDs
type RequestBulkRetryCreateRequestQueryId struct {
	typeName string
	// Request ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewRequestBulkRetryCreateRequestQueryIdFromString(value string) *RequestBulkRetryCreateRequestQueryId {
	return &RequestBulkRetryCreateRequestQueryId{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryIdFromStringList(value []string) *RequestBulkRetryCreateRequestQueryId {
	return &RequestBulkRetryCreateRequestQueryId{typeName: "stringList", StringList: value}
}

func (r *RequestBulkRetryCreateRequestQueryId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		r.typeName = "stringList"
		r.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryId) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "stringList":
		return json.Marshal(r.StringList)
	}
}

type RequestBulkRetryCreateRequestQueryIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (r *RequestBulkRetryCreateRequestQueryId) Accept(visitor RequestBulkRetryCreateRequestQueryIdVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "stringList":
		return visitor.VisitStringList(r.StringList)
	}
}

// Filter by count of ignored events
type RequestBulkRetryCreateRequestQueryIgnoredCount struct {
	typeName                                          string
	Integer                                           int
	RequestBulkRetryCreateRequestQueryIgnoredCountAny *RequestBulkRetryCreateRequestQueryIgnoredCountAny
	IntegerList                                       []int
}

func NewRequestBulkRetryCreateRequestQueryIgnoredCountFromInteger(value int) *RequestBulkRetryCreateRequestQueryIgnoredCount {
	return &RequestBulkRetryCreateRequestQueryIgnoredCount{typeName: "integer", Integer: value}
}

func NewRequestBulkRetryCreateRequestQueryIgnoredCountFromRequestBulkRetryCreateRequestQueryIgnoredCountAny(value *RequestBulkRetryCreateRequestQueryIgnoredCountAny) *RequestBulkRetryCreateRequestQueryIgnoredCount {
	return &RequestBulkRetryCreateRequestQueryIgnoredCount{typeName: "requestBulkRetryCreateRequestQueryIgnoredCountAny", RequestBulkRetryCreateRequestQueryIgnoredCountAny: value}
}

func NewRequestBulkRetryCreateRequestQueryIgnoredCountFromIntegerList(value []int) *RequestBulkRetryCreateRequestQueryIgnoredCount {
	return &RequestBulkRetryCreateRequestQueryIgnoredCount{typeName: "integerList", IntegerList: value}
}

func (r *RequestBulkRetryCreateRequestQueryIgnoredCount) UnmarshalJSON(data []byte) error {
	var valueInteger int
	if err := json.Unmarshal(data, &valueInteger); err == nil {
		r.typeName = "integer"
		r.Integer = valueInteger
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryIgnoredCountAny := new(RequestBulkRetryCreateRequestQueryIgnoredCountAny)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryIgnoredCountAny); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryIgnoredCountAny"
		r.RequestBulkRetryCreateRequestQueryIgnoredCountAny = valueRequestBulkRetryCreateRequestQueryIgnoredCountAny
		return nil
	}
	var valueIntegerList []int
	if err := json.Unmarshal(data, &valueIntegerList); err == nil {
		r.typeName = "integerList"
		r.IntegerList = valueIntegerList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryIgnoredCount) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return json.Marshal(r.Integer)
	case "requestBulkRetryCreateRequestQueryIgnoredCountAny":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryIgnoredCountAny)
	case "integerList":
		return json.Marshal(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryIgnoredCountVisitor interface {
	VisitInteger(int) error
	VisitRequestBulkRetryCreateRequestQueryIgnoredCountAny(*RequestBulkRetryCreateRequestQueryIgnoredCountAny) error
	VisitIntegerList([]int) error
}

func (r *RequestBulkRetryCreateRequestQueryIgnoredCount) Accept(visitor RequestBulkRetryCreateRequestQueryIgnoredCountVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "integer":
		return visitor.VisitInteger(r.Integer)
	case "requestBulkRetryCreateRequestQueryIgnoredCountAny":
		return visitor.VisitRequestBulkRetryCreateRequestQueryIgnoredCountAny(r.RequestBulkRetryCreateRequestQueryIgnoredCountAny)
	case "integerList":
		return visitor.VisitIntegerList(r.IntegerList)
	}
}

type RequestBulkRetryCreateRequestQueryIgnoredCountAny struct {
	Gt       *int  `json:"gt,omitempty"`
	Gte      *int  `json:"gte,omitempty"`
	Le       *int  `json:"le,omitempty"`
	Lte      *int  `json:"lte,omitempty"`
	Any      *bool `json:"any,omitempty"`
	Contains *int  `json:"contains,omitempty"`
}

// Filter by event ingested date
type RequestBulkRetryCreateRequestQueryIngestedAt struct {
	typeName                                        string
	DateTime                                        time.Time
	RequestBulkRetryCreateRequestQueryIngestedAtAny *RequestBulkRetryCreateRequestQueryIngestedAtAny
}

func NewRequestBulkRetryCreateRequestQueryIngestedAtFromDateTime(value time.Time) *RequestBulkRetryCreateRequestQueryIngestedAt {
	return &RequestBulkRetryCreateRequestQueryIngestedAt{typeName: "dateTime", DateTime: value}
}

func NewRequestBulkRetryCreateRequestQueryIngestedAtFromRequestBulkRetryCreateRequestQueryIngestedAtAny(value *RequestBulkRetryCreateRequestQueryIngestedAtAny) *RequestBulkRetryCreateRequestQueryIngestedAt {
	return &RequestBulkRetryCreateRequestQueryIngestedAt{typeName: "requestBulkRetryCreateRequestQueryIngestedAtAny", RequestBulkRetryCreateRequestQueryIngestedAtAny: value}
}

func (r *RequestBulkRetryCreateRequestQueryIngestedAt) UnmarshalJSON(data []byte) error {
	var valueDateTime time.Time
	if err := json.Unmarshal(data, &valueDateTime); err == nil {
		r.typeName = "dateTime"
		r.DateTime = valueDateTime
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryIngestedAtAny := new(RequestBulkRetryCreateRequestQueryIngestedAtAny)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryIngestedAtAny); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryIngestedAtAny"
		r.RequestBulkRetryCreateRequestQueryIngestedAtAny = valueRequestBulkRetryCreateRequestQueryIngestedAtAny
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryIngestedAt) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "dateTime":
		return json.Marshal(r.DateTime)
	case "requestBulkRetryCreateRequestQueryIngestedAtAny":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryIngestedAtAny)
	}
}

type RequestBulkRetryCreateRequestQueryIngestedAtVisitor interface {
	VisitDateTime(time.Time) error
	VisitRequestBulkRetryCreateRequestQueryIngestedAtAny(*RequestBulkRetryCreateRequestQueryIngestedAtAny) error
}

func (r *RequestBulkRetryCreateRequestQueryIngestedAt) Accept(visitor RequestBulkRetryCreateRequestQueryIngestedAtVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "dateTime":
		return visitor.VisitDateTime(r.DateTime)
	case "requestBulkRetryCreateRequestQueryIngestedAtAny":
		return visitor.VisitRequestBulkRetryCreateRequestQueryIngestedAtAny(r.RequestBulkRetryCreateRequestQueryIngestedAtAny)
	}
}

type RequestBulkRetryCreateRequestQueryIngestedAtAny struct {
	Gt  *time.Time `json:"gt,omitempty"`
	Gte *time.Time `json:"gte,omitempty"`
	Le  *time.Time `json:"le,omitempty"`
	Lte *time.Time `json:"lte,omitempty"`
	Any *bool      `json:"any,omitempty"`
}

// URL Encoded string of the JSON to match to the parsed query (JSON representation of the query)
type RequestBulkRetryCreateRequestQueryParsedQuery struct {
	typeName                                         string
	String                                           string
	RequestBulkRetryCreateRequestQueryParsedQueryOne *RequestBulkRetryCreateRequestQueryParsedQueryOne
}

func NewRequestBulkRetryCreateRequestQueryParsedQueryFromString(value string) *RequestBulkRetryCreateRequestQueryParsedQuery {
	return &RequestBulkRetryCreateRequestQueryParsedQuery{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQueryParsedQueryFromRequestBulkRetryCreateRequestQueryParsedQueryOne(value *RequestBulkRetryCreateRequestQueryParsedQueryOne) *RequestBulkRetryCreateRequestQueryParsedQuery {
	return &RequestBulkRetryCreateRequestQueryParsedQuery{typeName: "requestBulkRetryCreateRequestQueryParsedQueryOne", RequestBulkRetryCreateRequestQueryParsedQueryOne: value}
}

func (r *RequestBulkRetryCreateRequestQueryParsedQuery) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	valueRequestBulkRetryCreateRequestQueryParsedQueryOne := new(RequestBulkRetryCreateRequestQueryParsedQueryOne)
	if err := json.Unmarshal(data, &valueRequestBulkRetryCreateRequestQueryParsedQueryOne); err == nil {
		r.typeName = "requestBulkRetryCreateRequestQueryParsedQueryOne"
		r.RequestBulkRetryCreateRequestQueryParsedQueryOne = valueRequestBulkRetryCreateRequestQueryParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryParsedQuery) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "requestBulkRetryCreateRequestQueryParsedQueryOne":
		return json.Marshal(r.RequestBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type RequestBulkRetryCreateRequestQueryParsedQueryVisitor interface {
	VisitString(string) error
	VisitRequestBulkRetryCreateRequestQueryParsedQueryOne(*RequestBulkRetryCreateRequestQueryParsedQueryOne) error
}

func (r *RequestBulkRetryCreateRequestQueryParsedQuery) Accept(visitor RequestBulkRetryCreateRequestQueryParsedQueryVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "requestBulkRetryCreateRequestQueryParsedQueryOne":
		return visitor.VisitRequestBulkRetryCreateRequestQueryParsedQueryOne(r.RequestBulkRetryCreateRequestQueryParsedQueryOne)
	}
}

type RequestBulkRetryCreateRequestQueryParsedQueryOne struct {
}

// Filter by rejection cause
type RequestBulkRetryCreateRequestQueryRejectionCause struct {
	typeName                  string
	RequestRejectionCause     RequestRejectionCause
	RequestRejectionCauseList []RequestRejectionCause
}

func NewRequestBulkRetryCreateRequestQueryRejectionCauseFromRequestRejectionCause(value RequestRejectionCause) *RequestBulkRetryCreateRequestQueryRejectionCause {
	return &RequestBulkRetryCreateRequestQueryRejectionCause{typeName: "requestRejectionCause", RequestRejectionCause: value}
}

func NewRequestBulkRetryCreateRequestQueryRejectionCauseFromRequestRejectionCauseList(value []RequestRejectionCause) *RequestBulkRetryCreateRequestQueryRejectionCause {
	return &RequestBulkRetryCreateRequestQueryRejectionCause{typeName: "requestRejectionCauseList", RequestRejectionCauseList: value}
}

func (r *RequestBulkRetryCreateRequestQueryRejectionCause) UnmarshalJSON(data []byte) error {
	var valueRequestRejectionCause RequestRejectionCause
	if err := json.Unmarshal(data, &valueRequestRejectionCause); err == nil {
		r.typeName = "requestRejectionCause"
		r.RequestRejectionCause = valueRequestRejectionCause
		return nil
	}
	var valueRequestRejectionCauseList []RequestRejectionCause
	if err := json.Unmarshal(data, &valueRequestRejectionCauseList); err == nil {
		r.typeName = "requestRejectionCauseList"
		r.RequestRejectionCauseList = valueRequestRejectionCauseList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQueryRejectionCause) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "requestRejectionCause":
		return json.Marshal(r.RequestRejectionCause)
	case "requestRejectionCauseList":
		return json.Marshal(r.RequestRejectionCauseList)
	}
}

type RequestBulkRetryCreateRequestQueryRejectionCauseVisitor interface {
	VisitRequestRejectionCause(RequestRejectionCause) error
	VisitRequestRejectionCauseList([]RequestRejectionCause) error
}

func (r *RequestBulkRetryCreateRequestQueryRejectionCause) Accept(visitor RequestBulkRetryCreateRequestQueryRejectionCauseVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "requestRejectionCause":
		return visitor.VisitRequestRejectionCause(r.RequestRejectionCause)
	case "requestRejectionCauseList":
		return visitor.VisitRequestRejectionCauseList(r.RequestRejectionCauseList)
	}
}

// Filter by source IDs
type RequestBulkRetryCreateRequestQuerySourceId struct {
	typeName string
	// Source ID <span style="white-space: nowrap">`<= 255 characters`</span>
	String     string
	StringList []string
}

func NewRequestBulkRetryCreateRequestQuerySourceIdFromString(value string) *RequestBulkRetryCreateRequestQuerySourceId {
	return &RequestBulkRetryCreateRequestQuerySourceId{typeName: "string", String: value}
}

func NewRequestBulkRetryCreateRequestQuerySourceIdFromStringList(value []string) *RequestBulkRetryCreateRequestQuerySourceId {
	return &RequestBulkRetryCreateRequestQuerySourceId{typeName: "stringList", StringList: value}
}

func (r *RequestBulkRetryCreateRequestQuerySourceId) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		r.typeName = "string"
		r.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		r.typeName = "stringList"
		r.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r RequestBulkRetryCreateRequestQuerySourceId) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return json.Marshal(r.String)
	case "stringList":
		return json.Marshal(r.StringList)
	}
}

type RequestBulkRetryCreateRequestQuerySourceIdVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (r *RequestBulkRetryCreateRequestQuerySourceId) Accept(visitor RequestBulkRetryCreateRequestQuerySourceIdVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "string":
		return visitor.VisitString(r.String)
	case "stringList":
		return visitor.VisitStringList(r.StringList)
	}
}

// Filter by status
type RequestBulkRetryCreateRequestQueryStatus string

const (
	RequestBulkRetryCreateRequestQueryStatusAccepted RequestBulkRetryCreateRequestQueryStatus = "accepted"
	RequestBulkRetryCreateRequestQueryStatusRejected RequestBulkRetryCreateRequestQueryStatus = "rejected"
)

func NewRequestBulkRetryCreateRequestQueryStatusFromString(s string) (RequestBulkRetryCreateRequestQueryStatus, error) {
	switch s {
	case "accepted":
		return RequestBulkRetryCreateRequestQueryStatusAccepted, nil
	case "rejected":
		return RequestBulkRetryCreateRequestQueryStatusRejected, nil
	}
	var t RequestBulkRetryCreateRequestQueryStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestBulkRetryCreateRequestQueryStatus) Ptr() *RequestBulkRetryCreateRequestQueryStatus {
	return &r
}

type RequestBulkRetryListRequestDir string

const (
	RequestBulkRetryListRequestDirAsc  RequestBulkRetryListRequestDir = "asc"
	RequestBulkRetryListRequestDirDesc RequestBulkRetryListRequestDir = "desc"
)

func NewRequestBulkRetryListRequestDirFromString(s string) (RequestBulkRetryListRequestDir, error) {
	switch s {
	case "asc":
		return RequestBulkRetryListRequestDirAsc, nil
	case "desc":
		return RequestBulkRetryListRequestDirDesc, nil
	}
	var t RequestBulkRetryListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestBulkRetryListRequestDir) Ptr() *RequestBulkRetryListRequestDir {
	return &r
}

type RequestBulkRetryPlanResponse struct {
	// Number of batches required to complete the bulk retry
	EstimatedBatch *int `json:"estimated_batch,omitempty"`
	// Number of estimated events to be retried
	EstimatedCount *int `json:"estimated_count,omitempty"`
	// Progression of the batch operations, values 0 - 1
	Progress *float64 `json:"progress,omitempty"`
}

// The priority attributed to the request when received
type RequestIngestPriority string

const (
	RequestIngestPriorityNormal RequestIngestPriority = "NORMAL"
	RequestIngestPriorityLow    RequestIngestPriority = "LOW"
)

func NewRequestIngestPriorityFromString(s string) (RequestIngestPriority, error) {
	switch s {
	case "NORMAL":
		return RequestIngestPriorityNormal, nil
	case "LOW":
		return RequestIngestPriorityLow, nil
	}
	var t RequestIngestPriority
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestIngestPriority) Ptr() *RequestIngestPriority {
	return &r
}

// Sort direction
type RequestListEventRequestDir string

const (
	RequestListEventRequestDirAsc  RequestListEventRequestDir = "asc"
	RequestListEventRequestDirDesc RequestListEventRequestDir = "desc"
)

func NewRequestListEventRequestDirFromString(s string) (RequestListEventRequestDir, error) {
	switch s {
	case "asc":
		return RequestListEventRequestDirAsc, nil
	case "desc":
		return RequestListEventRequestDirDesc, nil
	}
	var t RequestListEventRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestListEventRequestDir) Ptr() *RequestListEventRequestDir {
	return &r
}

// Sort key
type RequestListEventRequestOrderBy string

const (
	RequestListEventRequestOrderByLastAttemptAt RequestListEventRequestOrderBy = "last_attempt_at"
	RequestListEventRequestOrderByCreatedAt     RequestListEventRequestOrderBy = "created_at"
)

func NewRequestListEventRequestOrderByFromString(s string) (RequestListEventRequestOrderBy, error) {
	switch s {
	case "last_attempt_at":
		return RequestListEventRequestOrderByLastAttemptAt, nil
	case "created_at":
		return RequestListEventRequestOrderByCreatedAt, nil
	}
	var t RequestListEventRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestListEventRequestOrderBy) Ptr() *RequestListEventRequestOrderBy {
	return &r
}

type RequestListIgnoredEventRequestDir string

const (
	RequestListIgnoredEventRequestDirAsc  RequestListIgnoredEventRequestDir = "asc"
	RequestListIgnoredEventRequestDirDesc RequestListIgnoredEventRequestDir = "desc"
)

func NewRequestListIgnoredEventRequestDirFromString(s string) (RequestListIgnoredEventRequestDir, error) {
	switch s {
	case "asc":
		return RequestListIgnoredEventRequestDirAsc, nil
	case "desc":
		return RequestListIgnoredEventRequestDirDesc, nil
	}
	var t RequestListIgnoredEventRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestListIgnoredEventRequestDir) Ptr() *RequestListIgnoredEventRequestDir {
	return &r
}

// Sort direction
type RequestListRequestDir string

const (
	RequestListRequestDirAsc  RequestListRequestDir = "asc"
	RequestListRequestDirDesc RequestListRequestDir = "desc"
)

func NewRequestListRequestDirFromString(s string) (RequestListRequestDir, error) {
	switch s {
	case "asc":
		return RequestListRequestDirAsc, nil
	case "desc":
		return RequestListRequestDirDesc, nil
	}
	var t RequestListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestListRequestDir) Ptr() *RequestListRequestDir {
	return &r
}

// Sort key
type RequestListRequestOrderBy string

const (
	RequestListRequestOrderByIngestedAt RequestListRequestOrderBy = "ingested_at"
	RequestListRequestOrderByCreatedAt  RequestListRequestOrderBy = "created_at"
)

func NewRequestListRequestOrderByFromString(s string) (RequestListRequestOrderBy, error) {
	switch s {
	case "ingested_at":
		return RequestListRequestOrderByIngestedAt, nil
	case "created_at":
		return RequestListRequestOrderByCreatedAt, nil
	}
	var t RequestListRequestOrderBy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestListRequestOrderBy) Ptr() *RequestListRequestOrderBy {
	return &r
}

// Filter by status
type RequestListRequestStatus string

const (
	RequestListRequestStatusAccepted RequestListRequestStatus = "accepted"
	RequestListRequestStatusRejected RequestListRequestStatus = "rejected"
)

func NewRequestListRequestStatusFromString(s string) (RequestListRequestStatus, error) {
	switch s {
	case "accepted":
		return RequestListRequestStatusAccepted, nil
	case "rejected":
		return RequestListRequestStatusRejected, nil
	}
	var t RequestListRequestStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestListRequestStatus) Ptr() *RequestListRequestStatus {
	return &r
}

type RequestPaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Request      `json:"models,omitempty"`
}

type RequestRejectionCause string

const (
	RequestRejectionCauseSourceArchived         RequestRejectionCause = "SOURCE_ARCHIVED"
	RequestRejectionCauseNoWebhook              RequestRejectionCause = "NO_WEBHOOK"
	RequestRejectionCauseVerificationFailed     RequestRejectionCause = "VERIFICATION_FAILED"
	RequestRejectionCauseUnsupportedHttpMethod  RequestRejectionCause = "UNSUPPORTED_HTTP_METHOD"
	RequestRejectionCauseUnsupportedContentType RequestRejectionCause = "UNSUPPORTED_CONTENT_TYPE"
	RequestRejectionCauseUnparsableJson         RequestRejectionCause = "UNPARSABLE_JSON"
	RequestRejectionCausePayloadTooLarge        RequestRejectionCause = "PAYLOAD_TOO_LARGE"
	RequestRejectionCauseIngestionFatal         RequestRejectionCause = "INGESTION_FATAL"
	RequestRejectionCauseUnknown                RequestRejectionCause = "UNKNOWN"
)

func NewRequestRejectionCauseFromString(s string) (RequestRejectionCause, error) {
	switch s {
	case "SOURCE_ARCHIVED":
		return RequestRejectionCauseSourceArchived, nil
	case "NO_WEBHOOK":
		return RequestRejectionCauseNoWebhook, nil
	case "VERIFICATION_FAILED":
		return RequestRejectionCauseVerificationFailed, nil
	case "UNSUPPORTED_HTTP_METHOD":
		return RequestRejectionCauseUnsupportedHttpMethod, nil
	case "UNSUPPORTED_CONTENT_TYPE":
		return RequestRejectionCauseUnsupportedContentType, nil
	case "UNPARSABLE_JSON":
		return RequestRejectionCauseUnparsableJson, nil
	case "PAYLOAD_TOO_LARGE":
		return RequestRejectionCausePayloadTooLarge, nil
	case "INGESTION_FATAL":
		return RequestRejectionCauseIngestionFatal, nil
	case "UNKNOWN":
		return RequestRejectionCauseUnknown, nil
	}
	var t RequestRejectionCause
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RequestRejectionCause) Ptr() *RequestRejectionCause {
	return &r
}

type RetriedEvent struct {
	Event   *Event        `json:"event,omitempty"`
	Attempt *EventAttempt `json:"attempt,omitempty"`
}

type RetryRequest struct {
	Request *Request `json:"request,omitempty"`
	Events  []*Event `json:"events,omitempty"`
}

type RetryRule struct {
	Strategy RetryStrategy `json:"strategy,omitempty"`
	// Time in MS between each retry
	Interval *int `json:"interval,omitempty"`
	// Maximum number of retries to attempt
	Count *int `json:"count,omitempty"`
	type_ string
}

func (r *RetryRule) Type() string {
	return r.type_
}

func (r *RetryRule) UnmarshalJSON(data []byte) error {
	type unmarshaler RetryRule
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*r = RetryRule(value)
	r.type_ = "retry"
	return nil
}

func (r *RetryRule) MarshalJSON() ([]byte, error) {
	type embed RetryRule
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*r),
		Type:  "retry",
	}
	return json.Marshal(marshaler)
}

// Algorithm to use when calculating delay between retries
type RetryStrategy string

const (
	RetryStrategyLinear      RetryStrategy = "linear"
	RetryStrategyExponential RetryStrategy = "exponential"
)

func NewRetryStrategyFromString(s string) (RetryStrategy, error) {
	switch s {
	case "linear":
		return RetryStrategyLinear, nil
	case "exponential":
		return RetryStrategyExponential, nil
	}
	var t RetryStrategy
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (r RetryStrategy) Ptr() *RetryStrategy {
	return &r
}

type Rule struct {
	typeName      string
	RetryRule     *RetryRule
	FilterRule    *FilterRule
	TransformRule *TransformRule
	DelayRule     *DelayRule
}

func NewRuleFromRetryRule(value *RetryRule) *Rule {
	return &Rule{typeName: "retryRule", RetryRule: value}
}

func NewRuleFromFilterRule(value *FilterRule) *Rule {
	return &Rule{typeName: "filterRule", FilterRule: value}
}

func NewRuleFromTransformRule(value *TransformRule) *Rule {
	return &Rule{typeName: "transformRule", TransformRule: value}
}

func NewRuleFromDelayRule(value *DelayRule) *Rule {
	return &Rule{typeName: "delayRule", DelayRule: value}
}

func (r *Rule) UnmarshalJSON(data []byte) error {
	valueRetryRule := new(RetryRule)
	if err := json.Unmarshal(data, &valueRetryRule); err == nil {
		r.typeName = "retryRule"
		r.RetryRule = valueRetryRule
		return nil
	}
	valueFilterRule := new(FilterRule)
	if err := json.Unmarshal(data, &valueFilterRule); err == nil {
		r.typeName = "filterRule"
		r.FilterRule = valueFilterRule
		return nil
	}
	valueTransformRule := new(TransformRule)
	if err := json.Unmarshal(data, &valueTransformRule); err == nil {
		r.typeName = "transformRule"
		r.TransformRule = valueTransformRule
		return nil
	}
	valueDelayRule := new(DelayRule)
	if err := json.Unmarshal(data, &valueDelayRule); err == nil {
		r.typeName = "delayRule"
		r.DelayRule = valueDelayRule
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, r)
}

func (r Rule) MarshalJSON() ([]byte, error) {
	switch r.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "retryRule":
		return json.Marshal(r.RetryRule)
	case "filterRule":
		return json.Marshal(r.FilterRule)
	case "transformRule":
		return json.Marshal(r.TransformRule)
	case "delayRule":
		return json.Marshal(r.DelayRule)
	}
}

type RuleVisitor interface {
	VisitRetryRule(*RetryRule) error
	VisitFilterRule(*FilterRule) error
	VisitTransformRule(*TransformRule) error
	VisitDelayRule(*DelayRule) error
}

func (r *Rule) Accept(visitor RuleVisitor) error {
	switch r.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", r.typeName, r)
	case "retryRule":
		return visitor.VisitRetryRule(r.RetryRule)
	case "filterRule":
		return visitor.VisitFilterRule(r.FilterRule)
	case "transformRule":
		return visitor.VisitTransformRule(r.TransformRule)
	case "delayRule":
		return visitor.VisitDelayRule(r.DelayRule)
	}
}

type SeekPagination struct {
	OrderBy *SeekPaginationOrderBy `json:"order_by,omitempty"`
	Dir     *SeekPaginationDir     `json:"dir,omitempty"`
	Limit   *int                   `json:"limit,omitempty"`
	Prev    *string                `json:"prev,omitempty"`
	Next    *string                `json:"next,omitempty"`
}

type SeekPaginationDir struct {
	typeName             string
	OrderByDirection     OrderByDirection
	OrderByDirectionList []OrderByDirection
}

func NewSeekPaginationDirFromOrderByDirection(value OrderByDirection) *SeekPaginationDir {
	return &SeekPaginationDir{typeName: "orderByDirection", OrderByDirection: value}
}

func NewSeekPaginationDirFromOrderByDirectionList(value []OrderByDirection) *SeekPaginationDir {
	return &SeekPaginationDir{typeName: "orderByDirectionList", OrderByDirectionList: value}
}

func (s *SeekPaginationDir) UnmarshalJSON(data []byte) error {
	var valueOrderByDirection OrderByDirection
	if err := json.Unmarshal(data, &valueOrderByDirection); err == nil {
		s.typeName = "orderByDirection"
		s.OrderByDirection = valueOrderByDirection
		return nil
	}
	var valueOrderByDirectionList []OrderByDirection
	if err := json.Unmarshal(data, &valueOrderByDirectionList); err == nil {
		s.typeName = "orderByDirectionList"
		s.OrderByDirectionList = valueOrderByDirectionList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SeekPaginationDir) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "orderByDirection":
		return json.Marshal(s.OrderByDirection)
	case "orderByDirectionList":
		return json.Marshal(s.OrderByDirectionList)
	}
}

type SeekPaginationDirVisitor interface {
	VisitOrderByDirection(OrderByDirection) error
	VisitOrderByDirectionList([]OrderByDirection) error
}

func (s *SeekPaginationDir) Accept(visitor SeekPaginationDirVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "orderByDirection":
		return visitor.VisitOrderByDirection(s.OrderByDirection)
	case "orderByDirectionList":
		return visitor.VisitOrderByDirectionList(s.OrderByDirectionList)
	}
}

type SeekPaginationOrderBy struct {
	typeName   string
	String     string
	StringList []string
}

func NewSeekPaginationOrderByFromString(value string) *SeekPaginationOrderBy {
	return &SeekPaginationOrderBy{typeName: "string", String: value}
}

func NewSeekPaginationOrderByFromStringList(value []string) *SeekPaginationOrderBy {
	return &SeekPaginationOrderBy{typeName: "stringList", StringList: value}
}

func (s *SeekPaginationOrderBy) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	var valueStringList []string
	if err := json.Unmarshal(data, &valueStringList); err == nil {
		s.typeName = "stringList"
		s.StringList = valueStringList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s SeekPaginationOrderBy) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "stringList":
		return json.Marshal(s.StringList)
	}
}

type SeekPaginationOrderByVisitor interface {
	VisitString(string) error
	VisitStringList([]string) error
}

func (s *SeekPaginationOrderBy) Accept(visitor SeekPaginationOrderByVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "stringList":
		return visitor.VisitStringList(s.StringList)
	}
}

type ShopifyIntegrationConfigs struct {
	WebhookSecretKey string                                    `json:"webhook_secret_key"`
	RateLimitPeriod  *ShopifyIntegrationConfigsRateLimitPeriod `json:"rate_limit_period,omitempty"`
	RateLimit        *float64                                  `json:"rate_limit,omitempty"`
	ApiKey           *string                                   `json:"api_key,omitempty"`
	ApiSecret        *string                                   `json:"api_secret,omitempty"`
	Shop             *string                                   `json:"shop,omitempty"`
}

type ShopifyIntegrationConfigsRateLimitPeriod string

const (
	ShopifyIntegrationConfigsRateLimitPeriodMinute ShopifyIntegrationConfigsRateLimitPeriod = "minute"
	ShopifyIntegrationConfigsRateLimitPeriodSecond ShopifyIntegrationConfigsRateLimitPeriod = "second"
)

func NewShopifyIntegrationConfigsRateLimitPeriodFromString(s string) (ShopifyIntegrationConfigsRateLimitPeriod, error) {
	switch s {
	case "minute":
		return ShopifyIntegrationConfigsRateLimitPeriodMinute, nil
	case "second":
		return ShopifyIntegrationConfigsRateLimitPeriodSecond, nil
	}
	var t ShopifyIntegrationConfigsRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s ShopifyIntegrationConfigsRateLimitPeriod) Ptr() *ShopifyIntegrationConfigsRateLimitPeriod {
	return &s
}

// Request data
type ShortEventData struct {
	// Request path
	Path string `json:"path"`
	// Raw query param string
	Query *string `json:"query,omitempty"`
	// JSON representation of query params
	ParsedQuery *ShortEventDataParsedQuery `json:"parsed_query,omitempty"`
	// JSON representation of the headers
	Headers *ShortEventDataHeaders `json:"headers,omitempty"`
	// JSON or string representation of the body
	Body *ShortEventDataBody `json:"body,omitempty"`
	// Whether the payload is considered large payload and not searchable
	IsLargePayload *bool `json:"is_large_payload,omitempty"`
}

// JSON or string representation of the body
type ShortEventDataBody struct {
	typeName              string
	String                string
	ShortEventDataBodyOne *ShortEventDataBodyOne
	UnknownList           []interface{}
}

func NewShortEventDataBodyFromString(value string) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "string", String: value}
}

func NewShortEventDataBodyFromShortEventDataBodyOne(value *ShortEventDataBodyOne) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "shortEventDataBodyOne", ShortEventDataBodyOne: value}
}

func NewShortEventDataBodyFromUnknownList(value []interface{}) *ShortEventDataBody {
	return &ShortEventDataBody{typeName: "unknownList", UnknownList: value}
}

func (s *ShortEventDataBody) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	valueShortEventDataBodyOne := new(ShortEventDataBodyOne)
	if err := json.Unmarshal(data, &valueShortEventDataBodyOne); err == nil {
		s.typeName = "shortEventDataBodyOne"
		s.ShortEventDataBodyOne = valueShortEventDataBodyOne
		return nil
	}
	var valueUnknownList []interface{}
	if err := json.Unmarshal(data, &valueUnknownList); err == nil {
		s.typeName = "unknownList"
		s.UnknownList = valueUnknownList
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataBody) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "shortEventDataBodyOne":
		return json.Marshal(s.ShortEventDataBodyOne)
	case "unknownList":
		return json.Marshal(s.UnknownList)
	}
}

type ShortEventDataBodyVisitor interface {
	VisitString(string) error
	VisitShortEventDataBodyOne(*ShortEventDataBodyOne) error
	VisitUnknownList([]interface{}) error
}

func (s *ShortEventDataBody) Accept(visitor ShortEventDataBodyVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "shortEventDataBodyOne":
		return visitor.VisitShortEventDataBodyOne(s.ShortEventDataBodyOne)
	case "unknownList":
		return visitor.VisitUnknownList(s.UnknownList)
	}
}

type ShortEventDataBodyOne struct {
}

// JSON representation of the headers
type ShortEventDataHeaders struct {
	typeName                string
	String                  string
	StringStringOptionalMap map[string]*string
}

func NewShortEventDataHeadersFromString(value string) *ShortEventDataHeaders {
	return &ShortEventDataHeaders{typeName: "string", String: value}
}

func NewShortEventDataHeadersFromStringStringOptionalMap(value map[string]*string) *ShortEventDataHeaders {
	return &ShortEventDataHeaders{typeName: "stringStringOptionalMap", StringStringOptionalMap: value}
}

func (s *ShortEventDataHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		s.typeName = "string"
		s.String = valueString
		return nil
	}
	var valueStringStringOptionalMap map[string]*string
	if err := json.Unmarshal(data, &valueStringStringOptionalMap); err == nil {
		s.typeName = "stringStringOptionalMap"
		s.StringStringOptionalMap = valueStringStringOptionalMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataHeaders) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return json.Marshal(s.String)
	case "stringStringOptionalMap":
		return json.Marshal(s.StringStringOptionalMap)
	}
}

type ShortEventDataHeadersVisitor interface {
	VisitString(string) error
	VisitStringStringOptionalMap(map[string]*string) error
}

func (s *ShortEventDataHeaders) Accept(visitor ShortEventDataHeadersVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "string":
		return visitor.VisitString(s.String)
	case "stringStringOptionalMap":
		return visitor.VisitStringStringOptionalMap(s.StringStringOptionalMap)
	}
}

// JSON representation of query params
type ShortEventDataParsedQuery struct {
	typeName                     string
	StringOptional               *string
	ShortEventDataParsedQueryOne *ShortEventDataParsedQueryOne
}

func NewShortEventDataParsedQueryFromStringOptional(value *string) *ShortEventDataParsedQuery {
	return &ShortEventDataParsedQuery{typeName: "stringOptional", StringOptional: value}
}

func NewShortEventDataParsedQueryFromShortEventDataParsedQueryOne(value *ShortEventDataParsedQueryOne) *ShortEventDataParsedQuery {
	return &ShortEventDataParsedQuery{typeName: "shortEventDataParsedQueryOne", ShortEventDataParsedQueryOne: value}
}

func (s *ShortEventDataParsedQuery) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		s.typeName = "stringOptional"
		s.StringOptional = valueStringOptional
		return nil
	}
	valueShortEventDataParsedQueryOne := new(ShortEventDataParsedQueryOne)
	if err := json.Unmarshal(data, &valueShortEventDataParsedQueryOne); err == nil {
		s.typeName = "shortEventDataParsedQueryOne"
		s.ShortEventDataParsedQueryOne = valueShortEventDataParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, s)
}

func (s ShortEventDataParsedQuery) MarshalJSON() ([]byte, error) {
	switch s.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringOptional":
		return json.Marshal(s.StringOptional)
	case "shortEventDataParsedQueryOne":
		return json.Marshal(s.ShortEventDataParsedQueryOne)
	}
}

type ShortEventDataParsedQueryVisitor interface {
	VisitStringOptional(*string) error
	VisitShortEventDataParsedQueryOne(*ShortEventDataParsedQueryOne) error
}

func (s *ShortEventDataParsedQuery) Accept(visitor ShortEventDataParsedQueryVisitor) error {
	switch s.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", s.typeName, s)
	case "stringOptional":
		return visitor.VisitStringOptional(s.StringOptional)
	case "shortEventDataParsedQueryOne":
		return visitor.VisitShortEventDataParsedQueryOne(s.ShortEventDataParsedQueryOne)
	}
}

type ShortEventDataParsedQueryOne struct {
}

// Associated [Source](#source-object) object
type Source struct {
	// ID of the source
	Id string `json:"id"`
	// Name for the source
	Name string `json:"name"`
	// Description of the source
	Description *string `json:"description,omitempty"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// A unique URL that must be supplied to your webhook's provider
	Url                string                   `json:"url"`
	Verification       *VerificationConfig      `json:"verification,omitempty"`
	AllowedHttpMethods *SourceAllowedHttpMethod `json:"allowed_http_methods,omitempty"`
	CustomResponse     *SourceCustomResponse    `json:"custom_response,omitempty"`
	// Date the source was archived
	ArchivedAt *time.Time `json:"archived_at,omitempty"`
	// Date the source was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the source was created
	CreatedAt time.Time `json:"created_at"`
}

// List of allowed HTTP methods. Defaults to PUT, POST, PATCH, DELETE.
type SourceAllowedHttpMethod = []SourceAllowedHttpMethodItem

type SourceAllowedHttpMethodItem string

const (
	SourceAllowedHttpMethodItemGet    SourceAllowedHttpMethodItem = "GET"
	SourceAllowedHttpMethodItemPost   SourceAllowedHttpMethodItem = "POST"
	SourceAllowedHttpMethodItemPut    SourceAllowedHttpMethodItem = "PUT"
	SourceAllowedHttpMethodItemPatch  SourceAllowedHttpMethodItem = "PATCH"
	SourceAllowedHttpMethodItemDelete SourceAllowedHttpMethodItem = "DELETE"
)

func NewSourceAllowedHttpMethodItemFromString(s string) (SourceAllowedHttpMethodItem, error) {
	switch s {
	case "GET":
		return SourceAllowedHttpMethodItemGet, nil
	case "POST":
		return SourceAllowedHttpMethodItemPost, nil
	case "PUT":
		return SourceAllowedHttpMethodItemPut, nil
	case "PATCH":
		return SourceAllowedHttpMethodItemPatch, nil
	case "DELETE":
		return SourceAllowedHttpMethodItemDelete, nil
	}
	var t SourceAllowedHttpMethodItem
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceAllowedHttpMethodItem) Ptr() *SourceAllowedHttpMethodItem {
	return &s
}

// Custom response object
type SourceCustomResponse struct {
	ContentType SourceCustomResponseContentType `json:"content_type,omitempty"`
	// Body of the custom response <span style="white-space: nowrap">`<= 1000 characters`</span>
	Body string `json:"body"`
}

// Content type of the custom response
type SourceCustomResponseContentType string

const (
	SourceCustomResponseContentTypeJson SourceCustomResponseContentType = "json"
	SourceCustomResponseContentTypeText SourceCustomResponseContentType = "text"
	SourceCustomResponseContentTypeXml  SourceCustomResponseContentType = "xml"
)

func NewSourceCustomResponseContentTypeFromString(s string) (SourceCustomResponseContentType, error) {
	switch s {
	case "json":
		return SourceCustomResponseContentTypeJson, nil
	case "text":
		return SourceCustomResponseContentTypeText, nil
	case "xml":
		return SourceCustomResponseContentTypeXml, nil
	}
	var t SourceCustomResponseContentType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceCustomResponseContentType) Ptr() *SourceCustomResponseContentType {
	return &s
}

type SourceDeleteResponse struct {
	// ID of the source
	Id string `json:"id"`
}

type SourceListRequestDir string

const (
	SourceListRequestDirAsc  SourceListRequestDir = "asc"
	SourceListRequestDirDesc SourceListRequestDir = "desc"
)

func NewSourceListRequestDirFromString(s string) (SourceListRequestDir, error) {
	switch s {
	case "asc":
		return SourceListRequestDirAsc, nil
	case "desc":
		return SourceListRequestDirDesc, nil
	}
	var t SourceListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (s SourceListRequestDir) Ptr() *SourceListRequestDir {
	return &s
}

type SourcePaginatedResult struct {
	Pagination *SeekPagination `json:"pagination,omitempty"`
	Count      *int            `json:"count,omitempty"`
	Models     []*Source       `json:"models,omitempty"`
}

type ToggleWebhookNotifications struct {
	Enabled  bool          `json:"enabled"`
	Topics   []TopicsValue `json:"topics,omitempty"`
	SourceId string        `json:"source_id"`
}

// Supported topics
type TopicsValue string

const (
	TopicsValueIssueOpened             TopicsValue = "issue.opened"
	TopicsValueIssueUpdated            TopicsValue = "issue.updated"
	TopicsValueDeprecatedAttemptFailed TopicsValue = "deprecated.attempt-failed"
	TopicsValueEventSuccessful         TopicsValue = "event.successful"
)

func NewTopicsValueFromString(s string) (TopicsValue, error) {
	switch s {
	case "issue.opened":
		return TopicsValueIssueOpened, nil
	case "issue.updated":
		return TopicsValueIssueUpdated, nil
	case "deprecated.attempt-failed":
		return TopicsValueDeprecatedAttemptFailed, nil
	case "event.successful":
		return TopicsValueEventSuccessful, nil
	}
	var t TopicsValue
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TopicsValue) Ptr() *TopicsValue {
	return &t
}

type TransformFull struct {
	// ID of the attached transformation object. Optional input, always set once the rule is defined
	TransformationId *string `json:"transformation_id,omitempty"`
	// You can optionally define a new transformation while creating a transform rule
	Transformation *TransformFullTransformation `json:"transformation,omitempty"`
	type_          string
}

func (t *TransformFull) Type() string {
	return t.type_
}

func (t *TransformFull) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformFull
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformFull(value)
	t.type_ = "transform"
	return nil
}

func (t *TransformFull) MarshalJSON() ([]byte, error) {
	type embed TransformFull
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transform",
	}
	return json.Marshal(marshaler)
}

// You can optionally define a new transformation while creating a transform rule
type TransformFullTransformation struct {
	// The unique name of the transformation
	Name string `json:"name"`
	// A string representation of your JavaScript (ES6) code to run
	Code string `json:"code"`
	// A key-value object of environment variables to encrypt and expose to your transformation code
	Env map[string]*string `json:"env,omitempty"`
}

type TransformReference struct {
	// ID of the attached transformation object. Optional input, always set once the rule is defined
	TransformationId string `json:"transformation_id"`
	type_            string
}

func (t *TransformReference) Type() string {
	return t.type_
}

func (t *TransformReference) UnmarshalJSON(data []byte) error {
	type unmarshaler TransformReference
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*t = TransformReference(value)
	t.type_ = "transform"
	return nil
}

func (t *TransformReference) MarshalJSON() ([]byte, error) {
	type embed TransformReference
	var marshaler = struct {
		embed
		Type string `json:"type"`
	}{
		embed: embed(*t),
		Type:  "transform",
	}
	return json.Marshal(marshaler)
}

type TransformRule struct {
	typeName           string
	TransformReference *TransformReference
	TransformFull      *TransformFull
}

func NewTransformRuleFromTransformReference(value *TransformReference) *TransformRule {
	return &TransformRule{typeName: "transformReference", TransformReference: value}
}

func NewTransformRuleFromTransformFull(value *TransformFull) *TransformRule {
	return &TransformRule{typeName: "transformFull", TransformFull: value}
}

func (t *TransformRule) UnmarshalJSON(data []byte) error {
	valueTransformReference := new(TransformReference)
	if err := json.Unmarshal(data, &valueTransformReference); err == nil {
		t.typeName = "transformReference"
		t.TransformReference = valueTransformReference
		return nil
	}
	valueTransformFull := new(TransformFull)
	if err := json.Unmarshal(data, &valueTransformFull); err == nil {
		t.typeName = "transformFull"
		t.TransformFull = valueTransformFull
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformRule) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformReference":
		return json.Marshal(t.TransformReference)
	case "transformFull":
		return json.Marshal(t.TransformFull)
	}
}

type TransformRuleVisitor interface {
	VisitTransformReference(*TransformReference) error
	VisitTransformFull(*TransformFull) error
}

func (t *TransformRule) Accept(visitor TransformRuleVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformReference":
		return visitor.VisitTransformReference(t.TransformReference)
	case "transformFull":
		return visitor.VisitTransformFull(t.TransformFull)
	}
}

type Transformation struct {
	// ID of the transformation
	Id string `json:"id"`
	// ID of the workspace
	TeamId string `json:"team_id"`
	// A unique, human-friendly name for the transformation
	Name string `json:"name"`
	// JavaScript code to be executed
	Code         string  `json:"code"`
	EncryptedEnv *string `json:"encrypted_env,omitempty"`
	Iv           *string `json:"iv,omitempty"`
	// Key-value environment variables to be passed to the transformation
	Env map[string]*string `json:"env,omitempty"`
	// Date the transformation was last updated
	UpdatedAt time.Time `json:"updated_at"`
	// Date the transformation was created
	CreatedAt time.Time `json:"created_at"`
}

type TransformationExecution struct {
	Id                     string                          `json:"id"`
	TransformedEventDataId string                          `json:"transformed_event_data_id"`
	OriginalEventDataId    string                          `json:"original_event_data_id"`
	TransformationId       string                          `json:"transformation_id"`
	TeamId                 string                          `json:"team_id"`
	WebhookId              string                          `json:"webhook_id"`
	LogLevel               TransformationExecutionLogLevel `json:"log_level,omitempty"`
	Logs                   []*ConsoleLine                  `json:"logs,omitempty"`
	UpdatedAt              time.Time                       `json:"updated_at"`
	CreatedAt              time.Time                       `json:"created_at"`
	OriginalEventData      *ShortEventData                 `json:"original_event_data,omitempty"`
	TransformedEventData   *ShortEventData                 `json:"transformed_event_data,omitempty"`
	IssueId                *string                         `json:"issue_id,omitempty"`
}

// The minimum log level to open the issue on
type TransformationExecutionLogLevel string

const (
	TransformationExecutionLogLevelDebug TransformationExecutionLogLevel = "debug"
	TransformationExecutionLogLevelInfo  TransformationExecutionLogLevel = "info"
	TransformationExecutionLogLevelWarn  TransformationExecutionLogLevel = "warn"
	TransformationExecutionLogLevelError TransformationExecutionLogLevel = "error"
	TransformationExecutionLogLevelFatal TransformationExecutionLogLevel = "fatal"
)

func NewTransformationExecutionLogLevelFromString(s string) (TransformationExecutionLogLevel, error) {
	switch s {
	case "debug":
		return TransformationExecutionLogLevelDebug, nil
	case "info":
		return TransformationExecutionLogLevelInfo, nil
	case "warn":
		return TransformationExecutionLogLevelWarn, nil
	case "error":
		return TransformationExecutionLogLevelError, nil
	case "fatal":
		return TransformationExecutionLogLevelFatal, nil
	}
	var t TransformationExecutionLogLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransformationExecutionLogLevel) Ptr() *TransformationExecutionLogLevel {
	return &t
}

type TransformationExecutionPaginatedResult struct {
	Pagination *SeekPagination            `json:"pagination,omitempty"`
	Count      *int                       `json:"count,omitempty"`
	Models     []*TransformationExecution `json:"models,omitempty"`
}

type TransformationExecutorOutput struct {
	RequestId        *string                              `json:"request_id,omitempty"`
	TransformationId *string                              `json:"transformation_id,omitempty"`
	ExecutionId      *string                              `json:"execution_id,omitempty"`
	LogLevel         TransformationExecutionLogLevel      `json:"log_level,omitempty"`
	Request          *TransformationExecutorOutputRequest `json:"request,omitempty"`
	Console          []*ConsoleLine                       `json:"console,omitempty"`
}

type TransformationExecutorOutputRequest struct {
	Headers     *TransformationExecutorOutputRequestHeaders     `json:"headers,omitempty"`
	Path        string                                          `json:"path"`
	Query       *TransformationExecutorOutputRequestQuery       `json:"query,omitempty"`
	ParsedQuery *TransformationExecutorOutputRequestParsedQuery `json:"parsed_query,omitempty"`
	Body        *TransformationExecutorOutputRequestBody        `json:"body,omitempty"`
}

type TransformationExecutorOutputRequestBody struct {
	typeName                                   string
	StringOptional                             *string
	TransformationExecutorOutputRequestBodyOne *TransformationExecutorOutputRequestBodyOne
}

func NewTransformationExecutorOutputRequestBodyFromStringOptional(value *string) *TransformationExecutorOutputRequestBody {
	return &TransformationExecutorOutputRequestBody{typeName: "stringOptional", StringOptional: value}
}

func NewTransformationExecutorOutputRequestBodyFromTransformationExecutorOutputRequestBodyOne(value *TransformationExecutorOutputRequestBodyOne) *TransformationExecutorOutputRequestBody {
	return &TransformationExecutorOutputRequestBody{typeName: "transformationExecutorOutputRequestBodyOne", TransformationExecutorOutputRequestBodyOne: value}
}

func (t *TransformationExecutorOutputRequestBody) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		t.typeName = "stringOptional"
		t.StringOptional = valueStringOptional
		return nil
	}
	valueTransformationExecutorOutputRequestBodyOne := new(TransformationExecutorOutputRequestBodyOne)
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestBodyOne); err == nil {
		t.typeName = "transformationExecutorOutputRequestBodyOne"
		t.TransformationExecutorOutputRequestBodyOne = valueTransformationExecutorOutputRequestBodyOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestBody) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return json.Marshal(t.StringOptional)
	case "transformationExecutorOutputRequestBodyOne":
		return json.Marshal(t.TransformationExecutorOutputRequestBodyOne)
	}
}

type TransformationExecutorOutputRequestBodyVisitor interface {
	VisitStringOptional(*string) error
	VisitTransformationExecutorOutputRequestBodyOne(*TransformationExecutorOutputRequestBodyOne) error
}

func (t *TransformationExecutorOutputRequestBody) Accept(visitor TransformationExecutorOutputRequestBodyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return visitor.VisitStringOptional(t.StringOptional)
	case "transformationExecutorOutputRequestBodyOne":
		return visitor.VisitTransformationExecutorOutputRequestBodyOne(t.TransformationExecutorOutputRequestBodyOne)
	}
}

type TransformationExecutorOutputRequestBodyOne struct {
}

type TransformationExecutorOutputRequestHeaders struct {
	typeName         string
	String           string
	StringUnknownMap map[string]interface{}
}

func NewTransformationExecutorOutputRequestHeadersFromString(value string) *TransformationExecutorOutputRequestHeaders {
	return &TransformationExecutorOutputRequestHeaders{typeName: "string", String: value}
}

func NewTransformationExecutorOutputRequestHeadersFromStringUnknownMap(value map[string]interface{}) *TransformationExecutorOutputRequestHeaders {
	return &TransformationExecutorOutputRequestHeaders{typeName: "stringUnknownMap", StringUnknownMap: value}
}

func (t *TransformationExecutorOutputRequestHeaders) UnmarshalJSON(data []byte) error {
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	var valueStringUnknownMap map[string]interface{}
	if err := json.Unmarshal(data, &valueStringUnknownMap); err == nil {
		t.typeName = "stringUnknownMap"
		t.StringUnknownMap = valueStringUnknownMap
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestHeaders) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return json.Marshal(t.String)
	case "stringUnknownMap":
		return json.Marshal(t.StringUnknownMap)
	}
}

type TransformationExecutorOutputRequestHeadersVisitor interface {
	VisitString(string) error
	VisitStringUnknownMap(map[string]interface{}) error
}

func (t *TransformationExecutorOutputRequestHeaders) Accept(visitor TransformationExecutorOutputRequestHeadersVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "string":
		return visitor.VisitString(t.String)
	case "stringUnknownMap":
		return visitor.VisitStringUnknownMap(t.StringUnknownMap)
	}
}

type TransformationExecutorOutputRequestParsedQuery struct {
	typeName                                          string
	StringOptional                                    *string
	TransformationExecutorOutputRequestParsedQueryOne *TransformationExecutorOutputRequestParsedQueryOne
}

func NewTransformationExecutorOutputRequestParsedQueryFromStringOptional(value *string) *TransformationExecutorOutputRequestParsedQuery {
	return &TransformationExecutorOutputRequestParsedQuery{typeName: "stringOptional", StringOptional: value}
}

func NewTransformationExecutorOutputRequestParsedQueryFromTransformationExecutorOutputRequestParsedQueryOne(value *TransformationExecutorOutputRequestParsedQueryOne) *TransformationExecutorOutputRequestParsedQuery {
	return &TransformationExecutorOutputRequestParsedQuery{typeName: "transformationExecutorOutputRequestParsedQueryOne", TransformationExecutorOutputRequestParsedQueryOne: value}
}

func (t *TransformationExecutorOutputRequestParsedQuery) UnmarshalJSON(data []byte) error {
	var valueStringOptional *string
	if err := json.Unmarshal(data, &valueStringOptional); err == nil {
		t.typeName = "stringOptional"
		t.StringOptional = valueStringOptional
		return nil
	}
	valueTransformationExecutorOutputRequestParsedQueryOne := new(TransformationExecutorOutputRequestParsedQueryOne)
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestParsedQueryOne); err == nil {
		t.typeName = "transformationExecutorOutputRequestParsedQueryOne"
		t.TransformationExecutorOutputRequestParsedQueryOne = valueTransformationExecutorOutputRequestParsedQueryOne
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestParsedQuery) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return json.Marshal(t.StringOptional)
	case "transformationExecutorOutputRequestParsedQueryOne":
		return json.Marshal(t.TransformationExecutorOutputRequestParsedQueryOne)
	}
}

type TransformationExecutorOutputRequestParsedQueryVisitor interface {
	VisitStringOptional(*string) error
	VisitTransformationExecutorOutputRequestParsedQueryOne(*TransformationExecutorOutputRequestParsedQueryOne) error
}

func (t *TransformationExecutorOutputRequestParsedQuery) Accept(visitor TransformationExecutorOutputRequestParsedQueryVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "stringOptional":
		return visitor.VisitStringOptional(t.StringOptional)
	case "transformationExecutorOutputRequestParsedQueryOne":
		return visitor.VisitTransformationExecutorOutputRequestParsedQueryOne(t.TransformationExecutorOutputRequestParsedQueryOne)
	}
}

type TransformationExecutorOutputRequestParsedQueryOne struct {
}

type TransformationExecutorOutputRequestQuery struct {
	typeName                                             string
	TransformationExecutorOutputRequestQueryZeroOptional *TransformationExecutorOutputRequestQueryZero
	String                                               string
}

func NewTransformationExecutorOutputRequestQueryFromTransformationExecutorOutputRequestQueryZeroOptional(value *TransformationExecutorOutputRequestQueryZero) *TransformationExecutorOutputRequestQuery {
	return &TransformationExecutorOutputRequestQuery{typeName: "transformationExecutorOutputRequestQueryZeroOptional", TransformationExecutorOutputRequestQueryZeroOptional: value}
}

func NewTransformationExecutorOutputRequestQueryFromString(value string) *TransformationExecutorOutputRequestQuery {
	return &TransformationExecutorOutputRequestQuery{typeName: "string", String: value}
}

func (t *TransformationExecutorOutputRequestQuery) UnmarshalJSON(data []byte) error {
	var valueTransformationExecutorOutputRequestQueryZeroOptional *TransformationExecutorOutputRequestQueryZero
	if err := json.Unmarshal(data, &valueTransformationExecutorOutputRequestQueryZeroOptional); err == nil {
		t.typeName = "transformationExecutorOutputRequestQueryZeroOptional"
		t.TransformationExecutorOutputRequestQueryZeroOptional = valueTransformationExecutorOutputRequestQueryZeroOptional
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationExecutorOutputRequestQuery) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationExecutorOutputRequestQueryZeroOptional":
		return json.Marshal(t.TransformationExecutorOutputRequestQueryZeroOptional)
	case "string":
		return json.Marshal(t.String)
	}
}

type TransformationExecutorOutputRequestQueryVisitor interface {
	VisitTransformationExecutorOutputRequestQueryZeroOptional(*TransformationExecutorOutputRequestQueryZero) error
	VisitString(string) error
}

func (t *TransformationExecutorOutputRequestQuery) Accept(visitor TransformationExecutorOutputRequestQueryVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationExecutorOutputRequestQueryZeroOptional":
		return visitor.VisitTransformationExecutorOutputRequestQueryZeroOptional(t.TransformationExecutorOutputRequestQueryZeroOptional)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TransformationExecutorOutputRequestQueryZero struct {
}

type TransformationFailedMeta struct {
	TransformationId string `json:"transformation_id"`
}

// Transformation issue
type TransformationIssue struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// ID of the team member who last updated the issue status
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                              `json:"created_at"`
	AggregationKeys *TransformationIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *TransformationIssueReference       `json:"reference,omitempty"`
}

// Keys used as the aggregation keys a 'transformation' type issue
type TransformationIssueAggregationKeys struct {
	TransformationId []string                        `json:"transformation_id,omitempty"`
	LogLevel         TransformationExecutionLogLevel `json:"log_level,omitempty"`
}

// Transformation issue data
type TransformationIssueData struct {
	TransformationExecution *TransformationExecution `json:"transformation_execution,omitempty"`
	TriggerAttempt          *EventAttempt            `json:"trigger_attempt,omitempty"`
}

// Reference to the event request transformation an issue is being created for.
type TransformationIssueReference struct {
	TransformationExecutionId string `json:"transformation_execution_id"`
	// Deprecated but still found on historical issues
	TriggerEventRequestTransformationId *string `json:"trigger_event_request_transformation_id,omitempty"`
}

// Transformation issue
type TransformationIssueWithData struct {
	// Issue ID
	Id string `json:"id"`
	// ID of the workspace
	TeamId string      `json:"team_id"`
	Status IssueStatus `json:"status,omitempty"`
	// ISO timestamp for when the issue was last opened
	OpenedAt time.Time `json:"opened_at"`
	// ISO timestamp for when the issue was first opened
	FirstSeenAt time.Time `json:"first_seen_at"`
	// ISO timestamp for when the issue last occured
	LastSeenAt time.Time `json:"last_seen_at"`
	// ID of the team member who last updated the issue status
	LastUpdatedBy *string `json:"last_updated_by,omitempty"`
	// ISO timestamp for when the issue was dismissed
	DismissedAt    *time.Time `json:"dismissed_at,omitempty"`
	AutoResolvedAt *time.Time `json:"auto_resolved_at,omitempty"`
	MergedWith     *string    `json:"merged_with,omitempty"`
	// ISO timestamp for when the issue was last updated
	UpdatedAt string `json:"updated_at"`
	// ISO timestamp for when the issue was created
	CreatedAt       string                              `json:"created_at"`
	AggregationKeys *TransformationIssueAggregationKeys `json:"aggregation_keys,omitempty"`
	Reference       *TransformationIssueReference       `json:"reference,omitempty"`
	Data            *TransformationIssueData            `json:"data,omitempty"`
}

type TransformationListExecutionRequestDir string

const (
	TransformationListExecutionRequestDirAsc  TransformationListExecutionRequestDir = "asc"
	TransformationListExecutionRequestDirDesc TransformationListExecutionRequestDir = "desc"
)

func NewTransformationListExecutionRequestDirFromString(s string) (TransformationListExecutionRequestDir, error) {
	switch s {
	case "asc":
		return TransformationListExecutionRequestDirAsc, nil
	case "desc":
		return TransformationListExecutionRequestDirDesc, nil
	}
	var t TransformationListExecutionRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransformationListExecutionRequestDir) Ptr() *TransformationListExecutionRequestDir {
	return &t
}

type TransformationListExecutionRequestLogLevel string

const (
	TransformationListExecutionRequestLogLevelDebug TransformationListExecutionRequestLogLevel = "debug"
	TransformationListExecutionRequestLogLevelInfo  TransformationListExecutionRequestLogLevel = "info"
	TransformationListExecutionRequestLogLevelWarn  TransformationListExecutionRequestLogLevel = "warn"
	TransformationListExecutionRequestLogLevelError TransformationListExecutionRequestLogLevel = "error"
	TransformationListExecutionRequestLogLevelFatal TransformationListExecutionRequestLogLevel = "fatal"
)

func NewTransformationListExecutionRequestLogLevelFromString(s string) (TransformationListExecutionRequestLogLevel, error) {
	switch s {
	case "debug":
		return TransformationListExecutionRequestLogLevelDebug, nil
	case "info":
		return TransformationListExecutionRequestLogLevelInfo, nil
	case "warn":
		return TransformationListExecutionRequestLogLevelWarn, nil
	case "error":
		return TransformationListExecutionRequestLogLevelError, nil
	case "fatal":
		return TransformationListExecutionRequestLogLevelFatal, nil
	}
	var t TransformationListExecutionRequestLogLevel
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransformationListExecutionRequestLogLevel) Ptr() *TransformationListExecutionRequestLogLevel {
	return &t
}

type TransformationListRequestDir string

const (
	TransformationListRequestDirAsc  TransformationListRequestDir = "asc"
	TransformationListRequestDirDesc TransformationListRequestDir = "desc"
)

func NewTransformationListRequestDirFromString(s string) (TransformationListRequestDir, error) {
	switch s {
	case "asc":
		return TransformationListRequestDirAsc, nil
	case "desc":
		return TransformationListRequestDirDesc, nil
	}
	var t TransformationListRequestDir
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (t TransformationListRequestDir) Ptr() *TransformationListRequestDir {
	return &t
}

type TransformationPaginatedResult struct {
	Pagination *SeekPagination   `json:"pagination,omitempty"`
	Count      *int              `json:"count,omitempty"`
	Models     []*Transformation `json:"models,omitempty"`
}

// Request input to use for the transformation execution
type TransformationRunRequestRequest struct {
	// Headers of the request
	Headers map[string]string `json:"headers,omitempty"`
	// Body of the request
	Body *TransformationRunRequestRequestBody `json:"body,omitempty"`
	// Path of the request
	Path *string `json:"path,omitempty"`
	// String representation of the query params of the request
	Query *string `json:"query,omitempty"`
	// JSON representation of the query params
	ParsedQuery *TransformationRunRequestRequestParsedQuery `json:"parsed_query,omitempty"`
}

// Body of the request
type TransformationRunRequestRequestBody struct {
	typeName                                string
	TransformationRunRequestRequestBodyZero *TransformationRunRequestRequestBodyZero
	String                                  string
}

func NewTransformationRunRequestRequestBodyFromTransformationRunRequestRequestBodyZero(value *TransformationRunRequestRequestBodyZero) *TransformationRunRequestRequestBody {
	return &TransformationRunRequestRequestBody{typeName: "transformationRunRequestRequestBodyZero", TransformationRunRequestRequestBodyZero: value}
}

func NewTransformationRunRequestRequestBodyFromString(value string) *TransformationRunRequestRequestBody {
	return &TransformationRunRequestRequestBody{typeName: "string", String: value}
}

func (t *TransformationRunRequestRequestBody) UnmarshalJSON(data []byte) error {
	valueTransformationRunRequestRequestBodyZero := new(TransformationRunRequestRequestBodyZero)
	if err := json.Unmarshal(data, &valueTransformationRunRequestRequestBodyZero); err == nil {
		t.typeName = "transformationRunRequestRequestBodyZero"
		t.TransformationRunRequestRequestBodyZero = valueTransformationRunRequestRequestBodyZero
		return nil
	}
	var valueString string
	if err := json.Unmarshal(data, &valueString); err == nil {
		t.typeName = "string"
		t.String = valueString
		return nil
	}
	return fmt.Errorf("%s cannot be deserialized as a %T", data, t)
}

func (t TransformationRunRequestRequestBody) MarshalJSON() ([]byte, error) {
	switch t.typeName {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationRunRequestRequestBodyZero":
		return json.Marshal(t.TransformationRunRequestRequestBodyZero)
	case "string":
		return json.Marshal(t.String)
	}
}

type TransformationRunRequestRequestBodyVisitor interface {
	VisitTransformationRunRequestRequestBodyZero(*TransformationRunRequestRequestBodyZero) error
	VisitString(string) error
}

func (t *TransformationRunRequestRequestBody) Accept(visitor TransformationRunRequestRequestBodyVisitor) error {
	switch t.typeName {
	default:
		return fmt.Errorf("invalid type %s in %T", t.typeName, t)
	case "transformationRunRequestRequestBodyZero":
		return visitor.VisitTransformationRunRequestRequestBodyZero(t.TransformationRunRequestRequestBodyZero)
	case "string":
		return visitor.VisitString(t.String)
	}
}

type TransformationRunRequestRequestBodyZero struct {
}

// JSON representation of the query params
type TransformationRunRequestRequestParsedQuery struct {
}

type Verification3DEye struct {
	Configs *Verification3DEyeConfigs `json:"configs,omitempty"`
}

// The verification configs for 3dEye. Only included if the ?include=verification.configs query param is present
type Verification3DEyeConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationAdyen struct {
	Configs *VerificationAdyenConfigs `json:"configs,omitempty"`
}

// The verification configs for Adyen. Only included if the ?include=verification.configs query param is present
type VerificationAdyenConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationAkeneo struct {
	Configs *VerificationAkeneoConfigs `json:"configs,omitempty"`
}

// The verification configs for Akeneo. Only included if the ?include=verification.configs query param is present
type VerificationAkeneoConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationApiKey struct {
	Configs *VerificationApiKeyConfigs `json:"configs,omitempty"`
}

// The verification configs for API Key. Only included if the ?include=verification.configs query param is present
type VerificationApiKeyConfigs struct {
	HeaderKey string `json:"header_key"`
	ApiKey    string `json:"api_key"`
}

type VerificationAwssns struct {
	Configs *VerificationAwssnsConfigs `json:"configs,omitempty"`
}

// The verification configs for AWS SNS. Only included if the ?include=verification.configs query param is present
type VerificationAwssnsConfigs struct {
}

type VerificationBasicAuth struct {
	Configs *VerificationBasicAuthConfigs `json:"configs,omitempty"`
}

// The verification configs for Basic Auth. Only included if the ?include=verification.configs query param is present
type VerificationBasicAuthConfigs struct {
	Name     string `json:"name"`
	Password string `json:"password"`
}

type VerificationCommercelayer struct {
	Configs *VerificationCommercelayerConfigs `json:"configs,omitempty"`
}

// The verification configs for Commercelayer. Only included if the ?include=verification.configs query param is present
type VerificationCommercelayerConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

// The verification configs for the specific verification type
type VerificationConfig struct {
	Type           string
	Hmac           *VerificationHmac
	BasicAuth      *VerificationBasicAuth
	ApiKey         *VerificationApiKey
	Twitter        *VerificationTwitter
	Stripe         *VerificationStripe
	Recharge       *VerificationRecharge
	Github         *VerificationGitHub
	Shopify        *VerificationShopify
	Postmark       *VerificationPostmark
	Typeform       *VerificationTypeform
	Xero           *VerificationXero
	Svix           *VerificationSvix
	Zoom           *VerificationZoom
	Akeneo         *VerificationAkeneo
	Adyen          *VerificationAdyen
	Gitlab         *VerificationGitLab
	PropertyFinder *VerificationPropertyFinder
	Woocommerce    *VerificationWooCommerce
	Oura           *VerificationOura
	Commercelayer  *VerificationCommercelayer
	Mailgun        *VerificationMailgun
	Pipedrive      *VerificationPipedrive
	Sendgrid       *VerificationSendGrid
	Workos         *VerificationWorkOs
	Synctera       *VerificationSynctera
	AwsSns         *VerificationAwssns
	ThreeDEye      *Verification3DEye
}

func NewVerificationConfigFromHmac(value *VerificationHmac) *VerificationConfig {
	return &VerificationConfig{Type: "hmac", Hmac: value}
}

func NewVerificationConfigFromBasicAuth(value *VerificationBasicAuth) *VerificationConfig {
	return &VerificationConfig{Type: "basic_auth", BasicAuth: value}
}

func NewVerificationConfigFromApiKey(value *VerificationApiKey) *VerificationConfig {
	return &VerificationConfig{Type: "api_key", ApiKey: value}
}

func NewVerificationConfigFromTwitter(value *VerificationTwitter) *VerificationConfig {
	return &VerificationConfig{Type: "twitter", Twitter: value}
}

func NewVerificationConfigFromStripe(value *VerificationStripe) *VerificationConfig {
	return &VerificationConfig{Type: "stripe", Stripe: value}
}

func NewVerificationConfigFromRecharge(value *VerificationRecharge) *VerificationConfig {
	return &VerificationConfig{Type: "recharge", Recharge: value}
}

func NewVerificationConfigFromGithub(value *VerificationGitHub) *VerificationConfig {
	return &VerificationConfig{Type: "github", Github: value}
}

func NewVerificationConfigFromShopify(value *VerificationShopify) *VerificationConfig {
	return &VerificationConfig{Type: "shopify", Shopify: value}
}

func NewVerificationConfigFromPostmark(value *VerificationPostmark) *VerificationConfig {
	return &VerificationConfig{Type: "postmark", Postmark: value}
}

func NewVerificationConfigFromTypeform(value *VerificationTypeform) *VerificationConfig {
	return &VerificationConfig{Type: "typeform", Typeform: value}
}

func NewVerificationConfigFromXero(value *VerificationXero) *VerificationConfig {
	return &VerificationConfig{Type: "xero", Xero: value}
}

func NewVerificationConfigFromSvix(value *VerificationSvix) *VerificationConfig {
	return &VerificationConfig{Type: "svix", Svix: value}
}

func NewVerificationConfigFromZoom(value *VerificationZoom) *VerificationConfig {
	return &VerificationConfig{Type: "zoom", Zoom: value}
}

func NewVerificationConfigFromAkeneo(value *VerificationAkeneo) *VerificationConfig {
	return &VerificationConfig{Type: "akeneo", Akeneo: value}
}

func NewVerificationConfigFromAdyen(value *VerificationAdyen) *VerificationConfig {
	return &VerificationConfig{Type: "adyen", Adyen: value}
}

func NewVerificationConfigFromGitlab(value *VerificationGitLab) *VerificationConfig {
	return &VerificationConfig{Type: "gitlab", Gitlab: value}
}

func NewVerificationConfigFromPropertyFinder(value *VerificationPropertyFinder) *VerificationConfig {
	return &VerificationConfig{Type: "property-finder", PropertyFinder: value}
}

func NewVerificationConfigFromWoocommerce(value *VerificationWooCommerce) *VerificationConfig {
	return &VerificationConfig{Type: "woocommerce", Woocommerce: value}
}

func NewVerificationConfigFromOura(value *VerificationOura) *VerificationConfig {
	return &VerificationConfig{Type: "oura", Oura: value}
}

func NewVerificationConfigFromCommercelayer(value *VerificationCommercelayer) *VerificationConfig {
	return &VerificationConfig{Type: "commercelayer", Commercelayer: value}
}

func NewVerificationConfigFromMailgun(value *VerificationMailgun) *VerificationConfig {
	return &VerificationConfig{Type: "mailgun", Mailgun: value}
}

func NewVerificationConfigFromPipedrive(value *VerificationPipedrive) *VerificationConfig {
	return &VerificationConfig{Type: "pipedrive", Pipedrive: value}
}

func NewVerificationConfigFromSendgrid(value *VerificationSendGrid) *VerificationConfig {
	return &VerificationConfig{Type: "sendgrid", Sendgrid: value}
}

func NewVerificationConfigFromWorkos(value *VerificationWorkOs) *VerificationConfig {
	return &VerificationConfig{Type: "workos", Workos: value}
}

func NewVerificationConfigFromSynctera(value *VerificationSynctera) *VerificationConfig {
	return &VerificationConfig{Type: "synctera", Synctera: value}
}

func NewVerificationConfigFromAwsSns(value *VerificationAwssns) *VerificationConfig {
	return &VerificationConfig{Type: "aws_sns", AwsSns: value}
}

func NewVerificationConfigFromThreeDEye(value *Verification3DEye) *VerificationConfig {
	return &VerificationConfig{Type: "three_d_eye", ThreeDEye: value}
}

func (v *VerificationConfig) UnmarshalJSON(data []byte) error {
	var unmarshaler struct {
		Type string `json:"type"`
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	v.Type = unmarshaler.Type
	switch unmarshaler.Type {
	case "hmac":
		value := new(VerificationHmac)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Hmac = value
	case "basic_auth":
		value := new(VerificationBasicAuth)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.BasicAuth = value
	case "api_key":
		value := new(VerificationApiKey)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ApiKey = value
	case "twitter":
		value := new(VerificationTwitter)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Twitter = value
	case "stripe":
		value := new(VerificationStripe)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Stripe = value
	case "recharge":
		value := new(VerificationRecharge)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Recharge = value
	case "github":
		value := new(VerificationGitHub)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Github = value
	case "shopify":
		value := new(VerificationShopify)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Shopify = value
	case "postmark":
		value := new(VerificationPostmark)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Postmark = value
	case "typeform":
		value := new(VerificationTypeform)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Typeform = value
	case "xero":
		value := new(VerificationXero)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Xero = value
	case "svix":
		value := new(VerificationSvix)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Svix = value
	case "zoom":
		value := new(VerificationZoom)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Zoom = value
	case "akeneo":
		value := new(VerificationAkeneo)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Akeneo = value
	case "adyen":
		value := new(VerificationAdyen)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Adyen = value
	case "gitlab":
		value := new(VerificationGitLab)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Gitlab = value
	case "property-finder":
		value := new(VerificationPropertyFinder)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.PropertyFinder = value
	case "woocommerce":
		value := new(VerificationWooCommerce)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Woocommerce = value
	case "oura":
		value := new(VerificationOura)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Oura = value
	case "commercelayer":
		value := new(VerificationCommercelayer)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Commercelayer = value
	case "mailgun":
		value := new(VerificationMailgun)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Mailgun = value
	case "pipedrive":
		value := new(VerificationPipedrive)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Pipedrive = value
	case "sendgrid":
		value := new(VerificationSendGrid)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Sendgrid = value
	case "workos":
		value := new(VerificationWorkOs)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Workos = value
	case "synctera":
		value := new(VerificationSynctera)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.Synctera = value
	case "aws_sns":
		value := new(VerificationAwssns)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.AwsSns = value
	case "three_d_eye":
		value := new(Verification3DEye)
		if err := json.Unmarshal(data, &value); err != nil {
			return err
		}
		v.ThreeDEye = value
	}
	return nil
}

func (v VerificationConfig) MarshalJSON() ([]byte, error) {
	switch v.Type {
	default:
		return nil, fmt.Errorf("invalid type %s in %T", v.Type, v)
	case "hmac":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationHmac
		}{
			Type:             v.Type,
			VerificationHmac: v.Hmac,
		}
		return json.Marshal(marshaler)
	case "basic_auth":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationBasicAuth
		}{
			Type:                  v.Type,
			VerificationBasicAuth: v.BasicAuth,
		}
		return json.Marshal(marshaler)
	case "api_key":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationApiKey
		}{
			Type:               v.Type,
			VerificationApiKey: v.ApiKey,
		}
		return json.Marshal(marshaler)
	case "twitter":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationTwitter
		}{
			Type:                v.Type,
			VerificationTwitter: v.Twitter,
		}
		return json.Marshal(marshaler)
	case "stripe":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationStripe
		}{
			Type:               v.Type,
			VerificationStripe: v.Stripe,
		}
		return json.Marshal(marshaler)
	case "recharge":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationRecharge
		}{
			Type:                 v.Type,
			VerificationRecharge: v.Recharge,
		}
		return json.Marshal(marshaler)
	case "github":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationGitHub
		}{
			Type:               v.Type,
			VerificationGitHub: v.Github,
		}
		return json.Marshal(marshaler)
	case "shopify":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationShopify
		}{
			Type:                v.Type,
			VerificationShopify: v.Shopify,
		}
		return json.Marshal(marshaler)
	case "postmark":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationPostmark
		}{
			Type:                 v.Type,
			VerificationPostmark: v.Postmark,
		}
		return json.Marshal(marshaler)
	case "typeform":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationTypeform
		}{
			Type:                 v.Type,
			VerificationTypeform: v.Typeform,
		}
		return json.Marshal(marshaler)
	case "xero":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationXero
		}{
			Type:             v.Type,
			VerificationXero: v.Xero,
		}
		return json.Marshal(marshaler)
	case "svix":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationSvix
		}{
			Type:             v.Type,
			VerificationSvix: v.Svix,
		}
		return json.Marshal(marshaler)
	case "zoom":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationZoom
		}{
			Type:             v.Type,
			VerificationZoom: v.Zoom,
		}
		return json.Marshal(marshaler)
	case "akeneo":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationAkeneo
		}{
			Type:               v.Type,
			VerificationAkeneo: v.Akeneo,
		}
		return json.Marshal(marshaler)
	case "adyen":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationAdyen
		}{
			Type:              v.Type,
			VerificationAdyen: v.Adyen,
		}
		return json.Marshal(marshaler)
	case "gitlab":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationGitLab
		}{
			Type:               v.Type,
			VerificationGitLab: v.Gitlab,
		}
		return json.Marshal(marshaler)
	case "property-finder":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationPropertyFinder
		}{
			Type:                       v.Type,
			VerificationPropertyFinder: v.PropertyFinder,
		}
		return json.Marshal(marshaler)
	case "woocommerce":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationWooCommerce
		}{
			Type:                    v.Type,
			VerificationWooCommerce: v.Woocommerce,
		}
		return json.Marshal(marshaler)
	case "oura":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationOura
		}{
			Type:             v.Type,
			VerificationOura: v.Oura,
		}
		return json.Marshal(marshaler)
	case "commercelayer":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationCommercelayer
		}{
			Type:                      v.Type,
			VerificationCommercelayer: v.Commercelayer,
		}
		return json.Marshal(marshaler)
	case "mailgun":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationMailgun
		}{
			Type:                v.Type,
			VerificationMailgun: v.Mailgun,
		}
		return json.Marshal(marshaler)
	case "pipedrive":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationPipedrive
		}{
			Type:                  v.Type,
			VerificationPipedrive: v.Pipedrive,
		}
		return json.Marshal(marshaler)
	case "sendgrid":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationSendGrid
		}{
			Type:                 v.Type,
			VerificationSendGrid: v.Sendgrid,
		}
		return json.Marshal(marshaler)
	case "workos":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationWorkOs
		}{
			Type:               v.Type,
			VerificationWorkOs: v.Workos,
		}
		return json.Marshal(marshaler)
	case "synctera":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationSynctera
		}{
			Type:                 v.Type,
			VerificationSynctera: v.Synctera,
		}
		return json.Marshal(marshaler)
	case "aws_sns":
		var marshaler = struct {
			Type string `json:"type"`
			*VerificationAwssns
		}{
			Type:               v.Type,
			VerificationAwssns: v.AwsSns,
		}
		return json.Marshal(marshaler)
	case "three_d_eye":
		var marshaler = struct {
			Type string `json:"type"`
			*Verification3DEye
		}{
			Type:              v.Type,
			Verification3DEye: v.ThreeDEye,
		}
		return json.Marshal(marshaler)
	}
}

type VerificationConfigVisitor interface {
	VisitHmac(*VerificationHmac) error
	VisitBasicAuth(*VerificationBasicAuth) error
	VisitApiKey(*VerificationApiKey) error
	VisitTwitter(*VerificationTwitter) error
	VisitStripe(*VerificationStripe) error
	VisitRecharge(*VerificationRecharge) error
	VisitGithub(*VerificationGitHub) error
	VisitShopify(*VerificationShopify) error
	VisitPostmark(*VerificationPostmark) error
	VisitTypeform(*VerificationTypeform) error
	VisitXero(*VerificationXero) error
	VisitSvix(*VerificationSvix) error
	VisitZoom(*VerificationZoom) error
	VisitAkeneo(*VerificationAkeneo) error
	VisitAdyen(*VerificationAdyen) error
	VisitGitlab(*VerificationGitLab) error
	VisitPropertyFinder(*VerificationPropertyFinder) error
	VisitWoocommerce(*VerificationWooCommerce) error
	VisitOura(*VerificationOura) error
	VisitCommercelayer(*VerificationCommercelayer) error
	VisitMailgun(*VerificationMailgun) error
	VisitPipedrive(*VerificationPipedrive) error
	VisitSendgrid(*VerificationSendGrid) error
	VisitWorkos(*VerificationWorkOs) error
	VisitSynctera(*VerificationSynctera) error
	VisitAwsSns(*VerificationAwssns) error
	VisitThreeDEye(*Verification3DEye) error
}

func (v *VerificationConfig) Accept(visitor VerificationConfigVisitor) error {
	switch v.Type {
	default:
		return fmt.Errorf("invalid type %s in %T", v.Type, v)
	case "hmac":
		return visitor.VisitHmac(v.Hmac)
	case "basic_auth":
		return visitor.VisitBasicAuth(v.BasicAuth)
	case "api_key":
		return visitor.VisitApiKey(v.ApiKey)
	case "twitter":
		return visitor.VisitTwitter(v.Twitter)
	case "stripe":
		return visitor.VisitStripe(v.Stripe)
	case "recharge":
		return visitor.VisitRecharge(v.Recharge)
	case "github":
		return visitor.VisitGithub(v.Github)
	case "shopify":
		return visitor.VisitShopify(v.Shopify)
	case "postmark":
		return visitor.VisitPostmark(v.Postmark)
	case "typeform":
		return visitor.VisitTypeform(v.Typeform)
	case "xero":
		return visitor.VisitXero(v.Xero)
	case "svix":
		return visitor.VisitSvix(v.Svix)
	case "zoom":
		return visitor.VisitZoom(v.Zoom)
	case "akeneo":
		return visitor.VisitAkeneo(v.Akeneo)
	case "adyen":
		return visitor.VisitAdyen(v.Adyen)
	case "gitlab":
		return visitor.VisitGitlab(v.Gitlab)
	case "property-finder":
		return visitor.VisitPropertyFinder(v.PropertyFinder)
	case "woocommerce":
		return visitor.VisitWoocommerce(v.Woocommerce)
	case "oura":
		return visitor.VisitOura(v.Oura)
	case "commercelayer":
		return visitor.VisitCommercelayer(v.Commercelayer)
	case "mailgun":
		return visitor.VisitMailgun(v.Mailgun)
	case "pipedrive":
		return visitor.VisitPipedrive(v.Pipedrive)
	case "sendgrid":
		return visitor.VisitSendgrid(v.Sendgrid)
	case "workos":
		return visitor.VisitWorkos(v.Workos)
	case "synctera":
		return visitor.VisitSynctera(v.Synctera)
	case "aws_sns":
		return visitor.VisitAwsSns(v.AwsSns)
	case "three_d_eye":
		return visitor.VisitThreeDEye(v.ThreeDEye)
	}
}

type VerificationGitHub struct {
	Configs *VerificationGitHubConfigs `json:"configs,omitempty"`
}

// The verification configs for GitHub. Only included if the ?include=verification.configs query param is present
type VerificationGitHubConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationGitLab struct {
	Configs *VerificationGitLabConfigs `json:"configs,omitempty"`
}

// The verification configs for GitLab. Only included if the ?include=verification.configs query param is present
type VerificationGitLabConfigs struct {
	ApiKey string `json:"api_key"`
}

type VerificationHmac struct {
	Configs *VerificationHmacConfigs `json:"configs,omitempty"`
}

// The verification configs for HMAC. Only included if the ?include=verification.configs query param is present
type VerificationHmacConfigs struct {
	WebhookSecretKey string                          `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms                  `json:"algorithm,omitempty"`
	HeaderKey        string                          `json:"header_key"`
	Encoding         VerificationHmacConfigsEncoding `json:"encoding,omitempty"`
}

type VerificationHmacConfigsEncoding string

const (
	VerificationHmacConfigsEncodingBase64 VerificationHmacConfigsEncoding = "base64"
	VerificationHmacConfigsEncodingHex    VerificationHmacConfigsEncoding = "hex"
)

func NewVerificationHmacConfigsEncodingFromString(s string) (VerificationHmacConfigsEncoding, error) {
	switch s {
	case "base64":
		return VerificationHmacConfigsEncodingBase64, nil
	case "hex":
		return VerificationHmacConfigsEncodingHex, nil
	}
	var t VerificationHmacConfigsEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationHmacConfigsEncoding) Ptr() *VerificationHmacConfigsEncoding {
	return &v
}

type VerificationMailgun struct {
	Configs *VerificationMailgunConfigs `json:"configs,omitempty"`
}

// The verification configs for Mailgun. Only included if the ?include=verification.configs query param is present
type VerificationMailgunConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationOura struct {
	Configs *VerificationOuraConfigs `json:"configs,omitempty"`
}

// The verification configs for Oura. Only included if the ?include=verification.configs query param is present
type VerificationOuraConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationPipedrive struct {
	Configs *VerificationPipedriveConfigs `json:"configs,omitempty"`
}

// The verification configs for Pipedrive. Only included if the ?include=verification.configs query param is present
type VerificationPipedriveConfigs struct {
	Name     string `json:"name"`
	Password string `json:"password"`
}

type VerificationPostmark struct {
	Configs *VerificationPostmarkConfigs `json:"configs,omitempty"`
}

// The verification configs for Postmark. Only included if the ?include=verification.configs query param is present
type VerificationPostmarkConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationPropertyFinder struct {
	Configs *VerificationPropertyFinderConfigs `json:"configs,omitempty"`
}

// The verification configs for Property Finder. Only included if the ?include=verification.configs query param is present
type VerificationPropertyFinderConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationRecharge struct {
	Configs *VerificationRechargeConfigs `json:"configs,omitempty"`
}

// The verification configs for Recharge. Only included if the ?include=verification.configs query param is present
type VerificationRechargeConfigs struct {
	WebhookSecretKey string                              `json:"webhook_secret_key"`
	Algorithm        HmacAlgorithms                      `json:"algorithm,omitempty"`
	HeaderKey        string                              `json:"header_key"`
	Encoding         VerificationRechargeConfigsEncoding `json:"encoding,omitempty"`
}

type VerificationRechargeConfigsEncoding string

const (
	VerificationRechargeConfigsEncodingBase64 VerificationRechargeConfigsEncoding = "base64"
	VerificationRechargeConfigsEncodingHex    VerificationRechargeConfigsEncoding = "hex"
)

func NewVerificationRechargeConfigsEncodingFromString(s string) (VerificationRechargeConfigsEncoding, error) {
	switch s {
	case "base64":
		return VerificationRechargeConfigsEncodingBase64, nil
	case "hex":
		return VerificationRechargeConfigsEncodingHex, nil
	}
	var t VerificationRechargeConfigsEncoding
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationRechargeConfigsEncoding) Ptr() *VerificationRechargeConfigsEncoding {
	return &v
}

type VerificationSendGrid struct {
	Configs *VerificationSendGridConfigs `json:"configs,omitempty"`
}

// The verification configs for SendGrid. Only included if the ?include=verification.configs query param is present
type VerificationSendGridConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationShopify struct {
	Configs *VerificationShopifyConfigs `json:"configs,omitempty"`
}

// The verification configs for Shopify. Only included if the ?include=verification.configs query param is present
type VerificationShopifyConfigs struct {
	WebhookSecretKey string                                     `json:"webhook_secret_key"`
	RateLimitPeriod  *VerificationShopifyConfigsRateLimitPeriod `json:"rate_limit_period,omitempty"`
	RateLimit        *float64                                   `json:"rate_limit,omitempty"`
	ApiKey           *string                                    `json:"api_key,omitempty"`
	ApiSecret        *string                                    `json:"api_secret,omitempty"`
	Shop             *string                                    `json:"shop,omitempty"`
}

type VerificationShopifyConfigsRateLimitPeriod string

const (
	VerificationShopifyConfigsRateLimitPeriodMinute VerificationShopifyConfigsRateLimitPeriod = "minute"
	VerificationShopifyConfigsRateLimitPeriodSecond VerificationShopifyConfigsRateLimitPeriod = "second"
)

func NewVerificationShopifyConfigsRateLimitPeriodFromString(s string) (VerificationShopifyConfigsRateLimitPeriod, error) {
	switch s {
	case "minute":
		return VerificationShopifyConfigsRateLimitPeriodMinute, nil
	case "second":
		return VerificationShopifyConfigsRateLimitPeriodSecond, nil
	}
	var t VerificationShopifyConfigsRateLimitPeriod
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (v VerificationShopifyConfigsRateLimitPeriod) Ptr() *VerificationShopifyConfigsRateLimitPeriod {
	return &v
}

type VerificationStripe struct {
	Configs *VerificationStripeConfigs `json:"configs,omitempty"`
}

// The verification configs for Stripe. Only included if the ?include=verification.configs query param is present
type VerificationStripeConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSvix struct {
	Configs *VerificationSvixConfigs `json:"configs,omitempty"`
}

// The verification configs for Svix. Only included if the ?include=verification.configs query param is present
type VerificationSvixConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationSynctera struct {
	Configs *VerificationSyncteraConfigs `json:"configs,omitempty"`
}

// The verification configs for Synctera. Only included if the ?include=verification.configs query param is present
type VerificationSyncteraConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationTwitter struct {
	Configs *VerificationTwitterConfigs `json:"configs,omitempty"`
}

// The verification configs for Twitter. Only included if the ?include=verification.configs query param is present
type VerificationTwitterConfigs struct {
	ApiKey string `json:"api_key"`
}

type VerificationTypeform struct {
	Configs *VerificationTypeformConfigs `json:"configs,omitempty"`
}

// The verification configs for Typeform. Only included if the ?include=verification.configs query param is present
type VerificationTypeformConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationWooCommerce struct {
	Configs *VerificationWooCommerceConfigs `json:"configs,omitempty"`
}

// The verification configs for WooCommerce. Only included if the ?include=verification.configs query param is present
type VerificationWooCommerceConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationWorkOs struct {
	Configs *VerificationWorkOsConfigs `json:"configs,omitempty"`
}

// The verification configs for WorkOS. Only included if the ?include=verification.configs query param is present
type VerificationWorkOsConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationXero struct {
	Configs *VerificationXeroConfigs `json:"configs,omitempty"`
}

// The verification configs for Xero. Only included if the ?include=verification.configs query param is present
type VerificationXeroConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}

type VerificationZoom struct {
	Configs *VerificationZoomConfigs `json:"configs,omitempty"`
}

// The verification configs for Zoom. Only included if the ?include=verification.configs query param is present
type VerificationZoomConfigs struct {
	WebhookSecretKey string `json:"webhook_secret_key"`
}
